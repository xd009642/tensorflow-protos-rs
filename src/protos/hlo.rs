// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/compiler/xla/service/hlo.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct HloInstructionProto {
    // message fields
    pub name: ::std::string::String,
    pub opcode: ::std::string::String,
    pub shape: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    pub metadata: ::protobuf::SingularPtrField<super::xla_data::OpMetadata>,
    pub literal: ::protobuf::SingularPtrField<super::xla_data::LiteralProto>,
    pub parameter_number: i64,
    pub fusion_kind: ::std::string::String,
    pub tuple_index: i64,
    pub dimensions: ::std::vec::Vec<i64>,
    pub window: ::protobuf::SingularPtrField<super::xla_data::Window>,
    pub convolution_dimension_numbers: ::protobuf::SingularPtrField<super::xla_data::ConvolutionDimensionNumbers>,
    pub feature_group_count: i64,
    pub batch_group_count: i64,
    pub slice_dimensions: ::protobuf::RepeatedField<HloInstructionProto_SliceDimensions>,
    pub exponent_bits: i32,
    pub mantissa_bits: i32,
    pub dynamic_slice_sizes: ::std::vec::Vec<i64>,
    pub padding_config: ::protobuf::SingularPtrField<super::xla_data::PaddingConfig>,
    pub outfeed_config: ::std::vec::Vec<u8>,
    pub distribution: super::xla_data::RandomDistribution,
    pub epsilon: f32,
    pub feature_index: i64,
    pub channel_id: i64,
    pub infeed_config: ::std::vec::Vec<u8>,
    pub custom_call_target: ::std::string::String,
    pub outfeed_shape: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    pub dot_dimension_numbers: ::protobuf::SingularPtrField<super::xla_data::DotDimensionNumbers>,
    pub fft_type: super::xla_data::FftType,
    pub fft_length: ::std::vec::Vec<i64>,
    pub comparison_direction: ::std::string::String,
    pub gather_dimension_numbers: ::protobuf::SingularPtrField<super::xla_data::GatherDimensionNumbers>,
    pub gather_slice_sizes: ::std::vec::Vec<i64>,
    pub channel_name: ::std::string::String,
    pub cost_estimate_ns: i64,
    pub id: i64,
    pub operand_ids: ::std::vec::Vec<i64>,
    pub control_predecessor_ids: ::std::vec::Vec<i64>,
    pub called_computation_ids: ::std::vec::Vec<i64>,
    pub sharding: ::protobuf::SingularPtrField<super::xla_data::OpSharding>,
    pub backend_config: ::std::string::String,
    pub replica_groups: ::protobuf::RepeatedField<super::xla_data::ReplicaGroup>,
    pub all_reduce_id: i64,
    pub is_host_transfer: bool,
    pub is_stable: bool,
    pub scatter_dimension_numbers: ::protobuf::SingularPtrField<super::xla_data::ScatterDimensionNumbers>,
    pub precision_config: ::protobuf::SingularPtrField<super::xla_data::PrecisionConfig>,
    pub source_target_pairs: ::protobuf::RepeatedField<super::xla_data::SourceTarget>,
    pub domain_entry_sharding: ::protobuf::SingularPtrField<super::xla_data::OpSharding>,
    pub domain_exit_sharding: ::protobuf::SingularPtrField<super::xla_data::OpSharding>,
    pub constrain_layout: bool,
    pub operand_shapes_with_layout: ::protobuf::RepeatedField<super::xla_data::ShapeProto>,
    pub triangular_solve_options: ::protobuf::SingularPtrField<super::xla_data::TriangularSolveOptions>,
    pub cholesky_options: ::protobuf::SingularPtrField<super::xla_data::CholeskyOptions>,
    pub parameter_replication: ::protobuf::SingularPtrField<super::xla_data::ParameterReplication>,
    pub outer_dimension_partitions: ::std::vec::Vec<i64>,
    pub custom_call_has_side_effect: bool,
    pub delta: i64,
    pub indices_are_sorted: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloInstructionProto {
    fn default() -> &'a HloInstructionProto {
        <HloInstructionProto as ::protobuf::Message>::default_instance()
    }
}

impl HloInstructionProto {
    pub fn new() -> HloInstructionProto {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string opcode = 2;


    pub fn get_opcode(&self) -> &str {
        &self.opcode
    }
    pub fn clear_opcode(&mut self) {
        self.opcode.clear();
    }

    // Param is passed by value, moved
    pub fn set_opcode(&mut self, v: ::std::string::String) {
        self.opcode = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_opcode(&mut self) -> &mut ::std::string::String {
        &mut self.opcode
    }

    // Take field
    pub fn take_opcode(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.opcode, ::std::string::String::new())
    }

    // .xla.ShapeProto shape = 3;


    pub fn get_shape(&self) -> &super::xla_data::ShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: super::xla_data::ShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> super::xla_data::ShapeProto {
        self.shape.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }

    // .xla.OpMetadata metadata = 7;


    pub fn get_metadata(&self) -> &super::xla_data::OpMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <super::xla_data::OpMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::xla_data::OpMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::xla_data::OpMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::xla_data::OpMetadata {
        self.metadata.take().unwrap_or_else(|| super::xla_data::OpMetadata::new())
    }

    // .xla.LiteralProto literal = 8;


    pub fn get_literal(&self) -> &super::xla_data::LiteralProto {
        self.literal.as_ref().unwrap_or_else(|| <super::xla_data::LiteralProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_literal(&mut self) {
        self.literal.clear();
    }

    pub fn has_literal(&self) -> bool {
        self.literal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_literal(&mut self, v: super::xla_data::LiteralProto) {
        self.literal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_literal(&mut self) -> &mut super::xla_data::LiteralProto {
        if self.literal.is_none() {
            self.literal.set_default();
        }
        self.literal.as_mut().unwrap()
    }

    // Take field
    pub fn take_literal(&mut self) -> super::xla_data::LiteralProto {
        self.literal.take().unwrap_or_else(|| super::xla_data::LiteralProto::new())
    }

    // int64 parameter_number = 9;


    pub fn get_parameter_number(&self) -> i64 {
        self.parameter_number
    }
    pub fn clear_parameter_number(&mut self) {
        self.parameter_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_parameter_number(&mut self, v: i64) {
        self.parameter_number = v;
    }

    // string fusion_kind = 11;


    pub fn get_fusion_kind(&self) -> &str {
        &self.fusion_kind
    }
    pub fn clear_fusion_kind(&mut self) {
        self.fusion_kind.clear();
    }

    // Param is passed by value, moved
    pub fn set_fusion_kind(&mut self, v: ::std::string::String) {
        self.fusion_kind = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fusion_kind(&mut self) -> &mut ::std::string::String {
        &mut self.fusion_kind
    }

    // Take field
    pub fn take_fusion_kind(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fusion_kind, ::std::string::String::new())
    }

    // int64 tuple_index = 13;


    pub fn get_tuple_index(&self) -> i64 {
        self.tuple_index
    }
    pub fn clear_tuple_index(&mut self) {
        self.tuple_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_tuple_index(&mut self, v: i64) {
        self.tuple_index = v;
    }

    // repeated int64 dimensions = 14;


    pub fn get_dimensions(&self) -> &[i64] {
        &self.dimensions
    }
    pub fn clear_dimensions(&mut self) {
        self.dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dimensions
    }

    // Take field
    pub fn take_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dimensions, ::std::vec::Vec::new())
    }

    // .xla.Window window = 15;


    pub fn get_window(&self) -> &super::xla_data::Window {
        self.window.as_ref().unwrap_or_else(|| <super::xla_data::Window as ::protobuf::Message>::default_instance())
    }
    pub fn clear_window(&mut self) {
        self.window.clear();
    }

    pub fn has_window(&self) -> bool {
        self.window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window(&mut self, v: super::xla_data::Window) {
        self.window = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window(&mut self) -> &mut super::xla_data::Window {
        if self.window.is_none() {
            self.window.set_default();
        }
        self.window.as_mut().unwrap()
    }

    // Take field
    pub fn take_window(&mut self) -> super::xla_data::Window {
        self.window.take().unwrap_or_else(|| super::xla_data::Window::new())
    }

    // .xla.ConvolutionDimensionNumbers convolution_dimension_numbers = 16;


    pub fn get_convolution_dimension_numbers(&self) -> &super::xla_data::ConvolutionDimensionNumbers {
        self.convolution_dimension_numbers.as_ref().unwrap_or_else(|| <super::xla_data::ConvolutionDimensionNumbers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_convolution_dimension_numbers(&mut self) {
        self.convolution_dimension_numbers.clear();
    }

    pub fn has_convolution_dimension_numbers(&self) -> bool {
        self.convolution_dimension_numbers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_convolution_dimension_numbers(&mut self, v: super::xla_data::ConvolutionDimensionNumbers) {
        self.convolution_dimension_numbers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_convolution_dimension_numbers(&mut self) -> &mut super::xla_data::ConvolutionDimensionNumbers {
        if self.convolution_dimension_numbers.is_none() {
            self.convolution_dimension_numbers.set_default();
        }
        self.convolution_dimension_numbers.as_mut().unwrap()
    }

    // Take field
    pub fn take_convolution_dimension_numbers(&mut self) -> super::xla_data::ConvolutionDimensionNumbers {
        self.convolution_dimension_numbers.take().unwrap_or_else(|| super::xla_data::ConvolutionDimensionNumbers::new())
    }

    // int64 feature_group_count = 50;


    pub fn get_feature_group_count(&self) -> i64 {
        self.feature_group_count
    }
    pub fn clear_feature_group_count(&mut self) {
        self.feature_group_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_feature_group_count(&mut self, v: i64) {
        self.feature_group_count = v;
    }

    // int64 batch_group_count = 58;


    pub fn get_batch_group_count(&self) -> i64 {
        self.batch_group_count
    }
    pub fn clear_batch_group_count(&mut self) {
        self.batch_group_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_batch_group_count(&mut self, v: i64) {
        self.batch_group_count = v;
    }

    // repeated .xla.HloInstructionProto.SliceDimensions slice_dimensions = 17;


    pub fn get_slice_dimensions(&self) -> &[HloInstructionProto_SliceDimensions] {
        &self.slice_dimensions
    }
    pub fn clear_slice_dimensions(&mut self) {
        self.slice_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_slice_dimensions(&mut self, v: ::protobuf::RepeatedField<HloInstructionProto_SliceDimensions>) {
        self.slice_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_slice_dimensions(&mut self) -> &mut ::protobuf::RepeatedField<HloInstructionProto_SliceDimensions> {
        &mut self.slice_dimensions
    }

    // Take field
    pub fn take_slice_dimensions(&mut self) -> ::protobuf::RepeatedField<HloInstructionProto_SliceDimensions> {
        ::std::mem::replace(&mut self.slice_dimensions, ::protobuf::RepeatedField::new())
    }

    // int32 exponent_bits = 18;


    pub fn get_exponent_bits(&self) -> i32 {
        self.exponent_bits
    }
    pub fn clear_exponent_bits(&mut self) {
        self.exponent_bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_exponent_bits(&mut self, v: i32) {
        self.exponent_bits = v;
    }

    // int32 mantissa_bits = 19;


    pub fn get_mantissa_bits(&self) -> i32 {
        self.mantissa_bits
    }
    pub fn clear_mantissa_bits(&mut self) {
        self.mantissa_bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_mantissa_bits(&mut self, v: i32) {
        self.mantissa_bits = v;
    }

    // repeated int64 dynamic_slice_sizes = 20;


    pub fn get_dynamic_slice_sizes(&self) -> &[i64] {
        &self.dynamic_slice_sizes
    }
    pub fn clear_dynamic_slice_sizes(&mut self) {
        self.dynamic_slice_sizes.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_slice_sizes(&mut self, v: ::std::vec::Vec<i64>) {
        self.dynamic_slice_sizes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_slice_sizes(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dynamic_slice_sizes
    }

    // Take field
    pub fn take_dynamic_slice_sizes(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dynamic_slice_sizes, ::std::vec::Vec::new())
    }

    // .xla.PaddingConfig padding_config = 21;


    pub fn get_padding_config(&self) -> &super::xla_data::PaddingConfig {
        self.padding_config.as_ref().unwrap_or_else(|| <super::xla_data::PaddingConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_padding_config(&mut self) {
        self.padding_config.clear();
    }

    pub fn has_padding_config(&self) -> bool {
        self.padding_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_padding_config(&mut self, v: super::xla_data::PaddingConfig) {
        self.padding_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_padding_config(&mut self) -> &mut super::xla_data::PaddingConfig {
        if self.padding_config.is_none() {
            self.padding_config.set_default();
        }
        self.padding_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_padding_config(&mut self) -> super::xla_data::PaddingConfig {
        self.padding_config.take().unwrap_or_else(|| super::xla_data::PaddingConfig::new())
    }

    // bytes outfeed_config = 22;


    pub fn get_outfeed_config(&self) -> &[u8] {
        &self.outfeed_config
    }
    pub fn clear_outfeed_config(&mut self) {
        self.outfeed_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_outfeed_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.outfeed_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outfeed_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.outfeed_config
    }

    // Take field
    pub fn take_outfeed_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.outfeed_config, ::std::vec::Vec::new())
    }

    // .xla.RandomDistribution distribution = 23;


    pub fn get_distribution(&self) -> super::xla_data::RandomDistribution {
        self.distribution
    }
    pub fn clear_distribution(&mut self) {
        self.distribution = super::xla_data::RandomDistribution::RNG_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_distribution(&mut self, v: super::xla_data::RandomDistribution) {
        self.distribution = v;
    }

    // float epsilon = 24;


    pub fn get_epsilon(&self) -> f32 {
        self.epsilon
    }
    pub fn clear_epsilon(&mut self) {
        self.epsilon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_epsilon(&mut self, v: f32) {
        self.epsilon = v;
    }

    // int64 feature_index = 25;


    pub fn get_feature_index(&self) -> i64 {
        self.feature_index
    }
    pub fn clear_feature_index(&mut self) {
        self.feature_index = 0;
    }

    // Param is passed by value, moved
    pub fn set_feature_index(&mut self, v: i64) {
        self.feature_index = v;
    }

    // int64 channel_id = 26;


    pub fn get_channel_id(&self) -> i64 {
        self.channel_id
    }
    pub fn clear_channel_id(&mut self) {
        self.channel_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_channel_id(&mut self, v: i64) {
        self.channel_id = v;
    }

    // bytes infeed_config = 27;


    pub fn get_infeed_config(&self) -> &[u8] {
        &self.infeed_config
    }
    pub fn clear_infeed_config(&mut self) {
        self.infeed_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_infeed_config(&mut self, v: ::std::vec::Vec<u8>) {
        self.infeed_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_infeed_config(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.infeed_config
    }

    // Take field
    pub fn take_infeed_config(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.infeed_config, ::std::vec::Vec::new())
    }

    // string custom_call_target = 28;


    pub fn get_custom_call_target(&self) -> &str {
        &self.custom_call_target
    }
    pub fn clear_custom_call_target(&mut self) {
        self.custom_call_target.clear();
    }

    // Param is passed by value, moved
    pub fn set_custom_call_target(&mut self, v: ::std::string::String) {
        self.custom_call_target = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_custom_call_target(&mut self) -> &mut ::std::string::String {
        &mut self.custom_call_target
    }

    // Take field
    pub fn take_custom_call_target(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.custom_call_target, ::std::string::String::new())
    }

    // .xla.ShapeProto outfeed_shape = 29;


    pub fn get_outfeed_shape(&self) -> &super::xla_data::ShapeProto {
        self.outfeed_shape.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_outfeed_shape(&mut self) {
        self.outfeed_shape.clear();
    }

    pub fn has_outfeed_shape(&self) -> bool {
        self.outfeed_shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_outfeed_shape(&mut self, v: super::xla_data::ShapeProto) {
        self.outfeed_shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_outfeed_shape(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.outfeed_shape.is_none() {
            self.outfeed_shape.set_default();
        }
        self.outfeed_shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_outfeed_shape(&mut self) -> super::xla_data::ShapeProto {
        self.outfeed_shape.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }

    // .xla.DotDimensionNumbers dot_dimension_numbers = 30;


    pub fn get_dot_dimension_numbers(&self) -> &super::xla_data::DotDimensionNumbers {
        self.dot_dimension_numbers.as_ref().unwrap_or_else(|| <super::xla_data::DotDimensionNumbers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dot_dimension_numbers(&mut self) {
        self.dot_dimension_numbers.clear();
    }

    pub fn has_dot_dimension_numbers(&self) -> bool {
        self.dot_dimension_numbers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dot_dimension_numbers(&mut self, v: super::xla_data::DotDimensionNumbers) {
        self.dot_dimension_numbers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dot_dimension_numbers(&mut self) -> &mut super::xla_data::DotDimensionNumbers {
        if self.dot_dimension_numbers.is_none() {
            self.dot_dimension_numbers.set_default();
        }
        self.dot_dimension_numbers.as_mut().unwrap()
    }

    // Take field
    pub fn take_dot_dimension_numbers(&mut self) -> super::xla_data::DotDimensionNumbers {
        self.dot_dimension_numbers.take().unwrap_or_else(|| super::xla_data::DotDimensionNumbers::new())
    }

    // .xla.FftType fft_type = 31;


    pub fn get_fft_type(&self) -> super::xla_data::FftType {
        self.fft_type
    }
    pub fn clear_fft_type(&mut self) {
        self.fft_type = super::xla_data::FftType::FFT;
    }

    // Param is passed by value, moved
    pub fn set_fft_type(&mut self, v: super::xla_data::FftType) {
        self.fft_type = v;
    }

    // repeated int64 fft_length = 32;


    pub fn get_fft_length(&self) -> &[i64] {
        &self.fft_length
    }
    pub fn clear_fft_length(&mut self) {
        self.fft_length.clear();
    }

    // Param is passed by value, moved
    pub fn set_fft_length(&mut self, v: ::std::vec::Vec<i64>) {
        self.fft_length = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fft_length(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.fft_length
    }

    // Take field
    pub fn take_fft_length(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.fft_length, ::std::vec::Vec::new())
    }

    // string comparison_direction = 63;


    pub fn get_comparison_direction(&self) -> &str {
        &self.comparison_direction
    }
    pub fn clear_comparison_direction(&mut self) {
        self.comparison_direction.clear();
    }

    // Param is passed by value, moved
    pub fn set_comparison_direction(&mut self, v: ::std::string::String) {
        self.comparison_direction = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comparison_direction(&mut self) -> &mut ::std::string::String {
        &mut self.comparison_direction
    }

    // Take field
    pub fn take_comparison_direction(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comparison_direction, ::std::string::String::new())
    }

    // .xla.GatherDimensionNumbers gather_dimension_numbers = 33;


    pub fn get_gather_dimension_numbers(&self) -> &super::xla_data::GatherDimensionNumbers {
        self.gather_dimension_numbers.as_ref().unwrap_or_else(|| <super::xla_data::GatherDimensionNumbers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gather_dimension_numbers(&mut self) {
        self.gather_dimension_numbers.clear();
    }

    pub fn has_gather_dimension_numbers(&self) -> bool {
        self.gather_dimension_numbers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gather_dimension_numbers(&mut self, v: super::xla_data::GatherDimensionNumbers) {
        self.gather_dimension_numbers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gather_dimension_numbers(&mut self) -> &mut super::xla_data::GatherDimensionNumbers {
        if self.gather_dimension_numbers.is_none() {
            self.gather_dimension_numbers.set_default();
        }
        self.gather_dimension_numbers.as_mut().unwrap()
    }

    // Take field
    pub fn take_gather_dimension_numbers(&mut self) -> super::xla_data::GatherDimensionNumbers {
        self.gather_dimension_numbers.take().unwrap_or_else(|| super::xla_data::GatherDimensionNumbers::new())
    }

    // repeated int64 gather_slice_sizes = 34;


    pub fn get_gather_slice_sizes(&self) -> &[i64] {
        &self.gather_slice_sizes
    }
    pub fn clear_gather_slice_sizes(&mut self) {
        self.gather_slice_sizes.clear();
    }

    // Param is passed by value, moved
    pub fn set_gather_slice_sizes(&mut self, v: ::std::vec::Vec<i64>) {
        self.gather_slice_sizes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_gather_slice_sizes(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.gather_slice_sizes
    }

    // Take field
    pub fn take_gather_slice_sizes(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.gather_slice_sizes, ::std::vec::Vec::new())
    }

    // string channel_name = 41;


    pub fn get_channel_name(&self) -> &str {
        &self.channel_name
    }
    pub fn clear_channel_name(&mut self) {
        self.channel_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_channel_name(&mut self, v: ::std::string::String) {
        self.channel_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel_name(&mut self) -> &mut ::std::string::String {
        &mut self.channel_name
    }

    // Take field
    pub fn take_channel_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.channel_name, ::std::string::String::new())
    }

    // int64 cost_estimate_ns = 42;


    pub fn get_cost_estimate_ns(&self) -> i64 {
        self.cost_estimate_ns
    }
    pub fn clear_cost_estimate_ns(&mut self) {
        self.cost_estimate_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_cost_estimate_ns(&mut self, v: i64) {
        self.cost_estimate_ns = v;
    }

    // int64 id = 35;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // repeated int64 operand_ids = 36;


    pub fn get_operand_ids(&self) -> &[i64] {
        &self.operand_ids
    }
    pub fn clear_operand_ids(&mut self) {
        self.operand_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_operand_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.operand_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operand_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.operand_ids
    }

    // Take field
    pub fn take_operand_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.operand_ids, ::std::vec::Vec::new())
    }

    // repeated int64 control_predecessor_ids = 37;


    pub fn get_control_predecessor_ids(&self) -> &[i64] {
        &self.control_predecessor_ids
    }
    pub fn clear_control_predecessor_ids(&mut self) {
        self.control_predecessor_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_control_predecessor_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.control_predecessor_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_control_predecessor_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.control_predecessor_ids
    }

    // Take field
    pub fn take_control_predecessor_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.control_predecessor_ids, ::std::vec::Vec::new())
    }

    // repeated int64 called_computation_ids = 38;


    pub fn get_called_computation_ids(&self) -> &[i64] {
        &self.called_computation_ids
    }
    pub fn clear_called_computation_ids(&mut self) {
        self.called_computation_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_called_computation_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.called_computation_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_called_computation_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.called_computation_ids
    }

    // Take field
    pub fn take_called_computation_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.called_computation_ids, ::std::vec::Vec::new())
    }

    // .xla.OpSharding sharding = 40;


    pub fn get_sharding(&self) -> &super::xla_data::OpSharding {
        self.sharding.as_ref().unwrap_or_else(|| <super::xla_data::OpSharding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sharding(&mut self) {
        self.sharding.clear();
    }

    pub fn has_sharding(&self) -> bool {
        self.sharding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sharding(&mut self, v: super::xla_data::OpSharding) {
        self.sharding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sharding(&mut self) -> &mut super::xla_data::OpSharding {
        if self.sharding.is_none() {
            self.sharding.set_default();
        }
        self.sharding.as_mut().unwrap()
    }

    // Take field
    pub fn take_sharding(&mut self) -> super::xla_data::OpSharding {
        self.sharding.take().unwrap_or_else(|| super::xla_data::OpSharding::new())
    }

    // string backend_config = 43;


    pub fn get_backend_config(&self) -> &str {
        &self.backend_config
    }
    pub fn clear_backend_config(&mut self) {
        self.backend_config.clear();
    }

    // Param is passed by value, moved
    pub fn set_backend_config(&mut self, v: ::std::string::String) {
        self.backend_config = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_backend_config(&mut self) -> &mut ::std::string::String {
        &mut self.backend_config
    }

    // Take field
    pub fn take_backend_config(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.backend_config, ::std::string::String::new())
    }

    // repeated .xla.ReplicaGroup replica_groups = 49;


    pub fn get_replica_groups(&self) -> &[super::xla_data::ReplicaGroup] {
        &self.replica_groups
    }
    pub fn clear_replica_groups(&mut self) {
        self.replica_groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_replica_groups(&mut self, v: ::protobuf::RepeatedField<super::xla_data::ReplicaGroup>) {
        self.replica_groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replica_groups(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::ReplicaGroup> {
        &mut self.replica_groups
    }

    // Take field
    pub fn take_replica_groups(&mut self) -> ::protobuf::RepeatedField<super::xla_data::ReplicaGroup> {
        ::std::mem::replace(&mut self.replica_groups, ::protobuf::RepeatedField::new())
    }

    // int64 all_reduce_id = 45;


    pub fn get_all_reduce_id(&self) -> i64 {
        self.all_reduce_id
    }
    pub fn clear_all_reduce_id(&mut self) {
        self.all_reduce_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_all_reduce_id(&mut self, v: i64) {
        self.all_reduce_id = v;
    }

    // bool is_host_transfer = 47;


    pub fn get_is_host_transfer(&self) -> bool {
        self.is_host_transfer
    }
    pub fn clear_is_host_transfer(&mut self) {
        self.is_host_transfer = false;
    }

    // Param is passed by value, moved
    pub fn set_is_host_transfer(&mut self, v: bool) {
        self.is_host_transfer = v;
    }

    // bool is_stable = 60;


    pub fn get_is_stable(&self) -> bool {
        self.is_stable
    }
    pub fn clear_is_stable(&mut self) {
        self.is_stable = false;
    }

    // Param is passed by value, moved
    pub fn set_is_stable(&mut self, v: bool) {
        self.is_stable = v;
    }

    // .xla.ScatterDimensionNumbers scatter_dimension_numbers = 48;


    pub fn get_scatter_dimension_numbers(&self) -> &super::xla_data::ScatterDimensionNumbers {
        self.scatter_dimension_numbers.as_ref().unwrap_or_else(|| <super::xla_data::ScatterDimensionNumbers as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scatter_dimension_numbers(&mut self) {
        self.scatter_dimension_numbers.clear();
    }

    pub fn has_scatter_dimension_numbers(&self) -> bool {
        self.scatter_dimension_numbers.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scatter_dimension_numbers(&mut self, v: super::xla_data::ScatterDimensionNumbers) {
        self.scatter_dimension_numbers = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scatter_dimension_numbers(&mut self) -> &mut super::xla_data::ScatterDimensionNumbers {
        if self.scatter_dimension_numbers.is_none() {
            self.scatter_dimension_numbers.set_default();
        }
        self.scatter_dimension_numbers.as_mut().unwrap()
    }

    // Take field
    pub fn take_scatter_dimension_numbers(&mut self) -> super::xla_data::ScatterDimensionNumbers {
        self.scatter_dimension_numbers.take().unwrap_or_else(|| super::xla_data::ScatterDimensionNumbers::new())
    }

    // .xla.PrecisionConfig precision_config = 51;


    pub fn get_precision_config(&self) -> &super::xla_data::PrecisionConfig {
        self.precision_config.as_ref().unwrap_or_else(|| <super::xla_data::PrecisionConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_precision_config(&mut self) {
        self.precision_config.clear();
    }

    pub fn has_precision_config(&self) -> bool {
        self.precision_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_precision_config(&mut self, v: super::xla_data::PrecisionConfig) {
        self.precision_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_precision_config(&mut self) -> &mut super::xla_data::PrecisionConfig {
        if self.precision_config.is_none() {
            self.precision_config.set_default();
        }
        self.precision_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_precision_config(&mut self) -> super::xla_data::PrecisionConfig {
        self.precision_config.take().unwrap_or_else(|| super::xla_data::PrecisionConfig::new())
    }

    // repeated .xla.SourceTarget source_target_pairs = 52;


    pub fn get_source_target_pairs(&self) -> &[super::xla_data::SourceTarget] {
        &self.source_target_pairs
    }
    pub fn clear_source_target_pairs(&mut self) {
        self.source_target_pairs.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_target_pairs(&mut self, v: ::protobuf::RepeatedField<super::xla_data::SourceTarget>) {
        self.source_target_pairs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_source_target_pairs(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::SourceTarget> {
        &mut self.source_target_pairs
    }

    // Take field
    pub fn take_source_target_pairs(&mut self) -> ::protobuf::RepeatedField<super::xla_data::SourceTarget> {
        ::std::mem::replace(&mut self.source_target_pairs, ::protobuf::RepeatedField::new())
    }

    // .xla.OpSharding domain_entry_sharding = 54;


    pub fn get_domain_entry_sharding(&self) -> &super::xla_data::OpSharding {
        self.domain_entry_sharding.as_ref().unwrap_or_else(|| <super::xla_data::OpSharding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_domain_entry_sharding(&mut self) {
        self.domain_entry_sharding.clear();
    }

    pub fn has_domain_entry_sharding(&self) -> bool {
        self.domain_entry_sharding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain_entry_sharding(&mut self, v: super::xla_data::OpSharding) {
        self.domain_entry_sharding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain_entry_sharding(&mut self) -> &mut super::xla_data::OpSharding {
        if self.domain_entry_sharding.is_none() {
            self.domain_entry_sharding.set_default();
        }
        self.domain_entry_sharding.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain_entry_sharding(&mut self) -> super::xla_data::OpSharding {
        self.domain_entry_sharding.take().unwrap_or_else(|| super::xla_data::OpSharding::new())
    }

    // .xla.OpSharding domain_exit_sharding = 55;


    pub fn get_domain_exit_sharding(&self) -> &super::xla_data::OpSharding {
        self.domain_exit_sharding.as_ref().unwrap_or_else(|| <super::xla_data::OpSharding as ::protobuf::Message>::default_instance())
    }
    pub fn clear_domain_exit_sharding(&mut self) {
        self.domain_exit_sharding.clear();
    }

    pub fn has_domain_exit_sharding(&self) -> bool {
        self.domain_exit_sharding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_domain_exit_sharding(&mut self, v: super::xla_data::OpSharding) {
        self.domain_exit_sharding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_domain_exit_sharding(&mut self) -> &mut super::xla_data::OpSharding {
        if self.domain_exit_sharding.is_none() {
            self.domain_exit_sharding.set_default();
        }
        self.domain_exit_sharding.as_mut().unwrap()
    }

    // Take field
    pub fn take_domain_exit_sharding(&mut self) -> super::xla_data::OpSharding {
        self.domain_exit_sharding.take().unwrap_or_else(|| super::xla_data::OpSharding::new())
    }

    // bool constrain_layout = 56;


    pub fn get_constrain_layout(&self) -> bool {
        self.constrain_layout
    }
    pub fn clear_constrain_layout(&mut self) {
        self.constrain_layout = false;
    }

    // Param is passed by value, moved
    pub fn set_constrain_layout(&mut self, v: bool) {
        self.constrain_layout = v;
    }

    // repeated .xla.ShapeProto operand_shapes_with_layout = 57;


    pub fn get_operand_shapes_with_layout(&self) -> &[super::xla_data::ShapeProto] {
        &self.operand_shapes_with_layout
    }
    pub fn clear_operand_shapes_with_layout(&mut self) {
        self.operand_shapes_with_layout.clear();
    }

    // Param is passed by value, moved
    pub fn set_operand_shapes_with_layout(&mut self, v: ::protobuf::RepeatedField<super::xla_data::ShapeProto>) {
        self.operand_shapes_with_layout = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operand_shapes_with_layout(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::ShapeProto> {
        &mut self.operand_shapes_with_layout
    }

    // Take field
    pub fn take_operand_shapes_with_layout(&mut self) -> ::protobuf::RepeatedField<super::xla_data::ShapeProto> {
        ::std::mem::replace(&mut self.operand_shapes_with_layout, ::protobuf::RepeatedField::new())
    }

    // .xla.TriangularSolveOptions triangular_solve_options = 59;


    pub fn get_triangular_solve_options(&self) -> &super::xla_data::TriangularSolveOptions {
        self.triangular_solve_options.as_ref().unwrap_or_else(|| <super::xla_data::TriangularSolveOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_triangular_solve_options(&mut self) {
        self.triangular_solve_options.clear();
    }

    pub fn has_triangular_solve_options(&self) -> bool {
        self.triangular_solve_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_triangular_solve_options(&mut self, v: super::xla_data::TriangularSolveOptions) {
        self.triangular_solve_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_triangular_solve_options(&mut self) -> &mut super::xla_data::TriangularSolveOptions {
        if self.triangular_solve_options.is_none() {
            self.triangular_solve_options.set_default();
        }
        self.triangular_solve_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_triangular_solve_options(&mut self) -> super::xla_data::TriangularSolveOptions {
        self.triangular_solve_options.take().unwrap_or_else(|| super::xla_data::TriangularSolveOptions::new())
    }

    // .xla.CholeskyOptions cholesky_options = 62;


    pub fn get_cholesky_options(&self) -> &super::xla_data::CholeskyOptions {
        self.cholesky_options.as_ref().unwrap_or_else(|| <super::xla_data::CholeskyOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cholesky_options(&mut self) {
        self.cholesky_options.clear();
    }

    pub fn has_cholesky_options(&self) -> bool {
        self.cholesky_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cholesky_options(&mut self, v: super::xla_data::CholeskyOptions) {
        self.cholesky_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cholesky_options(&mut self) -> &mut super::xla_data::CholeskyOptions {
        if self.cholesky_options.is_none() {
            self.cholesky_options.set_default();
        }
        self.cholesky_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_cholesky_options(&mut self) -> super::xla_data::CholeskyOptions {
        self.cholesky_options.take().unwrap_or_else(|| super::xla_data::CholeskyOptions::new())
    }

    // .xla.ParameterReplication parameter_replication = 61;


    pub fn get_parameter_replication(&self) -> &super::xla_data::ParameterReplication {
        self.parameter_replication.as_ref().unwrap_or_else(|| <super::xla_data::ParameterReplication as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parameter_replication(&mut self) {
        self.parameter_replication.clear();
    }

    pub fn has_parameter_replication(&self) -> bool {
        self.parameter_replication.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parameter_replication(&mut self, v: super::xla_data::ParameterReplication) {
        self.parameter_replication = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parameter_replication(&mut self) -> &mut super::xla_data::ParameterReplication {
        if self.parameter_replication.is_none() {
            self.parameter_replication.set_default();
        }
        self.parameter_replication.as_mut().unwrap()
    }

    // Take field
    pub fn take_parameter_replication(&mut self) -> super::xla_data::ParameterReplication {
        self.parameter_replication.take().unwrap_or_else(|| super::xla_data::ParameterReplication::new())
    }

    // repeated int64 outer_dimension_partitions = 64;


    pub fn get_outer_dimension_partitions(&self) -> &[i64] {
        &self.outer_dimension_partitions
    }
    pub fn clear_outer_dimension_partitions(&mut self) {
        self.outer_dimension_partitions.clear();
    }

    // Param is passed by value, moved
    pub fn set_outer_dimension_partitions(&mut self, v: ::std::vec::Vec<i64>) {
        self.outer_dimension_partitions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outer_dimension_partitions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.outer_dimension_partitions
    }

    // Take field
    pub fn take_outer_dimension_partitions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.outer_dimension_partitions, ::std::vec::Vec::new())
    }

    // bool custom_call_has_side_effect = 65;


    pub fn get_custom_call_has_side_effect(&self) -> bool {
        self.custom_call_has_side_effect
    }
    pub fn clear_custom_call_has_side_effect(&mut self) {
        self.custom_call_has_side_effect = false;
    }

    // Param is passed by value, moved
    pub fn set_custom_call_has_side_effect(&mut self, v: bool) {
        self.custom_call_has_side_effect = v;
    }

    // int64 delta = 66;


    pub fn get_delta(&self) -> i64 {
        self.delta
    }
    pub fn clear_delta(&mut self) {
        self.delta = 0;
    }

    // Param is passed by value, moved
    pub fn set_delta(&mut self, v: i64) {
        self.delta = v;
    }

    // bool indices_are_sorted = 67;


    pub fn get_indices_are_sorted(&self) -> bool {
        self.indices_are_sorted
    }
    pub fn clear_indices_are_sorted(&mut self) {
        self.indices_are_sorted = false;
    }

    // Param is passed by value, moved
    pub fn set_indices_are_sorted(&mut self, v: bool) {
        self.indices_are_sorted = v;
    }
}

impl ::protobuf::Message for HloInstructionProto {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.literal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.window {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.convolution_dimension_numbers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.slice_dimensions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.padding_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outfeed_shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dot_dimension_numbers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gather_dimension_numbers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sharding {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.replica_groups {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scatter_dimension_numbers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.precision_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source_target_pairs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.domain_entry_sharding {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.domain_exit_sharding {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.operand_shapes_with_layout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.triangular_solve_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cholesky_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parameter_replication {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.opcode)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.literal)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.parameter_number = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fusion_kind)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tuple_index = tmp;
                },
                14 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dimensions)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.window)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.convolution_dimension_numbers)?;
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.feature_group_count = tmp;
                },
                58 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.batch_group_count = tmp;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.slice_dimensions)?;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.exponent_bits = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mantissa_bits = tmp;
                },
                20 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dynamic_slice_sizes)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.padding_config)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.outfeed_config)?;
                },
                23 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.distribution, 23, &mut self.unknown_fields)?
                },
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.epsilon = tmp;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.feature_index = tmp;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.channel_id = tmp;
                },
                27 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.infeed_config)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.custom_call_target)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.outfeed_shape)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dot_dimension_numbers)?;
                },
                31 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.fft_type, 31, &mut self.unknown_fields)?
                },
                32 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.fft_length)?;
                },
                63 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comparison_direction)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gather_dimension_numbers)?;
                },
                34 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.gather_slice_sizes)?;
                },
                41 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.channel_name)?;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cost_estimate_ns = tmp;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                36 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.operand_ids)?;
                },
                37 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.control_predecessor_ids)?;
                },
                38 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.called_computation_ids)?;
                },
                40 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sharding)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.backend_config)?;
                },
                49 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.replica_groups)?;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.all_reduce_id = tmp;
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_host_transfer = tmp;
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_stable = tmp;
                },
                48 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scatter_dimension_numbers)?;
                },
                51 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.precision_config)?;
                },
                52 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.source_target_pairs)?;
                },
                54 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.domain_entry_sharding)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.domain_exit_sharding)?;
                },
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.constrain_layout = tmp;
                },
                57 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operand_shapes_with_layout)?;
                },
                59 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.triangular_solve_options)?;
                },
                62 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cholesky_options)?;
                },
                61 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parameter_replication)?;
                },
                64 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.outer_dimension_partitions)?;
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.custom_call_has_side_effect = tmp;
                },
                66 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.delta = tmp;
                },
                67 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.indices_are_sorted = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.opcode.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.opcode);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.literal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.parameter_number != 0 {
            my_size += ::protobuf::rt::value_size(9, self.parameter_number, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.fusion_kind.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.fusion_kind);
        }
        if self.tuple_index != 0 {
            my_size += ::protobuf::rt::value_size(13, self.tuple_index, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dimensions {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.window.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.convolution_dimension_numbers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.feature_group_count != 0 {
            my_size += ::protobuf::rt::value_size(50, self.feature_group_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.batch_group_count != 0 {
            my_size += ::protobuf::rt::value_size(58, self.batch_group_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.slice_dimensions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.exponent_bits != 0 {
            my_size += ::protobuf::rt::value_size(18, self.exponent_bits, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mantissa_bits != 0 {
            my_size += ::protobuf::rt::value_size(19, self.mantissa_bits, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dynamic_slice_sizes {
            my_size += ::protobuf::rt::value_size(20, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.padding_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.outfeed_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(22, &self.outfeed_config);
        }
        if self.distribution != super::xla_data::RandomDistribution::RNG_INVALID {
            my_size += ::protobuf::rt::enum_size(23, self.distribution);
        }
        if self.epsilon != 0. {
            my_size += 6;
        }
        if self.feature_index != 0 {
            my_size += ::protobuf::rt::value_size(25, self.feature_index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.channel_id != 0 {
            my_size += ::protobuf::rt::value_size(26, self.channel_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.infeed_config.is_empty() {
            my_size += ::protobuf::rt::bytes_size(27, &self.infeed_config);
        }
        if !self.custom_call_target.is_empty() {
            my_size += ::protobuf::rt::string_size(28, &self.custom_call_target);
        }
        if let Some(ref v) = self.outfeed_shape.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dot_dimension_numbers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.fft_type != super::xla_data::FftType::FFT {
            my_size += ::protobuf::rt::enum_size(31, self.fft_type);
        }
        for value in &self.fft_length {
            my_size += ::protobuf::rt::value_size(32, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.comparison_direction.is_empty() {
            my_size += ::protobuf::rt::string_size(63, &self.comparison_direction);
        }
        if let Some(ref v) = self.gather_dimension_numbers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.gather_slice_sizes {
            my_size += ::protobuf::rt::value_size(34, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.channel_name.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.channel_name);
        }
        if self.cost_estimate_ns != 0 {
            my_size += ::protobuf::rt::value_size(42, self.cost_estimate_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(35, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.operand_ids {
            my_size += ::protobuf::rt::value_size(36, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.control_predecessor_ids {
            my_size += ::protobuf::rt::value_size(37, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.called_computation_ids {
            my_size += ::protobuf::rt::value_size(38, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.sharding.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.backend_config.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.backend_config);
        }
        for value in &self.replica_groups {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.all_reduce_id != 0 {
            my_size += ::protobuf::rt::value_size(45, self.all_reduce_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_host_transfer != false {
            my_size += 3;
        }
        if self.is_stable != false {
            my_size += 3;
        }
        if let Some(ref v) = self.scatter_dimension_numbers.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.precision_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.source_target_pairs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.domain_entry_sharding.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.domain_exit_sharding.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.constrain_layout != false {
            my_size += 3;
        }
        for value in &self.operand_shapes_with_layout {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.triangular_solve_options.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cholesky_options.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parameter_replication.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.outer_dimension_partitions {
            my_size += ::protobuf::rt::value_size(64, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.custom_call_has_side_effect != false {
            my_size += 3;
        }
        if self.delta != 0 {
            my_size += ::protobuf::rt::value_size(66, self.delta, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.indices_are_sorted != false {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.opcode.is_empty() {
            os.write_string(2, &self.opcode)?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.literal.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.parameter_number != 0 {
            os.write_int64(9, self.parameter_number)?;
        }
        if !self.fusion_kind.is_empty() {
            os.write_string(11, &self.fusion_kind)?;
        }
        if self.tuple_index != 0 {
            os.write_int64(13, self.tuple_index)?;
        }
        for v in &self.dimensions {
            os.write_int64(14, *v)?;
        };
        if let Some(ref v) = self.window.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.convolution_dimension_numbers.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.feature_group_count != 0 {
            os.write_int64(50, self.feature_group_count)?;
        }
        if self.batch_group_count != 0 {
            os.write_int64(58, self.batch_group_count)?;
        }
        for v in &self.slice_dimensions {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.exponent_bits != 0 {
            os.write_int32(18, self.exponent_bits)?;
        }
        if self.mantissa_bits != 0 {
            os.write_int32(19, self.mantissa_bits)?;
        }
        for v in &self.dynamic_slice_sizes {
            os.write_int64(20, *v)?;
        };
        if let Some(ref v) = self.padding_config.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.outfeed_config.is_empty() {
            os.write_bytes(22, &self.outfeed_config)?;
        }
        if self.distribution != super::xla_data::RandomDistribution::RNG_INVALID {
            os.write_enum(23, ::protobuf::ProtobufEnum::value(&self.distribution))?;
        }
        if self.epsilon != 0. {
            os.write_float(24, self.epsilon)?;
        }
        if self.feature_index != 0 {
            os.write_int64(25, self.feature_index)?;
        }
        if self.channel_id != 0 {
            os.write_int64(26, self.channel_id)?;
        }
        if !self.infeed_config.is_empty() {
            os.write_bytes(27, &self.infeed_config)?;
        }
        if !self.custom_call_target.is_empty() {
            os.write_string(28, &self.custom_call_target)?;
        }
        if let Some(ref v) = self.outfeed_shape.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dot_dimension_numbers.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.fft_type != super::xla_data::FftType::FFT {
            os.write_enum(31, ::protobuf::ProtobufEnum::value(&self.fft_type))?;
        }
        for v in &self.fft_length {
            os.write_int64(32, *v)?;
        };
        if !self.comparison_direction.is_empty() {
            os.write_string(63, &self.comparison_direction)?;
        }
        if let Some(ref v) = self.gather_dimension_numbers.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.gather_slice_sizes {
            os.write_int64(34, *v)?;
        };
        if !self.channel_name.is_empty() {
            os.write_string(41, &self.channel_name)?;
        }
        if self.cost_estimate_ns != 0 {
            os.write_int64(42, self.cost_estimate_ns)?;
        }
        if self.id != 0 {
            os.write_int64(35, self.id)?;
        }
        for v in &self.operand_ids {
            os.write_int64(36, *v)?;
        };
        for v in &self.control_predecessor_ids {
            os.write_int64(37, *v)?;
        };
        for v in &self.called_computation_ids {
            os.write_int64(38, *v)?;
        };
        if let Some(ref v) = self.sharding.as_ref() {
            os.write_tag(40, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.backend_config.is_empty() {
            os.write_string(43, &self.backend_config)?;
        }
        for v in &self.replica_groups {
            os.write_tag(49, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.all_reduce_id != 0 {
            os.write_int64(45, self.all_reduce_id)?;
        }
        if self.is_host_transfer != false {
            os.write_bool(47, self.is_host_transfer)?;
        }
        if self.is_stable != false {
            os.write_bool(60, self.is_stable)?;
        }
        if let Some(ref v) = self.scatter_dimension_numbers.as_ref() {
            os.write_tag(48, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.precision_config.as_ref() {
            os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.source_target_pairs {
            os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.domain_entry_sharding.as_ref() {
            os.write_tag(54, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.domain_exit_sharding.as_ref() {
            os.write_tag(55, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.constrain_layout != false {
            os.write_bool(56, self.constrain_layout)?;
        }
        for v in &self.operand_shapes_with_layout {
            os.write_tag(57, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.triangular_solve_options.as_ref() {
            os.write_tag(59, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cholesky_options.as_ref() {
            os.write_tag(62, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parameter_replication.as_ref() {
            os.write_tag(61, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.outer_dimension_partitions {
            os.write_int64(64, *v)?;
        };
        if self.custom_call_has_side_effect != false {
            os.write_bool(65, self.custom_call_has_side_effect)?;
        }
        if self.delta != 0 {
            os.write_int64(66, self.delta)?;
        }
        if self.indices_are_sorted != false {
            os.write_bool(67, self.indices_are_sorted)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloInstructionProto {
        HloInstructionProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HloInstructionProto| { &m.name },
                |m: &mut HloInstructionProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "opcode",
                |m: &HloInstructionProto| { &m.opcode },
                |m: &mut HloInstructionProto| { &mut m.opcode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "shape",
                |m: &HloInstructionProto| { &m.shape },
                |m: &mut HloInstructionProto| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::OpMetadata>>(
                "metadata",
                |m: &HloInstructionProto| { &m.metadata },
                |m: &mut HloInstructionProto| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "literal",
                |m: &HloInstructionProto| { &m.literal },
                |m: &mut HloInstructionProto| { &mut m.literal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "parameter_number",
                |m: &HloInstructionProto| { &m.parameter_number },
                |m: &mut HloInstructionProto| { &mut m.parameter_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fusion_kind",
                |m: &HloInstructionProto| { &m.fusion_kind },
                |m: &mut HloInstructionProto| { &mut m.fusion_kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tuple_index",
                |m: &HloInstructionProto| { &m.tuple_index },
                |m: &mut HloInstructionProto| { &mut m.tuple_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dimensions",
                |m: &HloInstructionProto| { &m.dimensions },
                |m: &mut HloInstructionProto| { &mut m.dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::Window>>(
                "window",
                |m: &HloInstructionProto| { &m.window },
                |m: &mut HloInstructionProto| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ConvolutionDimensionNumbers>>(
                "convolution_dimension_numbers",
                |m: &HloInstructionProto| { &m.convolution_dimension_numbers },
                |m: &mut HloInstructionProto| { &mut m.convolution_dimension_numbers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "feature_group_count",
                |m: &HloInstructionProto| { &m.feature_group_count },
                |m: &mut HloInstructionProto| { &mut m.feature_group_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "batch_group_count",
                |m: &HloInstructionProto| { &m.batch_group_count },
                |m: &mut HloInstructionProto| { &mut m.batch_group_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloInstructionProto_SliceDimensions>>(
                "slice_dimensions",
                |m: &HloInstructionProto| { &m.slice_dimensions },
                |m: &mut HloInstructionProto| { &mut m.slice_dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "exponent_bits",
                |m: &HloInstructionProto| { &m.exponent_bits },
                |m: &mut HloInstructionProto| { &mut m.exponent_bits },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mantissa_bits",
                |m: &HloInstructionProto| { &m.mantissa_bits },
                |m: &mut HloInstructionProto| { &mut m.mantissa_bits },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dynamic_slice_sizes",
                |m: &HloInstructionProto| { &m.dynamic_slice_sizes },
                |m: &mut HloInstructionProto| { &mut m.dynamic_slice_sizes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::PaddingConfig>>(
                "padding_config",
                |m: &HloInstructionProto| { &m.padding_config },
                |m: &mut HloInstructionProto| { &mut m.padding_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "outfeed_config",
                |m: &HloInstructionProto| { &m.outfeed_config },
                |m: &mut HloInstructionProto| { &mut m.outfeed_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::xla_data::RandomDistribution>>(
                "distribution",
                |m: &HloInstructionProto| { &m.distribution },
                |m: &mut HloInstructionProto| { &mut m.distribution },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "epsilon",
                |m: &HloInstructionProto| { &m.epsilon },
                |m: &mut HloInstructionProto| { &mut m.epsilon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "feature_index",
                |m: &HloInstructionProto| { &m.feature_index },
                |m: &mut HloInstructionProto| { &mut m.feature_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "channel_id",
                |m: &HloInstructionProto| { &m.channel_id },
                |m: &mut HloInstructionProto| { &mut m.channel_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "infeed_config",
                |m: &HloInstructionProto| { &m.infeed_config },
                |m: &mut HloInstructionProto| { &mut m.infeed_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "custom_call_target",
                |m: &HloInstructionProto| { &m.custom_call_target },
                |m: &mut HloInstructionProto| { &mut m.custom_call_target },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "outfeed_shape",
                |m: &HloInstructionProto| { &m.outfeed_shape },
                |m: &mut HloInstructionProto| { &mut m.outfeed_shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DotDimensionNumbers>>(
                "dot_dimension_numbers",
                |m: &HloInstructionProto| { &m.dot_dimension_numbers },
                |m: &mut HloInstructionProto| { &mut m.dot_dimension_numbers },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::xla_data::FftType>>(
                "fft_type",
                |m: &HloInstructionProto| { &m.fft_type },
                |m: &mut HloInstructionProto| { &mut m.fft_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fft_length",
                |m: &HloInstructionProto| { &m.fft_length },
                |m: &mut HloInstructionProto| { &mut m.fft_length },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "comparison_direction",
                |m: &HloInstructionProto| { &m.comparison_direction },
                |m: &mut HloInstructionProto| { &mut m.comparison_direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GatherDimensionNumbers>>(
                "gather_dimension_numbers",
                |m: &HloInstructionProto| { &m.gather_dimension_numbers },
                |m: &mut HloInstructionProto| { &mut m.gather_dimension_numbers },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "gather_slice_sizes",
                |m: &HloInstructionProto| { &m.gather_slice_sizes },
                |m: &mut HloInstructionProto| { &mut m.gather_slice_sizes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "channel_name",
                |m: &HloInstructionProto| { &m.channel_name },
                |m: &mut HloInstructionProto| { &mut m.channel_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cost_estimate_ns",
                |m: &HloInstructionProto| { &m.cost_estimate_ns },
                |m: &mut HloInstructionProto| { &mut m.cost_estimate_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &HloInstructionProto| { &m.id },
                |m: &mut HloInstructionProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "operand_ids",
                |m: &HloInstructionProto| { &m.operand_ids },
                |m: &mut HloInstructionProto| { &mut m.operand_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "control_predecessor_ids",
                |m: &HloInstructionProto| { &m.control_predecessor_ids },
                |m: &mut HloInstructionProto| { &mut m.control_predecessor_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "called_computation_ids",
                |m: &HloInstructionProto| { &m.called_computation_ids },
                |m: &mut HloInstructionProto| { &mut m.called_computation_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::OpSharding>>(
                "sharding",
                |m: &HloInstructionProto| { &m.sharding },
                |m: &mut HloInstructionProto| { &mut m.sharding },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "backend_config",
                |m: &HloInstructionProto| { &m.backend_config },
                |m: &mut HloInstructionProto| { &mut m.backend_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ReplicaGroup>>(
                "replica_groups",
                |m: &HloInstructionProto| { &m.replica_groups },
                |m: &mut HloInstructionProto| { &mut m.replica_groups },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "all_reduce_id",
                |m: &HloInstructionProto| { &m.all_reduce_id },
                |m: &mut HloInstructionProto| { &mut m.all_reduce_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_host_transfer",
                |m: &HloInstructionProto| { &m.is_host_transfer },
                |m: &mut HloInstructionProto| { &mut m.is_host_transfer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_stable",
                |m: &HloInstructionProto| { &m.is_stable },
                |m: &mut HloInstructionProto| { &mut m.is_stable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ScatterDimensionNumbers>>(
                "scatter_dimension_numbers",
                |m: &HloInstructionProto| { &m.scatter_dimension_numbers },
                |m: &mut HloInstructionProto| { &mut m.scatter_dimension_numbers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::PrecisionConfig>>(
                "precision_config",
                |m: &HloInstructionProto| { &m.precision_config },
                |m: &mut HloInstructionProto| { &mut m.precision_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::SourceTarget>>(
                "source_target_pairs",
                |m: &HloInstructionProto| { &m.source_target_pairs },
                |m: &mut HloInstructionProto| { &mut m.source_target_pairs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::OpSharding>>(
                "domain_entry_sharding",
                |m: &HloInstructionProto| { &m.domain_entry_sharding },
                |m: &mut HloInstructionProto| { &mut m.domain_entry_sharding },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::OpSharding>>(
                "domain_exit_sharding",
                |m: &HloInstructionProto| { &m.domain_exit_sharding },
                |m: &mut HloInstructionProto| { &mut m.domain_exit_sharding },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "constrain_layout",
                |m: &HloInstructionProto| { &m.constrain_layout },
                |m: &mut HloInstructionProto| { &mut m.constrain_layout },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "operand_shapes_with_layout",
                |m: &HloInstructionProto| { &m.operand_shapes_with_layout },
                |m: &mut HloInstructionProto| { &mut m.operand_shapes_with_layout },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::TriangularSolveOptions>>(
                "triangular_solve_options",
                |m: &HloInstructionProto| { &m.triangular_solve_options },
                |m: &mut HloInstructionProto| { &mut m.triangular_solve_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::CholeskyOptions>>(
                "cholesky_options",
                |m: &HloInstructionProto| { &m.cholesky_options },
                |m: &mut HloInstructionProto| { &mut m.cholesky_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ParameterReplication>>(
                "parameter_replication",
                |m: &HloInstructionProto| { &m.parameter_replication },
                |m: &mut HloInstructionProto| { &mut m.parameter_replication },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "outer_dimension_partitions",
                |m: &HloInstructionProto| { &m.outer_dimension_partitions },
                |m: &mut HloInstructionProto| { &mut m.outer_dimension_partitions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "custom_call_has_side_effect",
                |m: &HloInstructionProto| { &m.custom_call_has_side_effect },
                |m: &mut HloInstructionProto| { &mut m.custom_call_has_side_effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "delta",
                |m: &HloInstructionProto| { &m.delta },
                |m: &mut HloInstructionProto| { &mut m.delta },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "indices_are_sorted",
                |m: &HloInstructionProto| { &m.indices_are_sorted },
                |m: &mut HloInstructionProto| { &mut m.indices_are_sorted },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloInstructionProto>(
                "HloInstructionProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloInstructionProto {
        static instance: ::protobuf::rt::LazyV2<HloInstructionProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloInstructionProto::new)
    }
}

impl ::protobuf::Clear for HloInstructionProto {
    fn clear(&mut self) {
        self.name.clear();
        self.opcode.clear();
        self.shape.clear();
        self.metadata.clear();
        self.literal.clear();
        self.parameter_number = 0;
        self.fusion_kind.clear();
        self.tuple_index = 0;
        self.dimensions.clear();
        self.window.clear();
        self.convolution_dimension_numbers.clear();
        self.feature_group_count = 0;
        self.batch_group_count = 0;
        self.slice_dimensions.clear();
        self.exponent_bits = 0;
        self.mantissa_bits = 0;
        self.dynamic_slice_sizes.clear();
        self.padding_config.clear();
        self.outfeed_config.clear();
        self.distribution = super::xla_data::RandomDistribution::RNG_INVALID;
        self.epsilon = 0.;
        self.feature_index = 0;
        self.channel_id = 0;
        self.infeed_config.clear();
        self.custom_call_target.clear();
        self.outfeed_shape.clear();
        self.dot_dimension_numbers.clear();
        self.fft_type = super::xla_data::FftType::FFT;
        self.fft_length.clear();
        self.comparison_direction.clear();
        self.gather_dimension_numbers.clear();
        self.gather_slice_sizes.clear();
        self.channel_name.clear();
        self.cost_estimate_ns = 0;
        self.id = 0;
        self.operand_ids.clear();
        self.control_predecessor_ids.clear();
        self.called_computation_ids.clear();
        self.sharding.clear();
        self.backend_config.clear();
        self.replica_groups.clear();
        self.all_reduce_id = 0;
        self.is_host_transfer = false;
        self.is_stable = false;
        self.scatter_dimension_numbers.clear();
        self.precision_config.clear();
        self.source_target_pairs.clear();
        self.domain_entry_sharding.clear();
        self.domain_exit_sharding.clear();
        self.constrain_layout = false;
        self.operand_shapes_with_layout.clear();
        self.triangular_solve_options.clear();
        self.cholesky_options.clear();
        self.parameter_replication.clear();
        self.outer_dimension_partitions.clear();
        self.custom_call_has_side_effect = false;
        self.delta = 0;
        self.indices_are_sorted = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloInstructionProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloInstructionProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloInstructionProto_SliceDimensions {
    // message fields
    pub start: i64,
    pub limit: i64,
    pub stride: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloInstructionProto_SliceDimensions {
    fn default() -> &'a HloInstructionProto_SliceDimensions {
        <HloInstructionProto_SliceDimensions as ::protobuf::Message>::default_instance()
    }
}

impl HloInstructionProto_SliceDimensions {
    pub fn new() -> HloInstructionProto_SliceDimensions {
        ::std::default::Default::default()
    }

    // int64 start = 1;


    pub fn get_start(&self) -> i64 {
        self.start
    }
    pub fn clear_start(&mut self) {
        self.start = 0;
    }

    // Param is passed by value, moved
    pub fn set_start(&mut self, v: i64) {
        self.start = v;
    }

    // int64 limit = 2;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // int64 stride = 3;


    pub fn get_stride(&self) -> i64 {
        self.stride
    }
    pub fn clear_stride(&mut self) {
        self.stride = 0;
    }

    // Param is passed by value, moved
    pub fn set_stride(&mut self, v: i64) {
        self.stride = v;
    }
}

impl ::protobuf::Message for HloInstructionProto_SliceDimensions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.start = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.stride = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.start != 0 {
            my_size += ::protobuf::rt::value_size(1, self.start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stride != 0 {
            my_size += ::protobuf::rt::value_size(3, self.stride, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.start != 0 {
            os.write_int64(1, self.start)?;
        }
        if self.limit != 0 {
            os.write_int64(2, self.limit)?;
        }
        if self.stride != 0 {
            os.write_int64(3, self.stride)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloInstructionProto_SliceDimensions {
        HloInstructionProto_SliceDimensions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start",
                |m: &HloInstructionProto_SliceDimensions| { &m.start },
                |m: &mut HloInstructionProto_SliceDimensions| { &mut m.start },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &HloInstructionProto_SliceDimensions| { &m.limit },
                |m: &mut HloInstructionProto_SliceDimensions| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "stride",
                |m: &HloInstructionProto_SliceDimensions| { &m.stride },
                |m: &mut HloInstructionProto_SliceDimensions| { &mut m.stride },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloInstructionProto_SliceDimensions>(
                "HloInstructionProto.SliceDimensions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloInstructionProto_SliceDimensions {
        static instance: ::protobuf::rt::LazyV2<HloInstructionProto_SliceDimensions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloInstructionProto_SliceDimensions::new)
    }
}

impl ::protobuf::Clear for HloInstructionProto_SliceDimensions {
    fn clear(&mut self) {
        self.start = 0;
        self.limit = 0;
        self.stride = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloInstructionProto_SliceDimensions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloInstructionProto_SliceDimensions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloComputationProto {
    // message fields
    pub name: ::std::string::String,
    pub instructions: ::protobuf::RepeatedField<HloInstructionProto>,
    pub program_shape: ::protobuf::SingularPtrField<super::xla_data::ProgramShapeProto>,
    pub id: i64,
    pub root_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloComputationProto {
    fn default() -> &'a HloComputationProto {
        <HloComputationProto as ::protobuf::Message>::default_instance()
    }
}

impl HloComputationProto {
    pub fn new() -> HloComputationProto {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .xla.HloInstructionProto instructions = 2;


    pub fn get_instructions(&self) -> &[HloInstructionProto] {
        &self.instructions
    }
    pub fn clear_instructions(&mut self) {
        self.instructions.clear();
    }

    // Param is passed by value, moved
    pub fn set_instructions(&mut self, v: ::protobuf::RepeatedField<HloInstructionProto>) {
        self.instructions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instructions(&mut self) -> &mut ::protobuf::RepeatedField<HloInstructionProto> {
        &mut self.instructions
    }

    // Take field
    pub fn take_instructions(&mut self) -> ::protobuf::RepeatedField<HloInstructionProto> {
        ::std::mem::replace(&mut self.instructions, ::protobuf::RepeatedField::new())
    }

    // .xla.ProgramShapeProto program_shape = 4;


    pub fn get_program_shape(&self) -> &super::xla_data::ProgramShapeProto {
        self.program_shape.as_ref().unwrap_or_else(|| <super::xla_data::ProgramShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_program_shape(&mut self) {
        self.program_shape.clear();
    }

    pub fn has_program_shape(&self) -> bool {
        self.program_shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_program_shape(&mut self, v: super::xla_data::ProgramShapeProto) {
        self.program_shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_program_shape(&mut self) -> &mut super::xla_data::ProgramShapeProto {
        if self.program_shape.is_none() {
            self.program_shape.set_default();
        }
        self.program_shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_program_shape(&mut self) -> super::xla_data::ProgramShapeProto {
        self.program_shape.take().unwrap_or_else(|| super::xla_data::ProgramShapeProto::new())
    }

    // int64 id = 5;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // int64 root_id = 6;


    pub fn get_root_id(&self) -> i64 {
        self.root_id
    }
    pub fn clear_root_id(&mut self) {
        self.root_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_root_id(&mut self, v: i64) {
        self.root_id = v;
    }
}

impl ::protobuf::Message for HloComputationProto {
    fn is_initialized(&self) -> bool {
        for v in &self.instructions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.program_shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.instructions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.program_shape)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.root_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.instructions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.program_shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.root_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.root_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.instructions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.program_shape.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.id != 0 {
            os.write_int64(5, self.id)?;
        }
        if self.root_id != 0 {
            os.write_int64(6, self.root_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloComputationProto {
        HloComputationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HloComputationProto| { &m.name },
                |m: &mut HloComputationProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloInstructionProto>>(
                "instructions",
                |m: &HloComputationProto| { &m.instructions },
                |m: &mut HloComputationProto| { &mut m.instructions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ProgramShapeProto>>(
                "program_shape",
                |m: &HloComputationProto| { &m.program_shape },
                |m: &mut HloComputationProto| { &mut m.program_shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &HloComputationProto| { &m.id },
                |m: &mut HloComputationProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "root_id",
                |m: &HloComputationProto| { &m.root_id },
                |m: &mut HloComputationProto| { &mut m.root_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloComputationProto>(
                "HloComputationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloComputationProto {
        static instance: ::protobuf::rt::LazyV2<HloComputationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloComputationProto::new)
    }
}

impl ::protobuf::Clear for HloComputationProto {
    fn clear(&mut self) {
        self.name.clear();
        self.instructions.clear();
        self.program_shape.clear();
        self.id = 0;
        self.root_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloComputationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloComputationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloScheduleProto {
    // message fields
    pub sequences: ::std::collections::HashMap<i64, HloScheduleProto_InstructionSequence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloScheduleProto {
    fn default() -> &'a HloScheduleProto {
        <HloScheduleProto as ::protobuf::Message>::default_instance()
    }
}

impl HloScheduleProto {
    pub fn new() -> HloScheduleProto {
        ::std::default::Default::default()
    }

    // repeated .xla.HloScheduleProto.SequencesEntry sequences = 1;


    pub fn get_sequences(&self) -> &::std::collections::HashMap<i64, HloScheduleProto_InstructionSequence> {
        &self.sequences
    }
    pub fn clear_sequences(&mut self) {
        self.sequences.clear();
    }

    // Param is passed by value, moved
    pub fn set_sequences(&mut self, v: ::std::collections::HashMap<i64, HloScheduleProto_InstructionSequence>) {
        self.sequences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sequences(&mut self) -> &mut ::std::collections::HashMap<i64, HloScheduleProto_InstructionSequence> {
        &mut self.sequences
    }

    // Take field
    pub fn take_sequences(&mut self) -> ::std::collections::HashMap<i64, HloScheduleProto_InstructionSequence> {
        ::std::mem::replace(&mut self.sequences, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for HloScheduleProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<HloScheduleProto_InstructionSequence>>(wire_type, is, &mut self.sequences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<HloScheduleProto_InstructionSequence>>(1, &self.sequences);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<HloScheduleProto_InstructionSequence>>(1, &self.sequences, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloScheduleProto {
        HloScheduleProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<HloScheduleProto_InstructionSequence>>(
                "sequences",
                |m: &HloScheduleProto| { &m.sequences },
                |m: &mut HloScheduleProto| { &mut m.sequences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloScheduleProto>(
                "HloScheduleProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloScheduleProto {
        static instance: ::protobuf::rt::LazyV2<HloScheduleProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloScheduleProto::new)
    }
}

impl ::protobuf::Clear for HloScheduleProto {
    fn clear(&mut self) {
        self.sequences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloScheduleProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloScheduleProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloScheduleProto_InstructionSequence {
    // message fields
    pub instruction_ids: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloScheduleProto_InstructionSequence {
    fn default() -> &'a HloScheduleProto_InstructionSequence {
        <HloScheduleProto_InstructionSequence as ::protobuf::Message>::default_instance()
    }
}

impl HloScheduleProto_InstructionSequence {
    pub fn new() -> HloScheduleProto_InstructionSequence {
        ::std::default::Default::default()
    }

    // repeated int64 instruction_ids = 1;


    pub fn get_instruction_ids(&self) -> &[i64] {
        &self.instruction_ids
    }
    pub fn clear_instruction_ids(&mut self) {
        self.instruction_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_instruction_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.instruction_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instruction_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.instruction_ids
    }

    // Take field
    pub fn take_instruction_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.instruction_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HloScheduleProto_InstructionSequence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.instruction_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.instruction_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.instruction_ids {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloScheduleProto_InstructionSequence {
        HloScheduleProto_InstructionSequence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "instruction_ids",
                |m: &HloScheduleProto_InstructionSequence| { &m.instruction_ids },
                |m: &mut HloScheduleProto_InstructionSequence| { &mut m.instruction_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloScheduleProto_InstructionSequence>(
                "HloScheduleProto.InstructionSequence",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloScheduleProto_InstructionSequence {
        static instance: ::protobuf::rt::LazyV2<HloScheduleProto_InstructionSequence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloScheduleProto_InstructionSequence::new)
    }
}

impl ::protobuf::Clear for HloScheduleProto_InstructionSequence {
    fn clear(&mut self) {
        self.instruction_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloScheduleProto_InstructionSequence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloScheduleProto_InstructionSequence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloInputOutputAliasProto {
    // message fields
    pub entries: ::protobuf::RepeatedField<HloInputOutputAliasProto_AliasEntryProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloInputOutputAliasProto {
    fn default() -> &'a HloInputOutputAliasProto {
        <HloInputOutputAliasProto as ::protobuf::Message>::default_instance()
    }
}

impl HloInputOutputAliasProto {
    pub fn new() -> HloInputOutputAliasProto {
        ::std::default::Default::default()
    }

    // repeated .xla.HloInputOutputAliasProto.AliasEntryProto entries = 1;


    pub fn get_entries(&self) -> &[HloInputOutputAliasProto_AliasEntryProto] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<HloInputOutputAliasProto_AliasEntryProto>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<HloInputOutputAliasProto_AliasEntryProto> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<HloInputOutputAliasProto_AliasEntryProto> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HloInputOutputAliasProto {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloInputOutputAliasProto {
        HloInputOutputAliasProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloInputOutputAliasProto_AliasEntryProto>>(
                "entries",
                |m: &HloInputOutputAliasProto| { &m.entries },
                |m: &mut HloInputOutputAliasProto| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloInputOutputAliasProto>(
                "HloInputOutputAliasProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloInputOutputAliasProto {
        static instance: ::protobuf::rt::LazyV2<HloInputOutputAliasProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloInputOutputAliasProto::new)
    }
}

impl ::protobuf::Clear for HloInputOutputAliasProto {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloInputOutputAliasProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloInputOutputAliasProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloInputOutputAliasProto_AliasEntryProto {
    // message fields
    pub output_shape_index: ::std::vec::Vec<i64>,
    pub parameter_number: i64,
    pub parameter_shape_index: ::std::vec::Vec<i64>,
    pub kind: HloInputOutputAliasProto_Kind,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloInputOutputAliasProto_AliasEntryProto {
    fn default() -> &'a HloInputOutputAliasProto_AliasEntryProto {
        <HloInputOutputAliasProto_AliasEntryProto as ::protobuf::Message>::default_instance()
    }
}

impl HloInputOutputAliasProto_AliasEntryProto {
    pub fn new() -> HloInputOutputAliasProto_AliasEntryProto {
        ::std::default::Default::default()
    }

    // repeated int64 output_shape_index = 1;


    pub fn get_output_shape_index(&self) -> &[i64] {
        &self.output_shape_index
    }
    pub fn clear_output_shape_index(&mut self) {
        self.output_shape_index.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_shape_index(&mut self, v: ::std::vec::Vec<i64>) {
        self.output_shape_index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_shape_index(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.output_shape_index
    }

    // Take field
    pub fn take_output_shape_index(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.output_shape_index, ::std::vec::Vec::new())
    }

    // int64 parameter_number = 2;


    pub fn get_parameter_number(&self) -> i64 {
        self.parameter_number
    }
    pub fn clear_parameter_number(&mut self) {
        self.parameter_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_parameter_number(&mut self, v: i64) {
        self.parameter_number = v;
    }

    // repeated int64 parameter_shape_index = 3;


    pub fn get_parameter_shape_index(&self) -> &[i64] {
        &self.parameter_shape_index
    }
    pub fn clear_parameter_shape_index(&mut self) {
        self.parameter_shape_index.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter_shape_index(&mut self, v: ::std::vec::Vec<i64>) {
        self.parameter_shape_index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameter_shape_index(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.parameter_shape_index
    }

    // Take field
    pub fn take_parameter_shape_index(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.parameter_shape_index, ::std::vec::Vec::new())
    }

    // .xla.HloInputOutputAliasProto.Kind kind = 4;


    pub fn get_kind(&self) -> HloInputOutputAliasProto_Kind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = HloInputOutputAliasProto_Kind::UNDEFINED_ALIAS;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: HloInputOutputAliasProto_Kind) {
        self.kind = v;
    }
}

impl ::protobuf::Message for HloInputOutputAliasProto_AliasEntryProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.output_shape_index)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.parameter_number = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.parameter_shape_index)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.output_shape_index {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.parameter_number != 0 {
            my_size += ::protobuf::rt::value_size(2, self.parameter_number, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.parameter_shape_index {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.kind != HloInputOutputAliasProto_Kind::UNDEFINED_ALIAS {
            my_size += ::protobuf::rt::enum_size(4, self.kind);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.output_shape_index {
            os.write_int64(1, *v)?;
        };
        if self.parameter_number != 0 {
            os.write_int64(2, self.parameter_number)?;
        }
        for v in &self.parameter_shape_index {
            os.write_int64(3, *v)?;
        };
        if self.kind != HloInputOutputAliasProto_Kind::UNDEFINED_ALIAS {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloInputOutputAliasProto_AliasEntryProto {
        HloInputOutputAliasProto_AliasEntryProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "output_shape_index",
                |m: &HloInputOutputAliasProto_AliasEntryProto| { &m.output_shape_index },
                |m: &mut HloInputOutputAliasProto_AliasEntryProto| { &mut m.output_shape_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "parameter_number",
                |m: &HloInputOutputAliasProto_AliasEntryProto| { &m.parameter_number },
                |m: &mut HloInputOutputAliasProto_AliasEntryProto| { &mut m.parameter_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "parameter_shape_index",
                |m: &HloInputOutputAliasProto_AliasEntryProto| { &m.parameter_shape_index },
                |m: &mut HloInputOutputAliasProto_AliasEntryProto| { &mut m.parameter_shape_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HloInputOutputAliasProto_Kind>>(
                "kind",
                |m: &HloInputOutputAliasProto_AliasEntryProto| { &m.kind },
                |m: &mut HloInputOutputAliasProto_AliasEntryProto| { &mut m.kind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloInputOutputAliasProto_AliasEntryProto>(
                "HloInputOutputAliasProto.AliasEntryProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloInputOutputAliasProto_AliasEntryProto {
        static instance: ::protobuf::rt::LazyV2<HloInputOutputAliasProto_AliasEntryProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloInputOutputAliasProto_AliasEntryProto::new)
    }
}

impl ::protobuf::Clear for HloInputOutputAliasProto_AliasEntryProto {
    fn clear(&mut self) {
        self.output_shape_index.clear();
        self.parameter_number = 0;
        self.parameter_shape_index.clear();
        self.kind = HloInputOutputAliasProto_Kind::UNDEFINED_ALIAS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloInputOutputAliasProto_AliasEntryProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloInputOutputAliasProto_AliasEntryProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HloInputOutputAliasProto_Kind {
    UNDEFINED_ALIAS = 0,
    USER_ALIAS = 1,
    SYSTEM_ALIAS = 2,
}

impl ::protobuf::ProtobufEnum for HloInputOutputAliasProto_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HloInputOutputAliasProto_Kind> {
        match value {
            0 => ::std::option::Option::Some(HloInputOutputAliasProto_Kind::UNDEFINED_ALIAS),
            1 => ::std::option::Option::Some(HloInputOutputAliasProto_Kind::USER_ALIAS),
            2 => ::std::option::Option::Some(HloInputOutputAliasProto_Kind::SYSTEM_ALIAS),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HloInputOutputAliasProto_Kind] = &[
            HloInputOutputAliasProto_Kind::UNDEFINED_ALIAS,
            HloInputOutputAliasProto_Kind::USER_ALIAS,
            HloInputOutputAliasProto_Kind::SYSTEM_ALIAS,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HloInputOutputAliasProto_Kind>("HloInputOutputAliasProto.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HloInputOutputAliasProto_Kind {
}

impl ::std::default::Default for HloInputOutputAliasProto_Kind {
    fn default() -> Self {
        HloInputOutputAliasProto_Kind::UNDEFINED_ALIAS
    }
}

impl ::protobuf::reflect::ProtobufValue for HloInputOutputAliasProto_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DynamicParameterBindingProto {
    // message fields
    pub entries: ::protobuf::RepeatedField<DynamicParameterBindingProto_Binding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DynamicParameterBindingProto {
    fn default() -> &'a DynamicParameterBindingProto {
        <DynamicParameterBindingProto as ::protobuf::Message>::default_instance()
    }
}

impl DynamicParameterBindingProto {
    pub fn new() -> DynamicParameterBindingProto {
        ::std::default::Default::default()
    }

    // repeated .xla.DynamicParameterBindingProto.Binding entries = 1;


    pub fn get_entries(&self) -> &[DynamicParameterBindingProto_Binding] {
        &self.entries
    }
    pub fn clear_entries(&mut self) {
        self.entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_entries(&mut self, v: ::protobuf::RepeatedField<DynamicParameterBindingProto_Binding>) {
        self.entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_entries(&mut self) -> &mut ::protobuf::RepeatedField<DynamicParameterBindingProto_Binding> {
        &mut self.entries
    }

    // Take field
    pub fn take_entries(&mut self) -> ::protobuf::RepeatedField<DynamicParameterBindingProto_Binding> {
        ::std::mem::replace(&mut self.entries, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DynamicParameterBindingProto {
    fn is_initialized(&self) -> bool {
        for v in &self.entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.entries)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DynamicParameterBindingProto {
        DynamicParameterBindingProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DynamicParameterBindingProto_Binding>>(
                "entries",
                |m: &DynamicParameterBindingProto| { &m.entries },
                |m: &mut DynamicParameterBindingProto| { &mut m.entries },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DynamicParameterBindingProto>(
                "DynamicParameterBindingProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DynamicParameterBindingProto {
        static instance: ::protobuf::rt::LazyV2<DynamicParameterBindingProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DynamicParameterBindingProto::new)
    }
}

impl ::protobuf::Clear for DynamicParameterBindingProto {
    fn clear(&mut self) {
        self.entries.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DynamicParameterBindingProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicParameterBindingProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DynamicParameterBindingProto_Binding {
    // message fields
    pub dynamic_param_num: i64,
    pub dynamic_param_index: ::std::vec::Vec<i64>,
    pub target_param_num: i64,
    pub target_param_index: ::std::vec::Vec<i64>,
    pub target_param_dim_num: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DynamicParameterBindingProto_Binding {
    fn default() -> &'a DynamicParameterBindingProto_Binding {
        <DynamicParameterBindingProto_Binding as ::protobuf::Message>::default_instance()
    }
}

impl DynamicParameterBindingProto_Binding {
    pub fn new() -> DynamicParameterBindingProto_Binding {
        ::std::default::Default::default()
    }

    // int64 dynamic_param_num = 1;


    pub fn get_dynamic_param_num(&self) -> i64 {
        self.dynamic_param_num
    }
    pub fn clear_dynamic_param_num(&mut self) {
        self.dynamic_param_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_dynamic_param_num(&mut self, v: i64) {
        self.dynamic_param_num = v;
    }

    // repeated int64 dynamic_param_index = 2;


    pub fn get_dynamic_param_index(&self) -> &[i64] {
        &self.dynamic_param_index
    }
    pub fn clear_dynamic_param_index(&mut self) {
        self.dynamic_param_index.clear();
    }

    // Param is passed by value, moved
    pub fn set_dynamic_param_index(&mut self, v: ::std::vec::Vec<i64>) {
        self.dynamic_param_index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic_param_index(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dynamic_param_index
    }

    // Take field
    pub fn take_dynamic_param_index(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dynamic_param_index, ::std::vec::Vec::new())
    }

    // int64 target_param_num = 3;


    pub fn get_target_param_num(&self) -> i64 {
        self.target_param_num
    }
    pub fn clear_target_param_num(&mut self) {
        self.target_param_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_param_num(&mut self, v: i64) {
        self.target_param_num = v;
    }

    // repeated int64 target_param_index = 4;


    pub fn get_target_param_index(&self) -> &[i64] {
        &self.target_param_index
    }
    pub fn clear_target_param_index(&mut self) {
        self.target_param_index.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_param_index(&mut self, v: ::std::vec::Vec<i64>) {
        self.target_param_index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_target_param_index(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.target_param_index
    }

    // Take field
    pub fn take_target_param_index(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.target_param_index, ::std::vec::Vec::new())
    }

    // int64 target_param_dim_num = 5;


    pub fn get_target_param_dim_num(&self) -> i64 {
        self.target_param_dim_num
    }
    pub fn clear_target_param_dim_num(&mut self) {
        self.target_param_dim_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_target_param_dim_num(&mut self, v: i64) {
        self.target_param_dim_num = v;
    }
}

impl ::protobuf::Message for DynamicParameterBindingProto_Binding {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dynamic_param_num = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dynamic_param_index)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.target_param_num = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.target_param_index)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.target_param_dim_num = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dynamic_param_num != 0 {
            my_size += ::protobuf::rt::value_size(1, self.dynamic_param_num, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.dynamic_param_index {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.target_param_num != 0 {
            my_size += ::protobuf::rt::value_size(3, self.target_param_num, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.target_param_index {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.target_param_dim_num != 0 {
            my_size += ::protobuf::rt::value_size(5, self.target_param_dim_num, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dynamic_param_num != 0 {
            os.write_int64(1, self.dynamic_param_num)?;
        }
        for v in &self.dynamic_param_index {
            os.write_int64(2, *v)?;
        };
        if self.target_param_num != 0 {
            os.write_int64(3, self.target_param_num)?;
        }
        for v in &self.target_param_index {
            os.write_int64(4, *v)?;
        };
        if self.target_param_dim_num != 0 {
            os.write_int64(5, self.target_param_dim_num)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DynamicParameterBindingProto_Binding {
        DynamicParameterBindingProto_Binding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dynamic_param_num",
                |m: &DynamicParameterBindingProto_Binding| { &m.dynamic_param_num },
                |m: &mut DynamicParameterBindingProto_Binding| { &mut m.dynamic_param_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dynamic_param_index",
                |m: &DynamicParameterBindingProto_Binding| { &m.dynamic_param_index },
                |m: &mut DynamicParameterBindingProto_Binding| { &mut m.dynamic_param_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "target_param_num",
                |m: &DynamicParameterBindingProto_Binding| { &m.target_param_num },
                |m: &mut DynamicParameterBindingProto_Binding| { &mut m.target_param_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "target_param_index",
                |m: &DynamicParameterBindingProto_Binding| { &m.target_param_index },
                |m: &mut DynamicParameterBindingProto_Binding| { &mut m.target_param_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "target_param_dim_num",
                |m: &DynamicParameterBindingProto_Binding| { &m.target_param_dim_num },
                |m: &mut DynamicParameterBindingProto_Binding| { &mut m.target_param_dim_num },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DynamicParameterBindingProto_Binding>(
                "DynamicParameterBindingProto.Binding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DynamicParameterBindingProto_Binding {
        static instance: ::protobuf::rt::LazyV2<DynamicParameterBindingProto_Binding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DynamicParameterBindingProto_Binding::new)
    }
}

impl ::protobuf::Clear for DynamicParameterBindingProto_Binding {
    fn clear(&mut self) {
        self.dynamic_param_num = 0;
        self.dynamic_param_index.clear();
        self.target_param_num = 0;
        self.target_param_index.clear();
        self.target_param_dim_num = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DynamicParameterBindingProto_Binding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicParameterBindingProto_Binding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloModuleProto {
    // message fields
    pub name: ::std::string::String,
    pub entry_computation_name: ::std::string::String,
    pub entry_computation_id: i64,
    pub computations: ::protobuf::RepeatedField<HloComputationProto>,
    pub host_program_shape: ::protobuf::SingularPtrField<super::xla_data::ProgramShapeProto>,
    pub id: i64,
    pub schedule: ::protobuf::SingularPtrField<HloScheduleProto>,
    pub input_output_alias: ::protobuf::SingularPtrField<HloInputOutputAliasProto>,
    pub dynamic_parameter_binding: ::protobuf::SingularPtrField<DynamicParameterBindingProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloModuleProto {
    fn default() -> &'a HloModuleProto {
        <HloModuleProto as ::protobuf::Message>::default_instance()
    }
}

impl HloModuleProto {
    pub fn new() -> HloModuleProto {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string entry_computation_name = 2;


    pub fn get_entry_computation_name(&self) -> &str {
        &self.entry_computation_name
    }
    pub fn clear_entry_computation_name(&mut self) {
        self.entry_computation_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_entry_computation_name(&mut self, v: ::std::string::String) {
        self.entry_computation_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entry_computation_name(&mut self) -> &mut ::std::string::String {
        &mut self.entry_computation_name
    }

    // Take field
    pub fn take_entry_computation_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entry_computation_name, ::std::string::String::new())
    }

    // int64 entry_computation_id = 6;


    pub fn get_entry_computation_id(&self) -> i64 {
        self.entry_computation_id
    }
    pub fn clear_entry_computation_id(&mut self) {
        self.entry_computation_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_entry_computation_id(&mut self, v: i64) {
        self.entry_computation_id = v;
    }

    // repeated .xla.HloComputationProto computations = 3;


    pub fn get_computations(&self) -> &[HloComputationProto] {
        &self.computations
    }
    pub fn clear_computations(&mut self) {
        self.computations.clear();
    }

    // Param is passed by value, moved
    pub fn set_computations(&mut self, v: ::protobuf::RepeatedField<HloComputationProto>) {
        self.computations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_computations(&mut self) -> &mut ::protobuf::RepeatedField<HloComputationProto> {
        &mut self.computations
    }

    // Take field
    pub fn take_computations(&mut self) -> ::protobuf::RepeatedField<HloComputationProto> {
        ::std::mem::replace(&mut self.computations, ::protobuf::RepeatedField::new())
    }

    // .xla.ProgramShapeProto host_program_shape = 4;


    pub fn get_host_program_shape(&self) -> &super::xla_data::ProgramShapeProto {
        self.host_program_shape.as_ref().unwrap_or_else(|| <super::xla_data::ProgramShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_host_program_shape(&mut self) {
        self.host_program_shape.clear();
    }

    pub fn has_host_program_shape(&self) -> bool {
        self.host_program_shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host_program_shape(&mut self, v: super::xla_data::ProgramShapeProto) {
        self.host_program_shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_program_shape(&mut self) -> &mut super::xla_data::ProgramShapeProto {
        if self.host_program_shape.is_none() {
            self.host_program_shape.set_default();
        }
        self.host_program_shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_host_program_shape(&mut self) -> super::xla_data::ProgramShapeProto {
        self.host_program_shape.take().unwrap_or_else(|| super::xla_data::ProgramShapeProto::new())
    }

    // int64 id = 5;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // .xla.HloScheduleProto schedule = 7;


    pub fn get_schedule(&self) -> &HloScheduleProto {
        self.schedule.as_ref().unwrap_or_else(|| <HloScheduleProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_schedule(&mut self) {
        self.schedule.clear();
    }

    pub fn has_schedule(&self) -> bool {
        self.schedule.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedule(&mut self, v: HloScheduleProto) {
        self.schedule = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedule(&mut self) -> &mut HloScheduleProto {
        if self.schedule.is_none() {
            self.schedule.set_default();
        }
        self.schedule.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedule(&mut self) -> HloScheduleProto {
        self.schedule.take().unwrap_or_else(|| HloScheduleProto::new())
    }

    // .xla.HloInputOutputAliasProto input_output_alias = 8;


    pub fn get_input_output_alias(&self) -> &HloInputOutputAliasProto {
        self.input_output_alias.as_ref().unwrap_or_else(|| <HloInputOutputAliasProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_input_output_alias(&mut self) {
        self.input_output_alias.clear();
    }

    pub fn has_input_output_alias(&self) -> bool {
        self.input_output_alias.is_some()
    }

    // Param is passed by value, moved
    pub fn set_input_output_alias(&mut self, v: HloInputOutputAliasProto) {
        self.input_output_alias = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_input_output_alias(&mut self) -> &mut HloInputOutputAliasProto {
        if self.input_output_alias.is_none() {
            self.input_output_alias.set_default();
        }
        self.input_output_alias.as_mut().unwrap()
    }

    // Take field
    pub fn take_input_output_alias(&mut self) -> HloInputOutputAliasProto {
        self.input_output_alias.take().unwrap_or_else(|| HloInputOutputAliasProto::new())
    }

    // .xla.DynamicParameterBindingProto dynamic_parameter_binding = 9;


    pub fn get_dynamic_parameter_binding(&self) -> &DynamicParameterBindingProto {
        self.dynamic_parameter_binding.as_ref().unwrap_or_else(|| <DynamicParameterBindingProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dynamic_parameter_binding(&mut self) {
        self.dynamic_parameter_binding.clear();
    }

    pub fn has_dynamic_parameter_binding(&self) -> bool {
        self.dynamic_parameter_binding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dynamic_parameter_binding(&mut self, v: DynamicParameterBindingProto) {
        self.dynamic_parameter_binding = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dynamic_parameter_binding(&mut self) -> &mut DynamicParameterBindingProto {
        if self.dynamic_parameter_binding.is_none() {
            self.dynamic_parameter_binding.set_default();
        }
        self.dynamic_parameter_binding.as_mut().unwrap()
    }

    // Take field
    pub fn take_dynamic_parameter_binding(&mut self) -> DynamicParameterBindingProto {
        self.dynamic_parameter_binding.take().unwrap_or_else(|| DynamicParameterBindingProto::new())
    }
}

impl ::protobuf::Message for HloModuleProto {
    fn is_initialized(&self) -> bool {
        for v in &self.computations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.host_program_shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.schedule {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_output_alias {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dynamic_parameter_binding {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entry_computation_name)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.entry_computation_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.computations)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.host_program_shape)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.schedule)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.input_output_alias)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dynamic_parameter_binding)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.entry_computation_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.entry_computation_name);
        }
        if self.entry_computation_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.entry_computation_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.computations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.host_program_shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.schedule.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.input_output_alias.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.dynamic_parameter_binding.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.entry_computation_name.is_empty() {
            os.write_string(2, &self.entry_computation_name)?;
        }
        if self.entry_computation_id != 0 {
            os.write_int64(6, self.entry_computation_id)?;
        }
        for v in &self.computations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.host_program_shape.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.id != 0 {
            os.write_int64(5, self.id)?;
        }
        if let Some(ref v) = self.schedule.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.input_output_alias.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.dynamic_parameter_binding.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloModuleProto {
        HloModuleProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HloModuleProto| { &m.name },
                |m: &mut HloModuleProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "entry_computation_name",
                |m: &HloModuleProto| { &m.entry_computation_name },
                |m: &mut HloModuleProto| { &mut m.entry_computation_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "entry_computation_id",
                |m: &HloModuleProto| { &m.entry_computation_id },
                |m: &mut HloModuleProto| { &mut m.entry_computation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloComputationProto>>(
                "computations",
                |m: &HloModuleProto| { &m.computations },
                |m: &mut HloModuleProto| { &mut m.computations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ProgramShapeProto>>(
                "host_program_shape",
                |m: &HloModuleProto| { &m.host_program_shape },
                |m: &mut HloModuleProto| { &mut m.host_program_shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &HloModuleProto| { &m.id },
                |m: &mut HloModuleProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloScheduleProto>>(
                "schedule",
                |m: &HloModuleProto| { &m.schedule },
                |m: &mut HloModuleProto| { &mut m.schedule },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloInputOutputAliasProto>>(
                "input_output_alias",
                |m: &HloModuleProto| { &m.input_output_alias },
                |m: &mut HloModuleProto| { &mut m.input_output_alias },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DynamicParameterBindingProto>>(
                "dynamic_parameter_binding",
                |m: &HloModuleProto| { &m.dynamic_parameter_binding },
                |m: &mut HloModuleProto| { &mut m.dynamic_parameter_binding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloModuleProto>(
                "HloModuleProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloModuleProto {
        static instance: ::protobuf::rt::LazyV2<HloModuleProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloModuleProto::new)
    }
}

impl ::protobuf::Clear for HloModuleProto {
    fn clear(&mut self) {
        self.name.clear();
        self.entry_computation_name.clear();
        self.entry_computation_id = 0;
        self.computations.clear();
        self.host_program_shape.clear();
        self.id = 0;
        self.schedule.clear();
        self.input_output_alias.clear();
        self.dynamic_parameter_binding.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloModuleProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloModuleProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogicalBufferProto {
    // message fields
    pub id: i64,
    pub size: i64,
    pub defined_at: ::protobuf::SingularPtrField<LogicalBufferProto_Location>,
    pub color: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogicalBufferProto {
    fn default() -> &'a LogicalBufferProto {
        <LogicalBufferProto as ::protobuf::Message>::default_instance()
    }
}

impl LogicalBufferProto {
    pub fn new() -> LogicalBufferProto {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // int64 size = 2;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // .xla.LogicalBufferProto.Location defined_at = 3;


    pub fn get_defined_at(&self) -> &LogicalBufferProto_Location {
        self.defined_at.as_ref().unwrap_or_else(|| <LogicalBufferProto_Location as ::protobuf::Message>::default_instance())
    }
    pub fn clear_defined_at(&mut self) {
        self.defined_at.clear();
    }

    pub fn has_defined_at(&self) -> bool {
        self.defined_at.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defined_at(&mut self, v: LogicalBufferProto_Location) {
        self.defined_at = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defined_at(&mut self) -> &mut LogicalBufferProto_Location {
        if self.defined_at.is_none() {
            self.defined_at.set_default();
        }
        self.defined_at.as_mut().unwrap()
    }

    // Take field
    pub fn take_defined_at(&mut self) -> LogicalBufferProto_Location {
        self.defined_at.take().unwrap_or_else(|| LogicalBufferProto_Location::new())
    }

    // int64 color = 4;


    pub fn get_color(&self) -> i64 {
        self.color
    }
    pub fn clear_color(&mut self) {
        self.color = 0;
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: i64) {
        self.color = v;
    }
}

impl ::protobuf::Message for LogicalBufferProto {
    fn is_initialized(&self) -> bool {
        for v in &self.defined_at {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defined_at)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.color = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.defined_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.color != 0 {
            my_size += ::protobuf::rt::value_size(4, self.color, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if self.size != 0 {
            os.write_int64(2, self.size)?;
        }
        if let Some(ref v) = self.defined_at.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.color != 0 {
            os.write_int64(4, self.color)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogicalBufferProto {
        LogicalBufferProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &LogicalBufferProto| { &m.id },
                |m: &mut LogicalBufferProto| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &LogicalBufferProto| { &m.size },
                |m: &mut LogicalBufferProto| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalBufferProto_Location>>(
                "defined_at",
                |m: &LogicalBufferProto| { &m.defined_at },
                |m: &mut LogicalBufferProto| { &mut m.defined_at },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "color",
                |m: &LogicalBufferProto| { &m.color },
                |m: &mut LogicalBufferProto| { &mut m.color },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogicalBufferProto>(
                "LogicalBufferProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogicalBufferProto {
        static instance: ::protobuf::rt::LazyV2<LogicalBufferProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogicalBufferProto::new)
    }
}

impl ::protobuf::Clear for LogicalBufferProto {
    fn clear(&mut self) {
        self.id = 0;
        self.size = 0;
        self.defined_at.clear();
        self.color = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogicalBufferProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalBufferProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogicalBufferProto_Location {
    // message fields
    pub computation_name: ::std::string::String,
    pub instruction_name: ::std::string::String,
    pub shape_index: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogicalBufferProto_Location {
    fn default() -> &'a LogicalBufferProto_Location {
        <LogicalBufferProto_Location as ::protobuf::Message>::default_instance()
    }
}

impl LogicalBufferProto_Location {
    pub fn new() -> LogicalBufferProto_Location {
        ::std::default::Default::default()
    }

    // string computation_name = 1;


    pub fn get_computation_name(&self) -> &str {
        &self.computation_name
    }
    pub fn clear_computation_name(&mut self) {
        self.computation_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_computation_name(&mut self, v: ::std::string::String) {
        self.computation_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_computation_name(&mut self) -> &mut ::std::string::String {
        &mut self.computation_name
    }

    // Take field
    pub fn take_computation_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.computation_name, ::std::string::String::new())
    }

    // string instruction_name = 2;


    pub fn get_instruction_name(&self) -> &str {
        &self.instruction_name
    }
    pub fn clear_instruction_name(&mut self) {
        self.instruction_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_instruction_name(&mut self, v: ::std::string::String) {
        self.instruction_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instruction_name(&mut self) -> &mut ::std::string::String {
        &mut self.instruction_name
    }

    // Take field
    pub fn take_instruction_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.instruction_name, ::std::string::String::new())
    }

    // repeated int64 shape_index = 3;


    pub fn get_shape_index(&self) -> &[i64] {
        &self.shape_index
    }
    pub fn clear_shape_index(&mut self) {
        self.shape_index.clear();
    }

    // Param is passed by value, moved
    pub fn set_shape_index(&mut self, v: ::std::vec::Vec<i64>) {
        self.shape_index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shape_index(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.shape_index
    }

    // Take field
    pub fn take_shape_index(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.shape_index, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LogicalBufferProto_Location {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.computation_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.instruction_name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.shape_index)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.computation_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.computation_name);
        }
        if !self.instruction_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.instruction_name);
        }
        for value in &self.shape_index {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.computation_name.is_empty() {
            os.write_string(1, &self.computation_name)?;
        }
        if !self.instruction_name.is_empty() {
            os.write_string(2, &self.instruction_name)?;
        }
        for v in &self.shape_index {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogicalBufferProto_Location {
        LogicalBufferProto_Location::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "computation_name",
                |m: &LogicalBufferProto_Location| { &m.computation_name },
                |m: &mut LogicalBufferProto_Location| { &mut m.computation_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instruction_name",
                |m: &LogicalBufferProto_Location| { &m.instruction_name },
                |m: &mut LogicalBufferProto_Location| { &mut m.instruction_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "shape_index",
                |m: &LogicalBufferProto_Location| { &m.shape_index },
                |m: &mut LogicalBufferProto_Location| { &mut m.shape_index },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogicalBufferProto_Location>(
                "LogicalBufferProto.Location",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogicalBufferProto_Location {
        static instance: ::protobuf::rt::LazyV2<LogicalBufferProto_Location> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogicalBufferProto_Location::new)
    }
}

impl ::protobuf::Clear for LogicalBufferProto_Location {
    fn clear(&mut self) {
        self.computation_name.clear();
        self.instruction_name.clear();
        self.shape_index.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogicalBufferProto_Location {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogicalBufferProto_Location {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BufferAllocationProto {
    // message fields
    pub index: i64,
    pub size: i64,
    pub is_thread_local: bool,
    pub is_tuple: bool,
    pub is_entry_computation_parameter: bool,
    pub is_constant: bool,
    pub parameter_number: i64,
    pub parameter_shape_index: ::std::vec::Vec<i64>,
    pub maybe_live_out: bool,
    pub color: i64,
    pub assigned: ::protobuf::RepeatedField<BufferAllocationProto_Assigned>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BufferAllocationProto {
    fn default() -> &'a BufferAllocationProto {
        <BufferAllocationProto as ::protobuf::Message>::default_instance()
    }
}

impl BufferAllocationProto {
    pub fn new() -> BufferAllocationProto {
        ::std::default::Default::default()
    }

    // int64 index = 1;


    pub fn get_index(&self) -> i64 {
        self.index
    }
    pub fn clear_index(&mut self) {
        self.index = 0;
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: i64) {
        self.index = v;
    }

    // int64 size = 2;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // bool is_thread_local = 3;


    pub fn get_is_thread_local(&self) -> bool {
        self.is_thread_local
    }
    pub fn clear_is_thread_local(&mut self) {
        self.is_thread_local = false;
    }

    // Param is passed by value, moved
    pub fn set_is_thread_local(&mut self, v: bool) {
        self.is_thread_local = v;
    }

    // bool is_tuple = 11;


    pub fn get_is_tuple(&self) -> bool {
        self.is_tuple
    }
    pub fn clear_is_tuple(&mut self) {
        self.is_tuple = false;
    }

    // Param is passed by value, moved
    pub fn set_is_tuple(&mut self, v: bool) {
        self.is_tuple = v;
    }

    // bool is_entry_computation_parameter = 5;


    pub fn get_is_entry_computation_parameter(&self) -> bool {
        self.is_entry_computation_parameter
    }
    pub fn clear_is_entry_computation_parameter(&mut self) {
        self.is_entry_computation_parameter = false;
    }

    // Param is passed by value, moved
    pub fn set_is_entry_computation_parameter(&mut self, v: bool) {
        self.is_entry_computation_parameter = v;
    }

    // bool is_constant = 12;


    pub fn get_is_constant(&self) -> bool {
        self.is_constant
    }
    pub fn clear_is_constant(&mut self) {
        self.is_constant = false;
    }

    // Param is passed by value, moved
    pub fn set_is_constant(&mut self, v: bool) {
        self.is_constant = v;
    }

    // int64 parameter_number = 6;


    pub fn get_parameter_number(&self) -> i64 {
        self.parameter_number
    }
    pub fn clear_parameter_number(&mut self) {
        self.parameter_number = 0;
    }

    // Param is passed by value, moved
    pub fn set_parameter_number(&mut self, v: i64) {
        self.parameter_number = v;
    }

    // repeated int64 parameter_shape_index = 10;


    pub fn get_parameter_shape_index(&self) -> &[i64] {
        &self.parameter_shape_index
    }
    pub fn clear_parameter_shape_index(&mut self) {
        self.parameter_shape_index.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter_shape_index(&mut self, v: ::std::vec::Vec<i64>) {
        self.parameter_shape_index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameter_shape_index(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.parameter_shape_index
    }

    // Take field
    pub fn take_parameter_shape_index(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.parameter_shape_index, ::std::vec::Vec::new())
    }

    // bool maybe_live_out = 7;


    pub fn get_maybe_live_out(&self) -> bool {
        self.maybe_live_out
    }
    pub fn clear_maybe_live_out(&mut self) {
        self.maybe_live_out = false;
    }

    // Param is passed by value, moved
    pub fn set_maybe_live_out(&mut self, v: bool) {
        self.maybe_live_out = v;
    }

    // int64 color = 8;


    pub fn get_color(&self) -> i64 {
        self.color
    }
    pub fn clear_color(&mut self) {
        self.color = 0;
    }

    // Param is passed by value, moved
    pub fn set_color(&mut self, v: i64) {
        self.color = v;
    }

    // repeated .xla.BufferAllocationProto.Assigned assigned = 9;


    pub fn get_assigned(&self) -> &[BufferAllocationProto_Assigned] {
        &self.assigned
    }
    pub fn clear_assigned(&mut self) {
        self.assigned.clear();
    }

    // Param is passed by value, moved
    pub fn set_assigned(&mut self, v: ::protobuf::RepeatedField<BufferAllocationProto_Assigned>) {
        self.assigned = v;
    }

    // Mutable pointer to the field.
    pub fn mut_assigned(&mut self) -> &mut ::protobuf::RepeatedField<BufferAllocationProto_Assigned> {
        &mut self.assigned
    }

    // Take field
    pub fn take_assigned(&mut self) -> ::protobuf::RepeatedField<BufferAllocationProto_Assigned> {
        ::std::mem::replace(&mut self.assigned, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BufferAllocationProto {
    fn is_initialized(&self) -> bool {
        for v in &self.assigned {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_thread_local = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_tuple = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_entry_computation_parameter = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_constant = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.parameter_number = tmp;
                },
                10 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.parameter_shape_index)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.maybe_live_out = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.color = tmp;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.assigned)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.index != 0 {
            my_size += ::protobuf::rt::value_size(1, self.index, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_thread_local != false {
            my_size += 2;
        }
        if self.is_tuple != false {
            my_size += 2;
        }
        if self.is_entry_computation_parameter != false {
            my_size += 2;
        }
        if self.is_constant != false {
            my_size += 2;
        }
        if self.parameter_number != 0 {
            my_size += ::protobuf::rt::value_size(6, self.parameter_number, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.parameter_shape_index {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.maybe_live_out != false {
            my_size += 2;
        }
        if self.color != 0 {
            my_size += ::protobuf::rt::value_size(8, self.color, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.assigned {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.index != 0 {
            os.write_int64(1, self.index)?;
        }
        if self.size != 0 {
            os.write_int64(2, self.size)?;
        }
        if self.is_thread_local != false {
            os.write_bool(3, self.is_thread_local)?;
        }
        if self.is_tuple != false {
            os.write_bool(11, self.is_tuple)?;
        }
        if self.is_entry_computation_parameter != false {
            os.write_bool(5, self.is_entry_computation_parameter)?;
        }
        if self.is_constant != false {
            os.write_bool(12, self.is_constant)?;
        }
        if self.parameter_number != 0 {
            os.write_int64(6, self.parameter_number)?;
        }
        for v in &self.parameter_shape_index {
            os.write_int64(10, *v)?;
        };
        if self.maybe_live_out != false {
            os.write_bool(7, self.maybe_live_out)?;
        }
        if self.color != 0 {
            os.write_int64(8, self.color)?;
        }
        for v in &self.assigned {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BufferAllocationProto {
        BufferAllocationProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index",
                |m: &BufferAllocationProto| { &m.index },
                |m: &mut BufferAllocationProto| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &BufferAllocationProto| { &m.size },
                |m: &mut BufferAllocationProto| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_thread_local",
                |m: &BufferAllocationProto| { &m.is_thread_local },
                |m: &mut BufferAllocationProto| { &mut m.is_thread_local },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_tuple",
                |m: &BufferAllocationProto| { &m.is_tuple },
                |m: &mut BufferAllocationProto| { &mut m.is_tuple },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_entry_computation_parameter",
                |m: &BufferAllocationProto| { &m.is_entry_computation_parameter },
                |m: &mut BufferAllocationProto| { &mut m.is_entry_computation_parameter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_constant",
                |m: &BufferAllocationProto| { &m.is_constant },
                |m: &mut BufferAllocationProto| { &mut m.is_constant },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "parameter_number",
                |m: &BufferAllocationProto| { &m.parameter_number },
                |m: &mut BufferAllocationProto| { &mut m.parameter_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "parameter_shape_index",
                |m: &BufferAllocationProto| { &m.parameter_shape_index },
                |m: &mut BufferAllocationProto| { &mut m.parameter_shape_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "maybe_live_out",
                |m: &BufferAllocationProto| { &m.maybe_live_out },
                |m: &mut BufferAllocationProto| { &mut m.maybe_live_out },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "color",
                |m: &BufferAllocationProto| { &m.color },
                |m: &mut BufferAllocationProto| { &mut m.color },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BufferAllocationProto_Assigned>>(
                "assigned",
                |m: &BufferAllocationProto| { &m.assigned },
                |m: &mut BufferAllocationProto| { &mut m.assigned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BufferAllocationProto>(
                "BufferAllocationProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BufferAllocationProto {
        static instance: ::protobuf::rt::LazyV2<BufferAllocationProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BufferAllocationProto::new)
    }
}

impl ::protobuf::Clear for BufferAllocationProto {
    fn clear(&mut self) {
        self.index = 0;
        self.size = 0;
        self.is_thread_local = false;
        self.is_tuple = false;
        self.is_entry_computation_parameter = false;
        self.is_constant = false;
        self.parameter_number = 0;
        self.parameter_shape_index.clear();
        self.maybe_live_out = false;
        self.color = 0;
        self.assigned.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BufferAllocationProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferAllocationProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BufferAllocationProto_Assigned {
    // message fields
    pub logical_buffer_id: i64,
    pub offset: i64,
    pub size: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BufferAllocationProto_Assigned {
    fn default() -> &'a BufferAllocationProto_Assigned {
        <BufferAllocationProto_Assigned as ::protobuf::Message>::default_instance()
    }
}

impl BufferAllocationProto_Assigned {
    pub fn new() -> BufferAllocationProto_Assigned {
        ::std::default::Default::default()
    }

    // int64 logical_buffer_id = 1;


    pub fn get_logical_buffer_id(&self) -> i64 {
        self.logical_buffer_id
    }
    pub fn clear_logical_buffer_id(&mut self) {
        self.logical_buffer_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_logical_buffer_id(&mut self, v: i64) {
        self.logical_buffer_id = v;
    }

    // int64 offset = 2;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 size = 3;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }
}

impl ::protobuf::Message for BufferAllocationProto_Assigned {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.logical_buffer_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.logical_buffer_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.logical_buffer_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.logical_buffer_id != 0 {
            os.write_int64(1, self.logical_buffer_id)?;
        }
        if self.offset != 0 {
            os.write_int64(2, self.offset)?;
        }
        if self.size != 0 {
            os.write_int64(3, self.size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BufferAllocationProto_Assigned {
        BufferAllocationProto_Assigned::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "logical_buffer_id",
                |m: &BufferAllocationProto_Assigned| { &m.logical_buffer_id },
                |m: &mut BufferAllocationProto_Assigned| { &mut m.logical_buffer_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "offset",
                |m: &BufferAllocationProto_Assigned| { &m.offset },
                |m: &mut BufferAllocationProto_Assigned| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &BufferAllocationProto_Assigned| { &m.size },
                |m: &mut BufferAllocationProto_Assigned| { &mut m.size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BufferAllocationProto_Assigned>(
                "BufferAllocationProto.Assigned",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BufferAllocationProto_Assigned {
        static instance: ::protobuf::rt::LazyV2<BufferAllocationProto_Assigned> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BufferAllocationProto_Assigned::new)
    }
}

impl ::protobuf::Clear for BufferAllocationProto_Assigned {
    fn clear(&mut self) {
        self.logical_buffer_id = 0;
        self.offset = 0;
        self.size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BufferAllocationProto_Assigned {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferAllocationProto_Assigned {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeapSimulatorTrace {
    // message fields
    pub events: ::protobuf::RepeatedField<HeapSimulatorTrace_Event>,
    pub whole_module_simulation: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeapSimulatorTrace {
    fn default() -> &'a HeapSimulatorTrace {
        <HeapSimulatorTrace as ::protobuf::Message>::default_instance()
    }
}

impl HeapSimulatorTrace {
    pub fn new() -> HeapSimulatorTrace {
        ::std::default::Default::default()
    }

    // repeated .xla.HeapSimulatorTrace.Event events = 1;


    pub fn get_events(&self) -> &[HeapSimulatorTrace_Event] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<HeapSimulatorTrace_Event>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<HeapSimulatorTrace_Event> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<HeapSimulatorTrace_Event> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }

    // bool whole_module_simulation = 2;


    pub fn get_whole_module_simulation(&self) -> bool {
        self.whole_module_simulation
    }
    pub fn clear_whole_module_simulation(&mut self) {
        self.whole_module_simulation = false;
    }

    // Param is passed by value, moved
    pub fn set_whole_module_simulation(&mut self, v: bool) {
        self.whole_module_simulation = v;
    }
}

impl ::protobuf::Message for HeapSimulatorTrace {
    fn is_initialized(&self) -> bool {
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.whole_module_simulation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.whole_module_simulation != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.events {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.whole_module_simulation != false {
            os.write_bool(2, self.whole_module_simulation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeapSimulatorTrace {
        HeapSimulatorTrace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeapSimulatorTrace_Event>>(
                "events",
                |m: &HeapSimulatorTrace| { &m.events },
                |m: &mut HeapSimulatorTrace| { &mut m.events },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "whole_module_simulation",
                |m: &HeapSimulatorTrace| { &m.whole_module_simulation },
                |m: &mut HeapSimulatorTrace| { &mut m.whole_module_simulation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeapSimulatorTrace>(
                "HeapSimulatorTrace",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeapSimulatorTrace {
        static instance: ::protobuf::rt::LazyV2<HeapSimulatorTrace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeapSimulatorTrace::new)
    }
}

impl ::protobuf::Clear for HeapSimulatorTrace {
    fn clear(&mut self) {
        self.events.clear();
        self.whole_module_simulation = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeapSimulatorTrace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeapSimulatorTrace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HeapSimulatorTrace_Event {
    // message fields
    pub kind: HeapSimulatorTrace_Event_Kind,
    pub buffer_id: i64,
    pub computation_name: ::std::string::String,
    pub instruction_name: ::std::string::String,
    pub share_with_canonical_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HeapSimulatorTrace_Event {
    fn default() -> &'a HeapSimulatorTrace_Event {
        <HeapSimulatorTrace_Event as ::protobuf::Message>::default_instance()
    }
}

impl HeapSimulatorTrace_Event {
    pub fn new() -> HeapSimulatorTrace_Event {
        ::std::default::Default::default()
    }

    // .xla.HeapSimulatorTrace.Event.Kind kind = 1;


    pub fn get_kind(&self) -> HeapSimulatorTrace_Event_Kind {
        self.kind
    }
    pub fn clear_kind(&mut self) {
        self.kind = HeapSimulatorTrace_Event_Kind::ALLOC;
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: HeapSimulatorTrace_Event_Kind) {
        self.kind = v;
    }

    // int64 buffer_id = 2;


    pub fn get_buffer_id(&self) -> i64 {
        self.buffer_id
    }
    pub fn clear_buffer_id(&mut self) {
        self.buffer_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_buffer_id(&mut self, v: i64) {
        self.buffer_id = v;
    }

    // string computation_name = 3;


    pub fn get_computation_name(&self) -> &str {
        &self.computation_name
    }
    pub fn clear_computation_name(&mut self) {
        self.computation_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_computation_name(&mut self, v: ::std::string::String) {
        self.computation_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_computation_name(&mut self) -> &mut ::std::string::String {
        &mut self.computation_name
    }

    // Take field
    pub fn take_computation_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.computation_name, ::std::string::String::new())
    }

    // string instruction_name = 4;


    pub fn get_instruction_name(&self) -> &str {
        &self.instruction_name
    }
    pub fn clear_instruction_name(&mut self) {
        self.instruction_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_instruction_name(&mut self, v: ::std::string::String) {
        self.instruction_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instruction_name(&mut self) -> &mut ::std::string::String {
        &mut self.instruction_name
    }

    // Take field
    pub fn take_instruction_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.instruction_name, ::std::string::String::new())
    }

    // int64 share_with_canonical_id = 5;


    pub fn get_share_with_canonical_id(&self) -> i64 {
        self.share_with_canonical_id
    }
    pub fn clear_share_with_canonical_id(&mut self) {
        self.share_with_canonical_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_share_with_canonical_id(&mut self, v: i64) {
        self.share_with_canonical_id = v;
    }
}

impl ::protobuf::Message for HeapSimulatorTrace_Event {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.kind, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.buffer_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.computation_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.instruction_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.share_with_canonical_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.kind != HeapSimulatorTrace_Event_Kind::ALLOC {
            my_size += ::protobuf::rt::enum_size(1, self.kind);
        }
        if self.buffer_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.buffer_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.computation_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.computation_name);
        }
        if !self.instruction_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.instruction_name);
        }
        if self.share_with_canonical_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.share_with_canonical_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.kind != HeapSimulatorTrace_Event_Kind::ALLOC {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.kind))?;
        }
        if self.buffer_id != 0 {
            os.write_int64(2, self.buffer_id)?;
        }
        if !self.computation_name.is_empty() {
            os.write_string(3, &self.computation_name)?;
        }
        if !self.instruction_name.is_empty() {
            os.write_string(4, &self.instruction_name)?;
        }
        if self.share_with_canonical_id != 0 {
            os.write_int64(5, self.share_with_canonical_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HeapSimulatorTrace_Event {
        HeapSimulatorTrace_Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HeapSimulatorTrace_Event_Kind>>(
                "kind",
                |m: &HeapSimulatorTrace_Event| { &m.kind },
                |m: &mut HeapSimulatorTrace_Event| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "buffer_id",
                |m: &HeapSimulatorTrace_Event| { &m.buffer_id },
                |m: &mut HeapSimulatorTrace_Event| { &mut m.buffer_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "computation_name",
                |m: &HeapSimulatorTrace_Event| { &m.computation_name },
                |m: &mut HeapSimulatorTrace_Event| { &mut m.computation_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instruction_name",
                |m: &HeapSimulatorTrace_Event| { &m.instruction_name },
                |m: &mut HeapSimulatorTrace_Event| { &mut m.instruction_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "share_with_canonical_id",
                |m: &HeapSimulatorTrace_Event| { &m.share_with_canonical_id },
                |m: &mut HeapSimulatorTrace_Event| { &mut m.share_with_canonical_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HeapSimulatorTrace_Event>(
                "HeapSimulatorTrace.Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HeapSimulatorTrace_Event {
        static instance: ::protobuf::rt::LazyV2<HeapSimulatorTrace_Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HeapSimulatorTrace_Event::new)
    }
}

impl ::protobuf::Clear for HeapSimulatorTrace_Event {
    fn clear(&mut self) {
        self.kind = HeapSimulatorTrace_Event_Kind::ALLOC;
        self.buffer_id = 0;
        self.computation_name.clear();
        self.instruction_name.clear();
        self.share_with_canonical_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HeapSimulatorTrace_Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HeapSimulatorTrace_Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HeapSimulatorTrace_Event_Kind {
    ALLOC = 0,
    FREE = 1,
    SHARE_WITH = 2,
}

impl ::protobuf::ProtobufEnum for HeapSimulatorTrace_Event_Kind {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HeapSimulatorTrace_Event_Kind> {
        match value {
            0 => ::std::option::Option::Some(HeapSimulatorTrace_Event_Kind::ALLOC),
            1 => ::std::option::Option::Some(HeapSimulatorTrace_Event_Kind::FREE),
            2 => ::std::option::Option::Some(HeapSimulatorTrace_Event_Kind::SHARE_WITH),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HeapSimulatorTrace_Event_Kind] = &[
            HeapSimulatorTrace_Event_Kind::ALLOC,
            HeapSimulatorTrace_Event_Kind::FREE,
            HeapSimulatorTrace_Event_Kind::SHARE_WITH,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HeapSimulatorTrace_Event_Kind>("HeapSimulatorTrace.Event.Kind", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HeapSimulatorTrace_Event_Kind {
}

impl ::std::default::Default for HeapSimulatorTrace_Event_Kind {
    fn default() -> Self {
        HeapSimulatorTrace_Event_Kind::ALLOC
    }
}

impl ::protobuf::reflect::ProtobufValue for HeapSimulatorTrace_Event_Kind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloModuleGroupProto {
    // message fields
    pub name: ::std::string::String,
    pub hlo_modules: ::protobuf::RepeatedField<HloModuleProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloModuleGroupProto {
    fn default() -> &'a HloModuleGroupProto {
        <HloModuleGroupProto as ::protobuf::Message>::default_instance()
    }
}

impl HloModuleGroupProto {
    pub fn new() -> HloModuleGroupProto {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .xla.HloModuleProto hlo_modules = 2;


    pub fn get_hlo_modules(&self) -> &[HloModuleProto] {
        &self.hlo_modules
    }
    pub fn clear_hlo_modules(&mut self) {
        self.hlo_modules.clear();
    }

    // Param is passed by value, moved
    pub fn set_hlo_modules(&mut self, v: ::protobuf::RepeatedField<HloModuleProto>) {
        self.hlo_modules = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hlo_modules(&mut self) -> &mut ::protobuf::RepeatedField<HloModuleProto> {
        &mut self.hlo_modules
    }

    // Take field
    pub fn take_hlo_modules(&mut self) -> ::protobuf::RepeatedField<HloModuleProto> {
        ::std::mem::replace(&mut self.hlo_modules, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HloModuleGroupProto {
    fn is_initialized(&self) -> bool {
        for v in &self.hlo_modules {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hlo_modules)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        for value in &self.hlo_modules {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        for v in &self.hlo_modules {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloModuleGroupProto {
        HloModuleGroupProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HloModuleGroupProto| { &m.name },
                |m: &mut HloModuleGroupProto| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloModuleProto>>(
                "hlo_modules",
                |m: &HloModuleGroupProto| { &m.hlo_modules },
                |m: &mut HloModuleGroupProto| { &mut m.hlo_modules },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloModuleGroupProto>(
                "HloModuleGroupProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloModuleGroupProto {
        static instance: ::protobuf::rt::LazyV2<HloModuleGroupProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloModuleGroupProto::new)
    }
}

impl ::protobuf::Clear for HloModuleGroupProto {
    fn clear(&mut self) {
        self.name.clear();
        self.hlo_modules.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloModuleGroupProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloModuleGroupProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BufferAssignmentProto {
    // message fields
    pub logical_buffers: ::protobuf::RepeatedField<LogicalBufferProto>,
    pub buffer_aliases: ::protobuf::RepeatedField<BufferAssignmentProto_BufferAlias>,
    pub buffer_allocations: ::protobuf::RepeatedField<BufferAllocationProto>,
    pub heap_simulator_traces: ::protobuf::RepeatedField<HeapSimulatorTrace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BufferAssignmentProto {
    fn default() -> &'a BufferAssignmentProto {
        <BufferAssignmentProto as ::protobuf::Message>::default_instance()
    }
}

impl BufferAssignmentProto {
    pub fn new() -> BufferAssignmentProto {
        ::std::default::Default::default()
    }

    // repeated .xla.LogicalBufferProto logical_buffers = 1;


    pub fn get_logical_buffers(&self) -> &[LogicalBufferProto] {
        &self.logical_buffers
    }
    pub fn clear_logical_buffers(&mut self) {
        self.logical_buffers.clear();
    }

    // Param is passed by value, moved
    pub fn set_logical_buffers(&mut self, v: ::protobuf::RepeatedField<LogicalBufferProto>) {
        self.logical_buffers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logical_buffers(&mut self) -> &mut ::protobuf::RepeatedField<LogicalBufferProto> {
        &mut self.logical_buffers
    }

    // Take field
    pub fn take_logical_buffers(&mut self) -> ::protobuf::RepeatedField<LogicalBufferProto> {
        ::std::mem::replace(&mut self.logical_buffers, ::protobuf::RepeatedField::new())
    }

    // repeated .xla.BufferAssignmentProto.BufferAlias buffer_aliases = 2;


    pub fn get_buffer_aliases(&self) -> &[BufferAssignmentProto_BufferAlias] {
        &self.buffer_aliases
    }
    pub fn clear_buffer_aliases(&mut self) {
        self.buffer_aliases.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffer_aliases(&mut self, v: ::protobuf::RepeatedField<BufferAssignmentProto_BufferAlias>) {
        self.buffer_aliases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buffer_aliases(&mut self) -> &mut ::protobuf::RepeatedField<BufferAssignmentProto_BufferAlias> {
        &mut self.buffer_aliases
    }

    // Take field
    pub fn take_buffer_aliases(&mut self) -> ::protobuf::RepeatedField<BufferAssignmentProto_BufferAlias> {
        ::std::mem::replace(&mut self.buffer_aliases, ::protobuf::RepeatedField::new())
    }

    // repeated .xla.BufferAllocationProto buffer_allocations = 3;


    pub fn get_buffer_allocations(&self) -> &[BufferAllocationProto] {
        &self.buffer_allocations
    }
    pub fn clear_buffer_allocations(&mut self) {
        self.buffer_allocations.clear();
    }

    // Param is passed by value, moved
    pub fn set_buffer_allocations(&mut self, v: ::protobuf::RepeatedField<BufferAllocationProto>) {
        self.buffer_allocations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_buffer_allocations(&mut self) -> &mut ::protobuf::RepeatedField<BufferAllocationProto> {
        &mut self.buffer_allocations
    }

    // Take field
    pub fn take_buffer_allocations(&mut self) -> ::protobuf::RepeatedField<BufferAllocationProto> {
        ::std::mem::replace(&mut self.buffer_allocations, ::protobuf::RepeatedField::new())
    }

    // repeated .xla.HeapSimulatorTrace heap_simulator_traces = 4;


    pub fn get_heap_simulator_traces(&self) -> &[HeapSimulatorTrace] {
        &self.heap_simulator_traces
    }
    pub fn clear_heap_simulator_traces(&mut self) {
        self.heap_simulator_traces.clear();
    }

    // Param is passed by value, moved
    pub fn set_heap_simulator_traces(&mut self, v: ::protobuf::RepeatedField<HeapSimulatorTrace>) {
        self.heap_simulator_traces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_heap_simulator_traces(&mut self) -> &mut ::protobuf::RepeatedField<HeapSimulatorTrace> {
        &mut self.heap_simulator_traces
    }

    // Take field
    pub fn take_heap_simulator_traces(&mut self) -> ::protobuf::RepeatedField<HeapSimulatorTrace> {
        ::std::mem::replace(&mut self.heap_simulator_traces, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BufferAssignmentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.logical_buffers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buffer_aliases {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buffer_allocations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.heap_simulator_traces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.logical_buffers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buffer_aliases)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.buffer_allocations)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.heap_simulator_traces)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.logical_buffers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buffer_aliases {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.buffer_allocations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.heap_simulator_traces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.logical_buffers {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buffer_aliases {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.buffer_allocations {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.heap_simulator_traces {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BufferAssignmentProto {
        BufferAssignmentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalBufferProto>>(
                "logical_buffers",
                |m: &BufferAssignmentProto| { &m.logical_buffers },
                |m: &mut BufferAssignmentProto| { &mut m.logical_buffers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BufferAssignmentProto_BufferAlias>>(
                "buffer_aliases",
                |m: &BufferAssignmentProto| { &m.buffer_aliases },
                |m: &mut BufferAssignmentProto| { &mut m.buffer_aliases },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BufferAllocationProto>>(
                "buffer_allocations",
                |m: &BufferAssignmentProto| { &m.buffer_allocations },
                |m: &mut BufferAssignmentProto| { &mut m.buffer_allocations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HeapSimulatorTrace>>(
                "heap_simulator_traces",
                |m: &BufferAssignmentProto| { &m.heap_simulator_traces },
                |m: &mut BufferAssignmentProto| { &mut m.heap_simulator_traces },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BufferAssignmentProto>(
                "BufferAssignmentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BufferAssignmentProto {
        static instance: ::protobuf::rt::LazyV2<BufferAssignmentProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BufferAssignmentProto::new)
    }
}

impl ::protobuf::Clear for BufferAssignmentProto {
    fn clear(&mut self) {
        self.logical_buffers.clear();
        self.buffer_aliases.clear();
        self.buffer_allocations.clear();
        self.heap_simulator_traces.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BufferAssignmentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferAssignmentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BufferAssignmentProto_BufferAlias {
    // message fields
    pub source_buffer_id: i64,
    pub location: ::protobuf::SingularPtrField<LogicalBufferProto_Location>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BufferAssignmentProto_BufferAlias {
    fn default() -> &'a BufferAssignmentProto_BufferAlias {
        <BufferAssignmentProto_BufferAlias as ::protobuf::Message>::default_instance()
    }
}

impl BufferAssignmentProto_BufferAlias {
    pub fn new() -> BufferAssignmentProto_BufferAlias {
        ::std::default::Default::default()
    }

    // int64 source_buffer_id = 1;


    pub fn get_source_buffer_id(&self) -> i64 {
        self.source_buffer_id
    }
    pub fn clear_source_buffer_id(&mut self) {
        self.source_buffer_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_source_buffer_id(&mut self, v: i64) {
        self.source_buffer_id = v;
    }

    // .xla.LogicalBufferProto.Location location = 2;


    pub fn get_location(&self) -> &LogicalBufferProto_Location {
        self.location.as_ref().unwrap_or_else(|| <LogicalBufferProto_Location as ::protobuf::Message>::default_instance())
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    pub fn has_location(&self) -> bool {
        self.location.is_some()
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: LogicalBufferProto_Location) {
        self.location = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut LogicalBufferProto_Location {
        if self.location.is_none() {
            self.location.set_default();
        }
        self.location.as_mut().unwrap()
    }

    // Take field
    pub fn take_location(&mut self) -> LogicalBufferProto_Location {
        self.location.take().unwrap_or_else(|| LogicalBufferProto_Location::new())
    }
}

impl ::protobuf::Message for BufferAssignmentProto_BufferAlias {
    fn is_initialized(&self) -> bool {
        for v in &self.location {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.source_buffer_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.location)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.source_buffer_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.source_buffer_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.location.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.source_buffer_id != 0 {
            os.write_int64(1, self.source_buffer_id)?;
        }
        if let Some(ref v) = self.location.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BufferAssignmentProto_BufferAlias {
        BufferAssignmentProto_BufferAlias::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "source_buffer_id",
                |m: &BufferAssignmentProto_BufferAlias| { &m.source_buffer_id },
                |m: &mut BufferAssignmentProto_BufferAlias| { &mut m.source_buffer_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LogicalBufferProto_Location>>(
                "location",
                |m: &BufferAssignmentProto_BufferAlias| { &m.location },
                |m: &mut BufferAssignmentProto_BufferAlias| { &mut m.location },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BufferAssignmentProto_BufferAlias>(
                "BufferAssignmentProto.BufferAlias",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BufferAssignmentProto_BufferAlias {
        static instance: ::protobuf::rt::LazyV2<BufferAssignmentProto_BufferAlias> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BufferAssignmentProto_BufferAlias::new)
    }
}

impl ::protobuf::Clear for BufferAssignmentProto_BufferAlias {
    fn clear(&mut self) {
        self.source_buffer_id = 0;
        self.location.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BufferAssignmentProto_BufferAlias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BufferAssignmentProto_BufferAlias {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloProto {
    // message fields
    pub hlo_module: ::protobuf::SingularPtrField<HloModuleProto>,
    pub buffer_assignment: ::protobuf::SingularPtrField<BufferAssignmentProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloProto {
    fn default() -> &'a HloProto {
        <HloProto as ::protobuf::Message>::default_instance()
    }
}

impl HloProto {
    pub fn new() -> HloProto {
        ::std::default::Default::default()
    }

    // .xla.HloModuleProto hlo_module = 1;


    pub fn get_hlo_module(&self) -> &HloModuleProto {
        self.hlo_module.as_ref().unwrap_or_else(|| <HloModuleProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hlo_module(&mut self) {
        self.hlo_module.clear();
    }

    pub fn has_hlo_module(&self) -> bool {
        self.hlo_module.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hlo_module(&mut self, v: HloModuleProto) {
        self.hlo_module = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hlo_module(&mut self) -> &mut HloModuleProto {
        if self.hlo_module.is_none() {
            self.hlo_module.set_default();
        }
        self.hlo_module.as_mut().unwrap()
    }

    // Take field
    pub fn take_hlo_module(&mut self) -> HloModuleProto {
        self.hlo_module.take().unwrap_or_else(|| HloModuleProto::new())
    }

    // .xla.BufferAssignmentProto buffer_assignment = 3;


    pub fn get_buffer_assignment(&self) -> &BufferAssignmentProto {
        self.buffer_assignment.as_ref().unwrap_or_else(|| <BufferAssignmentProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_buffer_assignment(&mut self) {
        self.buffer_assignment.clear();
    }

    pub fn has_buffer_assignment(&self) -> bool {
        self.buffer_assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_buffer_assignment(&mut self, v: BufferAssignmentProto) {
        self.buffer_assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buffer_assignment(&mut self) -> &mut BufferAssignmentProto {
        if self.buffer_assignment.is_none() {
            self.buffer_assignment.set_default();
        }
        self.buffer_assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_buffer_assignment(&mut self) -> BufferAssignmentProto {
        self.buffer_assignment.take().unwrap_or_else(|| BufferAssignmentProto::new())
    }
}

impl ::protobuf::Message for HloProto {
    fn is_initialized(&self) -> bool {
        for v in &self.hlo_module {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.buffer_assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hlo_module)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.buffer_assignment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hlo_module.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.buffer_assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hlo_module.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.buffer_assignment.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloProto {
        HloProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloModuleProto>>(
                "hlo_module",
                |m: &HloProto| { &m.hlo_module },
                |m: &mut HloProto| { &mut m.hlo_module },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BufferAssignmentProto>>(
                "buffer_assignment",
                |m: &HloProto| { &m.buffer_assignment },
                |m: &mut HloProto| { &mut m.buffer_assignment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloProto>(
                "HloProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloProto {
        static instance: ::protobuf::rt::LazyV2<HloProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloProto::new)
    }
}

impl ::protobuf::Clear for HloProto {
    fn clear(&mut self) {
        self.hlo_module.clear();
        self.buffer_assignment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HloSnapshot {
    // message fields
    pub hlo: ::protobuf::SingularPtrField<HloProto>,
    pub arguments: ::protobuf::RepeatedField<super::xla_data::LiteralProto>,
    pub result: ::protobuf::SingularPtrField<super::xla_data::LiteralProto>,
    pub execution_platform: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloSnapshot {
    fn default() -> &'a HloSnapshot {
        <HloSnapshot as ::protobuf::Message>::default_instance()
    }
}

impl HloSnapshot {
    pub fn new() -> HloSnapshot {
        ::std::default::Default::default()
    }

    // .xla.HloProto hlo = 1;


    pub fn get_hlo(&self) -> &HloProto {
        self.hlo.as_ref().unwrap_or_else(|| <HloProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hlo(&mut self) {
        self.hlo.clear();
    }

    pub fn has_hlo(&self) -> bool {
        self.hlo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hlo(&mut self, v: HloProto) {
        self.hlo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hlo(&mut self) -> &mut HloProto {
        if self.hlo.is_none() {
            self.hlo.set_default();
        }
        self.hlo.as_mut().unwrap()
    }

    // Take field
    pub fn take_hlo(&mut self) -> HloProto {
        self.hlo.take().unwrap_or_else(|| HloProto::new())
    }

    // repeated .xla.LiteralProto arguments = 2;


    pub fn get_arguments(&self) -> &[super::xla_data::LiteralProto] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<super::xla_data::LiteralProto>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::LiteralProto> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<super::xla_data::LiteralProto> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    // .xla.LiteralProto result = 3;


    pub fn get_result(&self) -> &super::xla_data::LiteralProto {
        self.result.as_ref().unwrap_or_else(|| <super::xla_data::LiteralProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: super::xla_data::LiteralProto) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut super::xla_data::LiteralProto {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> super::xla_data::LiteralProto {
        self.result.take().unwrap_or_else(|| super::xla_data::LiteralProto::new())
    }

    // string execution_platform = 4;


    pub fn get_execution_platform(&self) -> &str {
        &self.execution_platform
    }
    pub fn clear_execution_platform(&mut self) {
        self.execution_platform.clear();
    }

    // Param is passed by value, moved
    pub fn set_execution_platform(&mut self, v: ::std::string::String) {
        self.execution_platform = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_platform(&mut self) -> &mut ::std::string::String {
        &mut self.execution_platform
    }

    // Take field
    pub fn take_execution_platform(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.execution_platform, ::std::string::String::new())
    }
}

impl ::protobuf::Message for HloSnapshot {
    fn is_initialized(&self) -> bool {
        for v in &self.hlo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arguments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hlo)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arguments)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.execution_platform)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hlo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.execution_platform.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.execution_platform);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hlo.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.arguments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.execution_platform.is_empty() {
            os.write_string(4, &self.execution_platform)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloSnapshot {
        HloSnapshot::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloProto>>(
                "hlo",
                |m: &HloSnapshot| { &m.hlo },
                |m: &mut HloSnapshot| { &mut m.hlo },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "arguments",
                |m: &HloSnapshot| { &m.arguments },
                |m: &mut HloSnapshot| { &mut m.arguments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "result",
                |m: &HloSnapshot| { &m.result },
                |m: &mut HloSnapshot| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "execution_platform",
                |m: &HloSnapshot| { &m.execution_platform },
                |m: &mut HloSnapshot| { &mut m.execution_platform },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloSnapshot>(
                "HloSnapshot",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloSnapshot {
        static instance: ::protobuf::rt::LazyV2<HloSnapshot> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloSnapshot::new)
    }
}

impl ::protobuf::Clear for HloSnapshot {
    fn clear(&mut self) {
        self.hlo.clear();
        self.arguments.clear();
        self.result.clear();
        self.execution_platform.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloSnapshot {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloSnapshot {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)tensorflow/compiler/xla/service/hlo.proto\x12\x03xla\x1a&tensorflow/c\
    ompiler/xla/xla_data.proto\"\xff\x18\n\x13HloInstructionProto\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x12\x16\n\x06opcode\x18\x02\x20\x01\
    (\tR\x06opcode\x12%\n\x05shape\x18\x03\x20\x01(\x0b2\x0f.xla.ShapeProtoR\
    \x05shape\x12+\n\x08metadata\x18\x07\x20\x01(\x0b2\x0f.xla.OpMetadataR\
    \x08metadata\x12+\n\x07literal\x18\x08\x20\x01(\x0b2\x11.xla.LiteralProt\
    oR\x07literal\x12)\n\x10parameter_number\x18\t\x20\x01(\x03R\x0fparamete\
    rNumber\x12\x1f\n\x0bfusion_kind\x18\x0b\x20\x01(\tR\nfusionKind\x12\x1f\
    \n\x0btuple_index\x18\r\x20\x01(\x03R\ntupleIndex\x12\x1e\n\ndimensions\
    \x18\x0e\x20\x03(\x03R\ndimensions\x12#\n\x06window\x18\x0f\x20\x01(\x0b\
    2\x0b.xla.WindowR\x06window\x12d\n\x1dconvolution_dimension_numbers\x18\
    \x10\x20\x01(\x0b2\x20.xla.ConvolutionDimensionNumbersR\x1bconvolutionDi\
    mensionNumbers\x12.\n\x13feature_group_count\x182\x20\x01(\x03R\x11featu\
    reGroupCount\x12*\n\x11batch_group_count\x18:\x20\x01(\x03R\x0fbatchGrou\
    pCount\x12S\n\x10slice_dimensions\x18\x11\x20\x03(\x0b2(.xla.HloInstruct\
    ionProto.SliceDimensionsR\x0fsliceDimensions\x12#\n\rexponent_bits\x18\
    \x12\x20\x01(\x05R\x0cexponentBits\x12#\n\rmantissa_bits\x18\x13\x20\x01\
    (\x05R\x0cmantissaBits\x12.\n\x13dynamic_slice_sizes\x18\x14\x20\x03(\
    \x03R\x11dynamicSliceSizes\x129\n\x0epadding_config\x18\x15\x20\x01(\x0b\
    2\x12.xla.PaddingConfigR\rpaddingConfig\x12%\n\x0eoutfeed_config\x18\x16\
    \x20\x01(\x0cR\routfeedConfig\x12;\n\x0cdistribution\x18\x17\x20\x01(\
    \x0e2\x17.xla.RandomDistributionR\x0cdistribution\x12\x18\n\x07epsilon\
    \x18\x18\x20\x01(\x02R\x07epsilon\x12#\n\rfeature_index\x18\x19\x20\x01(\
    \x03R\x0cfeatureIndex\x12\x1d\n\nchannel_id\x18\x1a\x20\x01(\x03R\tchann\
    elId\x12#\n\rinfeed_config\x18\x1b\x20\x01(\x0cR\x0cinfeedConfig\x12,\n\
    \x12custom_call_target\x18\x1c\x20\x01(\tR\x10customCallTarget\x124\n\ro\
    utfeed_shape\x18\x1d\x20\x01(\x0b2\x0f.xla.ShapeProtoR\x0coutfeedShape\
    \x12L\n\x15dot_dimension_numbers\x18\x1e\x20\x01(\x0b2\x18.xla.DotDimens\
    ionNumbersR\x13dotDimensionNumbers\x12'\n\x08fft_type\x18\x1f\x20\x01(\
    \x0e2\x0c.xla.FftTypeR\x07fftType\x12\x1d\n\nfft_length\x18\x20\x20\x03(\
    \x03R\tfftLength\x121\n\x14comparison_direction\x18?\x20\x01(\tR\x13comp\
    arisonDirection\x12U\n\x18gather_dimension_numbers\x18!\x20\x01(\x0b2\
    \x1b.xla.GatherDimensionNumbersR\x16gatherDimensionNumbers\x12,\n\x12gat\
    her_slice_sizes\x18\"\x20\x03(\x03R\x10gatherSliceSizes\x12!\n\x0cchanne\
    l_name\x18)\x20\x01(\tR\x0bchannelName\x12(\n\x10cost_estimate_ns\x18*\
    \x20\x01(\x03R\x0ecostEstimateNs\x12\x0e\n\x02id\x18#\x20\x01(\x03R\x02i\
    d\x12\x1f\n\x0boperand_ids\x18$\x20\x03(\x03R\noperandIds\x126\n\x17cont\
    rol_predecessor_ids\x18%\x20\x03(\x03R\x15controlPredecessorIds\x124\n\
    \x16called_computation_ids\x18&\x20\x03(\x03R\x14calledComputationIds\
    \x12+\n\x08sharding\x18(\x20\x01(\x0b2\x0f.xla.OpShardingR\x08sharding\
    \x12%\n\x0ebackend_config\x18+\x20\x01(\tR\rbackendConfig\x128\n\x0erepl\
    ica_groups\x181\x20\x03(\x0b2\x11.xla.ReplicaGroupR\rreplicaGroups\x12&\
    \n\rall_reduce_id\x18-\x20\x01(\x03R\x0ballReduceIdB\x02\x18\x01\x12(\n\
    \x10is_host_transfer\x18/\x20\x01(\x08R\x0eisHostTransfer\x12\x1b\n\tis_\
    stable\x18<\x20\x01(\x08R\x08isStable\x12X\n\x19scatter_dimension_number\
    s\x180\x20\x01(\x0b2\x1c.xla.ScatterDimensionNumbersR\x17scatterDimensio\
    nNumbers\x12?\n\x10precision_config\x183\x20\x01(\x0b2\x14.xla.Precision\
    ConfigR\x0fprecisionConfig\x12A\n\x13source_target_pairs\x184\x20\x03(\
    \x0b2\x11.xla.SourceTargetR\x11sourceTargetPairs\x12C\n\x15domain_entry_\
    sharding\x186\x20\x01(\x0b2\x0f.xla.OpShardingR\x13domainEntrySharding\
    \x12A\n\x14domain_exit_sharding\x187\x20\x01(\x0b2\x0f.xla.OpShardingR\
    \x12domainExitSharding\x12)\n\x10constrain_layout\x188\x20\x01(\x08R\x0f\
    constrainLayout\x12L\n\x1aoperand_shapes_with_layout\x189\x20\x03(\x0b2\
    \x0f.xla.ShapeProtoR\x17operandShapesWithLayout\x12U\n\x18triangular_sol\
    ve_options\x18;\x20\x01(\x0b2\x1b.xla.TriangularSolveOptionsR\x16triangu\
    larSolveOptions\x12?\n\x10cholesky_options\x18>\x20\x01(\x0b2\x14.xla.Ch\
    oleskyOptionsR\x0fcholeskyOptions\x12N\n\x15parameter_replication\x18=\
    \x20\x01(\x0b2\x19.xla.ParameterReplicationR\x14parameterReplication\x12\
    <\n\x1aouter_dimension_partitions\x18@\x20\x03(\x03R\x18outerDimensionPa\
    rtitions\x12<\n\x1bcustom_call_has_side_effect\x18A\x20\x01(\x08R\x17cus\
    tomCallHasSideEffect\x12\x14\n\x05delta\x18B\x20\x01(\x03R\x05delta\x12,\
    \n\x12indices_are_sorted\x18C\x20\x01(\x08R\x10indicesAreSorted\x1aU\n\
    \x0fSliceDimensions\x12\x14\n\x05start\x18\x01\x20\x01(\x03R\x05start\
    \x12\x14\n\x05limit\x18\x02\x20\x01(\x03R\x05limit\x12\x16\n\x06stride\
    \x18\x03\x20\x01(\x03R\x06strideJ\x04\x08\n\x10\x0bJ\x04\x08\x0c\x10\rJ\
    \x04\x08\x04\x10\x05J\x04\x08\x05\x10\x06J\x04\x08\x06\x10\x07J\x04\x08,\
    \x10-J\x04\x085\x106J\x04\x08.\x10/R\x0eparameter_nameR\x1efused_instruc\
    tions_computationR\roperand_namesR\x19control_predecessor_namesR\x18call\
    ed_computation_namesR\x11replica_group_idsR\x12custom_call_opaqueR\x12al\
    l_reduce_barrier\"\xde\x01\n\x13HloComputationProto\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x12<\n\x0cinstructions\x18\x02\x20\x03(\x0b\
    2\x18.xla.HloInstructionProtoR\x0cinstructions\x12;\n\rprogram_shape\x18\
    \x04\x20\x01(\x0b2\x16.xla.ProgramShapeProtoR\x0cprogramShape\x12\x0e\n\
    \x02id\x18\x05\x20\x01(\x03R\x02id\x12\x17\n\x07root_id\x18\x06\x20\x01(\
    \x03R\x06rootIdJ\x04\x08\x03\x10\x04R\troot_name\"\xff\x01\n\x10HloSched\
    uleProto\x12B\n\tsequences\x18\x01\x20\x03(\x0b2$.xla.HloScheduleProto.S\
    equencesEntryR\tsequences\x1a>\n\x13InstructionSequence\x12'\n\x0finstru\
    ction_ids\x18\x01\x20\x03(\x03R\x0einstructionIds\x1ag\n\x0eSequencesEnt\
    ry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x12?\n\x05value\x18\x02\
    \x20\x01(\x0b2).xla.HloScheduleProto.InstructionSequenceR\x05value:\x028\
    \x01\"\xfb\x02\n\x18HloInputOutputAliasProto\x12G\n\x07entries\x18\x01\
    \x20\x03(\x0b2-.xla.HloInputOutputAliasProto.AliasEntryProtoR\x07entries\
    \x1a\xd6\x01\n\x0fAliasEntryProto\x12,\n\x12output_shape_index\x18\x01\
    \x20\x03(\x03R\x10outputShapeIndex\x12)\n\x10parameter_number\x18\x02\
    \x20\x01(\x03R\x0fparameterNumber\x122\n\x15parameter_shape_index\x18\
    \x03\x20\x03(\x03R\x13parameterShapeIndex\x126\n\x04kind\x18\x04\x20\x01\
    (\x0e2\".xla.HloInputOutputAliasProto.KindR\x04kind\"=\n\x04Kind\x12\x13\
    \n\x0fUNDEFINED_ALIAS\x10\0\x12\x0e\n\nUSER_ALIAS\x10\x01\x12\x10\n\x0cS\
    YSTEM_ALIAS\x10\x02\"\xd4\x02\n\x1cDynamicParameterBindingProto\x12C\n\
    \x07entries\x18\x01\x20\x03(\x0b2).xla.DynamicParameterBindingProto.Bind\
    ingR\x07entries\x1a\xee\x01\n\x07Binding\x12*\n\x11dynamic_param_num\x18\
    \x01\x20\x01(\x03R\x0fdynamicParamNum\x12.\n\x13dynamic_param_index\x18\
    \x02\x20\x03(\x03R\x11dynamicParamIndex\x12(\n\x10target_param_num\x18\
    \x03\x20\x01(\x03R\x0etargetParamNum\x12,\n\x12target_param_index\x18\
    \x04\x20\x03(\x03R\x10targetParamIndex\x12/\n\x14target_param_dim_num\
    \x18\x05\x20\x01(\x03R\x11targetParamDimNum\"\xff\x03\n\x0eHloModuleProt\
    o\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x124\n\x16entry_computat\
    ion_name\x18\x02\x20\x01(\tR\x14entryComputationName\x120\n\x14entry_com\
    putation_id\x18\x06\x20\x01(\x03R\x12entryComputationId\x12<\n\x0ccomput\
    ations\x18\x03\x20\x03(\x0b2\x18.xla.HloComputationProtoR\x0ccomputation\
    s\x12D\n\x12host_program_shape\x18\x04\x20\x01(\x0b2\x16.xla.ProgramShap\
    eProtoR\x10hostProgramShape\x12\x0e\n\x02id\x18\x05\x20\x01(\x03R\x02id\
    \x121\n\x08schedule\x18\x07\x20\x01(\x0b2\x15.xla.HloScheduleProtoR\x08s\
    chedule\x12K\n\x12input_output_alias\x18\x08\x20\x01(\x0b2\x1d.xla.HloIn\
    putOutputAliasProtoR\x10inputOutputAlias\x12]\n\x19dynamic_parameter_bin\
    ding\x18\t\x20\x01(\x0b2!.xla.DynamicParameterBindingProtoR\x17dynamicPa\
    rameterBinding\"\x93\x02\n\x12LogicalBufferProto\x12\x0e\n\x02id\x18\x01\
    \x20\x01(\x03R\x02id\x12\x12\n\x04size\x18\x02\x20\x01(\x03R\x04size\x12\
    ?\n\ndefined_at\x18\x03\x20\x01(\x0b2\x20.xla.LogicalBufferProto.Locatio\
    nR\tdefinedAt\x12\x14\n\x05color\x18\x04\x20\x01(\x03R\x05color\x1a\x81\
    \x01\n\x08Location\x12)\n\x10computation_name\x18\x01\x20\x01(\tR\x0fcom\
    putationName\x12)\n\x10instruction_name\x18\x02\x20\x01(\tR\x0finstructi\
    onName\x12\x1f\n\x0bshape_index\x18\x03\x20\x03(\x03R\nshapeIndex\"\xaa\
    \x04\n\x15BufferAllocationProto\x12\x14\n\x05index\x18\x01\x20\x01(\x03R\
    \x05index\x12\x12\n\x04size\x18\x02\x20\x01(\x03R\x04size\x12&\n\x0fis_t\
    hread_local\x18\x03\x20\x01(\x08R\risThreadLocal\x12\x19\n\x08is_tuple\
    \x18\x0b\x20\x01(\x08R\x07isTuple\x12C\n\x1eis_entry_computation_paramet\
    er\x18\x05\x20\x01(\x08R\x1bisEntryComputationParameter\x12\x1f\n\x0bis_\
    constant\x18\x0c\x20\x01(\x08R\nisConstant\x12)\n\x10parameter_number\
    \x18\x06\x20\x01(\x03R\x0fparameterNumber\x122\n\x15parameter_shape_inde\
    x\x18\n\x20\x03(\x03R\x13parameterShapeIndex\x12$\n\x0emaybe_live_out\
    \x18\x07\x20\x01(\x08R\x0cmaybeLiveOut\x12\x14\n\x05color\x18\x08\x20\
    \x01(\x03R\x05color\x12?\n\x08assigned\x18\t\x20\x03(\x0b2#.xla.BufferAl\
    locationProto.AssignedR\x08assigned\x1ab\n\x08Assigned\x12*\n\x11logical\
    _buffer_id\x18\x01\x20\x01(\x03R\x0flogicalBufferId\x12\x16\n\x06offset\
    \x18\x02\x20\x01(\x03R\x06offset\x12\x12\n\x04size\x18\x03\x20\x01(\x03R\
    \x04size\"\x9c\x03\n\x12HeapSimulatorTrace\x125\n\x06events\x18\x01\x20\
    \x03(\x0b2\x1d.xla.HeapSimulatorTrace.EventR\x06events\x126\n\x17whole_m\
    odule_simulation\x18\x02\x20\x01(\x08R\x15wholeModuleSimulation\x1a\x96\
    \x02\n\x05Event\x126\n\x04kind\x18\x01\x20\x01(\x0e2\".xla.HeapSimulator\
    Trace.Event.KindR\x04kind\x12\x1b\n\tbuffer_id\x18\x02\x20\x01(\x03R\x08\
    bufferId\x12)\n\x10computation_name\x18\x03\x20\x01(\tR\x0fcomputationNa\
    me\x12)\n\x10instruction_name\x18\x04\x20\x01(\tR\x0finstructionName\x12\
    5\n\x17share_with_canonical_id\x18\x05\x20\x01(\x03R\x14shareWithCanonic\
    alId\"+\n\x04Kind\x12\t\n\x05ALLOC\x10\0\x12\x08\n\x04FREE\x10\x01\x12\
    \x0e\n\nSHARE_WITH\x10\x02\"_\n\x13HloModuleGroupProto\x12\x12\n\x04name\
    \x18\x01\x20\x01(\tR\x04name\x124\n\x0bhlo_modules\x18\x02\x20\x03(\x0b2\
    \x13.xla.HloModuleProtoR\nhloModules\"\xb7\x03\n\x15BufferAssignmentProt\
    o\x12@\n\x0flogical_buffers\x18\x01\x20\x03(\x0b2\x17.xla.LogicalBufferP\
    rotoR\x0elogicalBuffers\x12M\n\x0ebuffer_aliases\x18\x02\x20\x03(\x0b2&.\
    xla.BufferAssignmentProto.BufferAliasR\rbufferAliases\x12I\n\x12buffer_a\
    llocations\x18\x03\x20\x03(\x0b2\x1a.xla.BufferAllocationProtoR\x11buffe\
    rAllocations\x12K\n\x15heap_simulator_traces\x18\x04\x20\x03(\x0b2\x17.x\
    la.HeapSimulatorTraceR\x13heapSimulatorTraces\x1au\n\x0bBufferAlias\x12(\
    \n\x10source_buffer_id\x18\x01\x20\x01(\x03R\x0esourceBufferId\x12<\n\
    \x08location\x18\x02\x20\x01(\x0b2\x20.xla.LogicalBufferProto.LocationR\
    \x08location\"\x9b\x01\n\x08HloProto\x122\n\nhlo_module\x18\x01\x20\x01(\
    \x0b2\x13.xla.HloModuleProtoR\thloModule\x12G\n\x11buffer_assignment\x18\
    \x03\x20\x01(\x0b2\x1a.xla.BufferAssignmentProtoR\x10bufferAssignmentJ\
    \x04\x08\x02\x10\x03R\x0chlo_ordering\"\xb9\x01\n\x0bHloSnapshot\x12\x1f\
    \n\x03hlo\x18\x01\x20\x01(\x0b2\r.xla.HloProtoR\x03hlo\x12/\n\targuments\
    \x18\x02\x20\x03(\x0b2\x11.xla.LiteralProtoR\targuments\x12)\n\x06result\
    \x18\x03\x20\x01(\x0b2\x11.xla.LiteralProtoR\x06result\x12-\n\x12executi\
    on_platform\x18\x04\x20\x01(\tR\x11executionPlatformB\x03\xf8\x01\x01b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
