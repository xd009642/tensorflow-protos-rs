// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/protobuf/eager_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct RemoteTensorHandle {
    // message fields
    pub op_id: i64,
    pub output_num: i32,
    pub device: ::std::string::String,
    pub op_device: ::std::string::String,
    pub dtype: super::types::DataType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RemoteTensorHandle {
    fn default() -> &'a RemoteTensorHandle {
        <RemoteTensorHandle as ::protobuf::Message>::default_instance()
    }
}

impl RemoteTensorHandle {
    pub fn new() -> RemoteTensorHandle {
        ::std::default::Default::default()
    }

    // int64 op_id = 1;


    pub fn get_op_id(&self) -> i64 {
        self.op_id
    }
    pub fn clear_op_id(&mut self) {
        self.op_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_op_id(&mut self, v: i64) {
        self.op_id = v;
    }

    // int32 output_num = 2;


    pub fn get_output_num(&self) -> i32 {
        self.output_num
    }
    pub fn clear_output_num(&mut self) {
        self.output_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_num(&mut self, v: i32) {
        self.output_num = v;
    }

    // string device = 3;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // string op_device = 4;


    pub fn get_op_device(&self) -> &str {
        &self.op_device
    }
    pub fn clear_op_device(&mut self) {
        self.op_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_device(&mut self, v: ::std::string::String) {
        self.op_device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_device(&mut self) -> &mut ::std::string::String {
        &mut self.op_device
    }

    // Take field
    pub fn take_op_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op_device, ::std::string::String::new())
    }

    // .tensorflow.DataType dtype = 5;


    pub fn get_dtype(&self) -> super::types::DataType {
        self.dtype
    }
    pub fn clear_dtype(&mut self) {
        self.dtype = super::types::DataType::DT_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_dtype(&mut self, v: super::types::DataType) {
        self.dtype = v;
    }
}

impl ::protobuf::Message for RemoteTensorHandle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.op_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.output_num = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op_device)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dtype, 5, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.op_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output_num != 0 {
            my_size += ::protobuf::rt::value_size(2, self.output_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device);
        }
        if !self.op_device.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.op_device);
        }
        if self.dtype != super::types::DataType::DT_INVALID {
            my_size += ::protobuf::rt::enum_size(5, self.dtype);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.op_id != 0 {
            os.write_int64(1, self.op_id)?;
        }
        if self.output_num != 0 {
            os.write_int32(2, self.output_num)?;
        }
        if !self.device.is_empty() {
            os.write_string(3, &self.device)?;
        }
        if !self.op_device.is_empty() {
            os.write_string(4, &self.op_device)?;
        }
        if self.dtype != super::types::DataType::DT_INVALID {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.dtype))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RemoteTensorHandle {
        RemoteTensorHandle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "op_id",
                |m: &RemoteTensorHandle| { &m.op_id },
                |m: &mut RemoteTensorHandle| { &mut m.op_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "output_num",
                |m: &RemoteTensorHandle| { &m.output_num },
                |m: &mut RemoteTensorHandle| { &mut m.output_num },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &RemoteTensorHandle| { &m.device },
                |m: &mut RemoteTensorHandle| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op_device",
                |m: &RemoteTensorHandle| { &m.op_device },
                |m: &mut RemoteTensorHandle| { &mut m.op_device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::types::DataType>>(
                "dtype",
                |m: &RemoteTensorHandle| { &m.dtype },
                |m: &mut RemoteTensorHandle| { &mut m.dtype },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RemoteTensorHandle>(
                "RemoteTensorHandle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RemoteTensorHandle {
        static instance: ::protobuf::rt::LazyV2<RemoteTensorHandle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RemoteTensorHandle::new)
    }
}

impl ::protobuf::Clear for RemoteTensorHandle {
    fn clear(&mut self) {
        self.op_id = 0;
        self.output_num = 0;
        self.device.clear();
        self.op_device.clear();
        self.dtype = super::types::DataType::DT_INVALID;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RemoteTensorHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RemoteTensorHandle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Operation {
    // message fields
    pub id: i64,
    pub name: ::std::string::String,
    pub inputs: ::protobuf::RepeatedField<RemoteTensorHandle>,
    pub control_op_ids: ::std::vec::Vec<i64>,
    pub attrs: ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue>,
    pub device: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Operation {
    fn default() -> &'a Operation {
        <Operation as ::protobuf::Message>::default_instance()
    }
}

impl Operation {
    pub fn new() -> Operation {
        ::std::default::Default::default()
    }

    // int64 id = 1;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // string name = 2;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // repeated .tensorflow.eager.RemoteTensorHandle inputs = 3;


    pub fn get_inputs(&self) -> &[RemoteTensorHandle] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<RemoteTensorHandle>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<RemoteTensorHandle> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<RemoteTensorHandle> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // repeated int64 control_op_ids = 4;


    pub fn get_control_op_ids(&self) -> &[i64] {
        &self.control_op_ids
    }
    pub fn clear_control_op_ids(&mut self) {
        self.control_op_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_control_op_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.control_op_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_control_op_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.control_op_ids
    }

    // Take field
    pub fn take_control_op_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.control_op_ids, ::std::vec::Vec::new())
    }

    // repeated .tensorflow.eager.Operation.AttrsEntry attrs = 5;


    pub fn get_attrs(&self) -> &::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        &self.attrs
    }
    pub fn clear_attrs(&mut self) {
        self.attrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_attrs(&mut self, v: ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue>) {
        self.attrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attrs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        &mut self.attrs
    }

    // Take field
    pub fn take_attrs(&mut self) -> ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        ::std::mem::replace(&mut self.attrs, ::std::collections::HashMap::new())
    }

    // string device = 6;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Operation {
    fn is_initialized(&self) -> bool {
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.control_op_ids)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(wire_type, is, &mut self.attrs)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.control_op_ids {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(5, &self.attrs);
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.device);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.id != 0 {
            os.write_int64(1, self.id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        for v in &self.inputs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.control_op_ids {
            os.write_int64(4, *v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(5, &self.attrs, os)?;
        if !self.device.is_empty() {
            os.write_string(6, &self.device)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Operation {
        Operation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &Operation| { &m.id },
                |m: &mut Operation| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Operation| { &m.name },
                |m: &mut Operation| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RemoteTensorHandle>>(
                "inputs",
                |m: &Operation| { &m.inputs },
                |m: &mut Operation| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "control_op_ids",
                |m: &Operation| { &m.control_op_ids },
                |m: &mut Operation| { &mut m.control_op_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(
                "attrs",
                |m: &Operation| { &m.attrs },
                |m: &mut Operation| { &mut m.attrs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &Operation| { &m.device },
                |m: &mut Operation| { &mut m.device },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Operation>(
                "Operation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Operation {
        static instance: ::protobuf::rt::LazyV2<Operation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Operation::new)
    }
}

impl ::protobuf::Clear for Operation {
    fn clear(&mut self) {
        self.id = 0;
        self.name.clear();
        self.inputs.clear();
        self.control_op_ids.clear();
        self.attrs.clear();
        self.device.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueueItem {
    // message oneof groups
    pub item: ::std::option::Option<QueueItem_oneof_item>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueItem {
    fn default() -> &'a QueueItem {
        <QueueItem as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum QueueItem_oneof_item {
    handle_to_decref(RemoteTensorHandle),
    operation(Operation),
    send_tensor(SendTensorOp),
}

impl QueueItem {
    pub fn new() -> QueueItem {
        ::std::default::Default::default()
    }

    // .tensorflow.eager.RemoteTensorHandle handle_to_decref = 1;


    pub fn get_handle_to_decref(&self) -> &RemoteTensorHandle {
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(ref v)) => v,
            _ => <RemoteTensorHandle as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_handle_to_decref(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_handle_to_decref(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_handle_to_decref(&mut self, v: RemoteTensorHandle) {
        self.item = ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(v))
    }

    // Mutable pointer to the field.
    pub fn mut_handle_to_decref(&mut self) -> &mut RemoteTensorHandle {
        if let ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(RemoteTensorHandle::new()));
        }
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_handle_to_decref(&mut self) -> RemoteTensorHandle {
        if self.has_handle_to_decref() {
            match self.item.take() {
                ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(v)) => v,
                _ => panic!(),
            }
        } else {
            RemoteTensorHandle::new()
        }
    }

    // .tensorflow.eager.Operation operation = 2;


    pub fn get_operation(&self) -> &Operation {
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::operation(ref v)) => v,
            _ => <Operation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_operation(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_operation(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::operation(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: Operation) {
        self.item = ::std::option::Option::Some(QueueItem_oneof_item::operation(v))
    }

    // Mutable pointer to the field.
    pub fn mut_operation(&mut self) -> &mut Operation {
        if let ::std::option::Option::Some(QueueItem_oneof_item::operation(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(QueueItem_oneof_item::operation(Operation::new()));
        }
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::operation(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_operation(&mut self) -> Operation {
        if self.has_operation() {
            match self.item.take() {
                ::std::option::Option::Some(QueueItem_oneof_item::operation(v)) => v,
                _ => panic!(),
            }
        } else {
            Operation::new()
        }
    }

    // .tensorflow.eager.SendTensorOp send_tensor = 3;


    pub fn get_send_tensor(&self) -> &SendTensorOp {
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(ref v)) => v,
            _ => <SendTensorOp as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_send_tensor(&mut self) {
        self.item = ::std::option::Option::None;
    }

    pub fn has_send_tensor(&self) -> bool {
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_send_tensor(&mut self, v: SendTensorOp) {
        self.item = ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_send_tensor(&mut self) -> &mut SendTensorOp {
        if let ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(_)) = self.item {
        } else {
            self.item = ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(SendTensorOp::new()));
        }
        match self.item {
            ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_send_tensor(&mut self) -> SendTensorOp {
        if self.has_send_tensor() {
            match self.item.take() {
                ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(v)) => v,
                _ => panic!(),
            }
        } else {
            SendTensorOp::new()
        }
    }
}

impl ::protobuf::Message for QueueItem {
    fn is_initialized(&self) -> bool {
        if let Some(QueueItem_oneof_item::handle_to_decref(ref v)) = self.item {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueueItem_oneof_item::operation(ref v)) = self.item {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(QueueItem_oneof_item::send_tensor(ref v)) = self.item {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.item = ::std::option::Option::Some(QueueItem_oneof_item::handle_to_decref(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.item = ::std::option::Option::Some(QueueItem_oneof_item::operation(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.item = ::std::option::Option::Some(QueueItem_oneof_item::send_tensor(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.item {
            match v {
                &QueueItem_oneof_item::handle_to_decref(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueueItem_oneof_item::operation(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &QueueItem_oneof_item::send_tensor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.item {
            match v {
                &QueueItem_oneof_item::handle_to_decref(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueueItem_oneof_item::operation(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &QueueItem_oneof_item::send_tensor(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueItem {
        QueueItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RemoteTensorHandle>(
                "handle_to_decref",
                QueueItem::has_handle_to_decref,
                QueueItem::get_handle_to_decref,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Operation>(
                "operation",
                QueueItem::has_operation,
                QueueItem::get_operation,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SendTensorOp>(
                "send_tensor",
                QueueItem::has_send_tensor,
                QueueItem::get_send_tensor,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueItem>(
                "QueueItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueueItem {
        static instance: ::protobuf::rt::LazyV2<QueueItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueItem::new)
    }
}

impl ::protobuf::Clear for QueueItem {
    fn clear(&mut self) {
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.item = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QueueResponse {
    // message fields
    pub shape: ::protobuf::RepeatedField<super::tensor_shape::TensorShapeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QueueResponse {
    fn default() -> &'a QueueResponse {
        <QueueResponse as ::protobuf::Message>::default_instance()
    }
}

impl QueueResponse {
    pub fn new() -> QueueResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.TensorShapeProto shape = 1;


    pub fn get_shape(&self) -> &[super::tensor_shape::TensorShapeProto] {
        &self.shape
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: ::protobuf::RepeatedField<super::tensor_shape::TensorShapeProto>) {
        self.shape = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shape(&mut self) -> &mut ::protobuf::RepeatedField<super::tensor_shape::TensorShapeProto> {
        &mut self.shape
    }

    // Take field
    pub fn take_shape(&mut self) -> ::protobuf::RepeatedField<super::tensor_shape::TensorShapeProto> {
        ::std::mem::replace(&mut self.shape, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for QueueResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.shape)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.shape {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.shape {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QueueResponse {
        QueueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor_shape::TensorShapeProto>>(
                "shape",
                |m: &QueueResponse| { &m.shape },
                |m: &mut QueueResponse| { &mut m.shape },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QueueResponse>(
                "QueueResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QueueResponse {
        static instance: ::protobuf::rt::LazyV2<QueueResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QueueResponse::new)
    }
}

impl ::protobuf::Clear for QueueResponse {
    fn clear(&mut self) {
        self.shape.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QueueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QueueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateContextRequest {
    // message fields
    pub server_def: ::protobuf::SingularPtrField<super::tensorflow_server::ServerDef>,
    pub field_async: bool,
    pub keep_alive_secs: i64,
    pub version_def: ::protobuf::SingularPtrField<super::versions::VersionDef>,
    pub cluster_device_attributes: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>,
    pub context_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContextRequest {
    fn default() -> &'a CreateContextRequest {
        <CreateContextRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateContextRequest {
    pub fn new() -> CreateContextRequest {
        ::std::default::Default::default()
    }

    // .tensorflow.ServerDef server_def = 1;


    pub fn get_server_def(&self) -> &super::tensorflow_server::ServerDef {
        self.server_def.as_ref().unwrap_or_else(|| <super::tensorflow_server::ServerDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_def(&mut self) {
        self.server_def.clear();
    }

    pub fn has_server_def(&self) -> bool {
        self.server_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_def(&mut self, v: super::tensorflow_server::ServerDef) {
        self.server_def = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_def(&mut self) -> &mut super::tensorflow_server::ServerDef {
        if self.server_def.is_none() {
            self.server_def.set_default();
        }
        self.server_def.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_def(&mut self) -> super::tensorflow_server::ServerDef {
        self.server_def.take().unwrap_or_else(|| super::tensorflow_server::ServerDef::new())
    }

    // bool async = 2;


    pub fn get_field_async(&self) -> bool {
        self.field_async
    }
    pub fn clear_field_async(&mut self) {
        self.field_async = false;
    }

    // Param is passed by value, moved
    pub fn set_field_async(&mut self, v: bool) {
        self.field_async = v;
    }

    // int64 keep_alive_secs = 3;


    pub fn get_keep_alive_secs(&self) -> i64 {
        self.keep_alive_secs
    }
    pub fn clear_keep_alive_secs(&mut self) {
        self.keep_alive_secs = 0;
    }

    // Param is passed by value, moved
    pub fn set_keep_alive_secs(&mut self, v: i64) {
        self.keep_alive_secs = v;
    }

    // .tensorflow.VersionDef version_def = 4;


    pub fn get_version_def(&self) -> &super::versions::VersionDef {
        self.version_def.as_ref().unwrap_or_else(|| <super::versions::VersionDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_version_def(&mut self) {
        self.version_def.clear();
    }

    pub fn has_version_def(&self) -> bool {
        self.version_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version_def(&mut self, v: super::versions::VersionDef) {
        self.version_def = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version_def(&mut self) -> &mut super::versions::VersionDef {
        if self.version_def.is_none() {
            self.version_def.set_default();
        }
        self.version_def.as_mut().unwrap()
    }

    // Take field
    pub fn take_version_def(&mut self) -> super::versions::VersionDef {
        self.version_def.take().unwrap_or_else(|| super::versions::VersionDef::new())
    }

    // repeated .tensorflow.DeviceAttributes cluster_device_attributes = 6;


    pub fn get_cluster_device_attributes(&self) -> &[super::device_attributes::DeviceAttributes] {
        &self.cluster_device_attributes
    }
    pub fn clear_cluster_device_attributes(&mut self) {
        self.cluster_device_attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_device_attributes(&mut self, v: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>) {
        self.cluster_device_attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_device_attributes(&mut self) -> &mut ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        &mut self.cluster_device_attributes
    }

    // Take field
    pub fn take_cluster_device_attributes(&mut self) -> ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        ::std::mem::replace(&mut self.cluster_device_attributes, ::protobuf::RepeatedField::new())
    }

    // fixed64 context_id = 7;


    pub fn get_context_id(&self) -> u64 {
        self.context_id
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = v;
    }
}

impl ::protobuf::Message for CreateContextRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.server_def {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.version_def {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cluster_device_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_def)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.field_async = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.keep_alive_secs = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.version_def)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cluster_device_attributes)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.context_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server_def.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.field_async != false {
            my_size += 2;
        }
        if self.keep_alive_secs != 0 {
            my_size += ::protobuf::rt::value_size(3, self.keep_alive_secs, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.version_def.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.cluster_device_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.context_id != 0 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server_def.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.field_async != false {
            os.write_bool(2, self.field_async)?;
        }
        if self.keep_alive_secs != 0 {
            os.write_int64(3, self.keep_alive_secs)?;
        }
        if let Some(ref v) = self.version_def.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.cluster_device_attributes {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.context_id != 0 {
            os.write_fixed64(7, self.context_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContextRequest {
        CreateContextRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensorflow_server::ServerDef>>(
                "server_def",
                |m: &CreateContextRequest| { &m.server_def },
                |m: &mut CreateContextRequest| { &mut m.server_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "async",
                |m: &CreateContextRequest| { &m.field_async },
                |m: &mut CreateContextRequest| { &mut m.field_async },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "keep_alive_secs",
                |m: &CreateContextRequest| { &m.keep_alive_secs },
                |m: &mut CreateContextRequest| { &mut m.keep_alive_secs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::versions::VersionDef>>(
                "version_def",
                |m: &CreateContextRequest| { &m.version_def },
                |m: &mut CreateContextRequest| { &mut m.version_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceAttributes>>(
                "cluster_device_attributes",
                |m: &CreateContextRequest| { &m.cluster_device_attributes },
                |m: &mut CreateContextRequest| { &mut m.cluster_device_attributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "context_id",
                |m: &CreateContextRequest| { &m.context_id },
                |m: &mut CreateContextRequest| { &mut m.context_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateContextRequest>(
                "CreateContextRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateContextRequest {
        static instance: ::protobuf::rt::LazyV2<CreateContextRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateContextRequest::new)
    }
}

impl ::protobuf::Clear for CreateContextRequest {
    fn clear(&mut self) {
        self.server_def.clear();
        self.field_async = false;
        self.keep_alive_secs = 0;
        self.version_def.clear();
        self.cluster_device_attributes.clear();
        self.context_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContextRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContextRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateContextResponse {
    // message fields
    pub device_attributes: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateContextResponse {
    fn default() -> &'a CreateContextResponse {
        <CreateContextResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateContextResponse {
    pub fn new() -> CreateContextResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.DeviceAttributes device_attributes = 2;


    pub fn get_device_attributes(&self) -> &[super::device_attributes::DeviceAttributes] {
        &self.device_attributes
    }
    pub fn clear_device_attributes(&mut self) {
        self.device_attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_attributes(&mut self, v: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>) {
        self.device_attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_attributes(&mut self) -> &mut ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        &mut self.device_attributes
    }

    // Take field
    pub fn take_device_attributes(&mut self) -> ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        ::std::mem::replace(&mut self.device_attributes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CreateContextResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.device_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.device_attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.device_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.device_attributes {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateContextResponse {
        CreateContextResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceAttributes>>(
                "device_attributes",
                |m: &CreateContextResponse| { &m.device_attributes },
                |m: &mut CreateContextResponse| { &mut m.device_attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateContextResponse>(
                "CreateContextResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateContextResponse {
        static instance: ::protobuf::rt::LazyV2<CreateContextResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateContextResponse::new)
    }
}

impl ::protobuf::Clear for CreateContextResponse {
    fn clear(&mut self) {
        self.device_attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateContextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateContextResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnqueueRequest {
    // message fields
    pub context_id: u64,
    pub queue: ::protobuf::RepeatedField<QueueItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnqueueRequest {
    fn default() -> &'a EnqueueRequest {
        <EnqueueRequest as ::protobuf::Message>::default_instance()
    }
}

impl EnqueueRequest {
    pub fn new() -> EnqueueRequest {
        ::std::default::Default::default()
    }

    // fixed64 context_id = 1;


    pub fn get_context_id(&self) -> u64 {
        self.context_id
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = v;
    }

    // repeated .tensorflow.eager.QueueItem queue = 3;


    pub fn get_queue(&self) -> &[QueueItem] {
        &self.queue
    }
    pub fn clear_queue(&mut self) {
        self.queue.clear();
    }

    // Param is passed by value, moved
    pub fn set_queue(&mut self, v: ::protobuf::RepeatedField<QueueItem>) {
        self.queue = v;
    }

    // Mutable pointer to the field.
    pub fn mut_queue(&mut self) -> &mut ::protobuf::RepeatedField<QueueItem> {
        &mut self.queue
    }

    // Take field
    pub fn take_queue(&mut self) -> ::protobuf::RepeatedField<QueueItem> {
        ::std::mem::replace(&mut self.queue, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EnqueueRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.queue {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.context_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.queue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.context_id != 0 {
            my_size += 9;
        }
        for value in &self.queue {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.context_id != 0 {
            os.write_fixed64(1, self.context_id)?;
        }
        for v in &self.queue {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnqueueRequest {
        EnqueueRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "context_id",
                |m: &EnqueueRequest| { &m.context_id },
                |m: &mut EnqueueRequest| { &mut m.context_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueueItem>>(
                "queue",
                |m: &EnqueueRequest| { &m.queue },
                |m: &mut EnqueueRequest| { &mut m.queue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnqueueRequest>(
                "EnqueueRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnqueueRequest {
        static instance: ::protobuf::rt::LazyV2<EnqueueRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnqueueRequest::new)
    }
}

impl ::protobuf::Clear for EnqueueRequest {
    fn clear(&mut self) {
        self.context_id = 0;
        self.queue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnqueueRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnqueueRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnqueueResponse {
    // message fields
    pub queue_response: ::protobuf::RepeatedField<QueueResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnqueueResponse {
    fn default() -> &'a EnqueueResponse {
        <EnqueueResponse as ::protobuf::Message>::default_instance()
    }
}

impl EnqueueResponse {
    pub fn new() -> EnqueueResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.eager.QueueResponse queue_response = 1;


    pub fn get_queue_response(&self) -> &[QueueResponse] {
        &self.queue_response
    }
    pub fn clear_queue_response(&mut self) {
        self.queue_response.clear();
    }

    // Param is passed by value, moved
    pub fn set_queue_response(&mut self, v: ::protobuf::RepeatedField<QueueResponse>) {
        self.queue_response = v;
    }

    // Mutable pointer to the field.
    pub fn mut_queue_response(&mut self) -> &mut ::protobuf::RepeatedField<QueueResponse> {
        &mut self.queue_response
    }

    // Take field
    pub fn take_queue_response(&mut self) -> ::protobuf::RepeatedField<QueueResponse> {
        ::std::mem::replace(&mut self.queue_response, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EnqueueResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.queue_response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.queue_response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.queue_response {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.queue_response {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnqueueResponse {
        EnqueueResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QueueResponse>>(
                "queue_response",
                |m: &EnqueueResponse| { &m.queue_response },
                |m: &mut EnqueueResponse| { &mut m.queue_response },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnqueueResponse>(
                "EnqueueResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnqueueResponse {
        static instance: ::protobuf::rt::LazyV2<EnqueueResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnqueueResponse::new)
    }
}

impl ::protobuf::Clear for EnqueueResponse {
    fn clear(&mut self) {
        self.queue_response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnqueueResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnqueueResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitQueueDoneRequest {
    // message fields
    pub context_id: u64,
    pub op_id: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitQueueDoneRequest {
    fn default() -> &'a WaitQueueDoneRequest {
        <WaitQueueDoneRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitQueueDoneRequest {
    pub fn new() -> WaitQueueDoneRequest {
        ::std::default::Default::default()
    }

    // fixed64 context_id = 1;


    pub fn get_context_id(&self) -> u64 {
        self.context_id
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = v;
    }

    // repeated int64 op_id = 2;


    pub fn get_op_id(&self) -> &[i64] {
        &self.op_id
    }
    pub fn clear_op_id(&mut self) {
        self.op_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_id(&mut self, v: ::std::vec::Vec<i64>) {
        self.op_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_op_id(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.op_id
    }

    // Take field
    pub fn take_op_id(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.op_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for WaitQueueDoneRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.context_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.op_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.context_id != 0 {
            my_size += 9;
        }
        for value in &self.op_id {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.context_id != 0 {
            os.write_fixed64(1, self.context_id)?;
        }
        for v in &self.op_id {
            os.write_int64(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitQueueDoneRequest {
        WaitQueueDoneRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "context_id",
                |m: &WaitQueueDoneRequest| { &m.context_id },
                |m: &mut WaitQueueDoneRequest| { &mut m.context_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "op_id",
                |m: &WaitQueueDoneRequest| { &m.op_id },
                |m: &mut WaitQueueDoneRequest| { &mut m.op_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitQueueDoneRequest>(
                "WaitQueueDoneRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WaitQueueDoneRequest {
        static instance: ::protobuf::rt::LazyV2<WaitQueueDoneRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WaitQueueDoneRequest::new)
    }
}

impl ::protobuf::Clear for WaitQueueDoneRequest {
    fn clear(&mut self) {
        self.context_id = 0;
        self.op_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitQueueDoneRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitQueueDoneRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitQueueDoneResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitQueueDoneResponse {
    fn default() -> &'a WaitQueueDoneResponse {
        <WaitQueueDoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl WaitQueueDoneResponse {
    pub fn new() -> WaitQueueDoneResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for WaitQueueDoneResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitQueueDoneResponse {
        WaitQueueDoneResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitQueueDoneResponse>(
                "WaitQueueDoneResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WaitQueueDoneResponse {
        static instance: ::protobuf::rt::LazyV2<WaitQueueDoneResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WaitQueueDoneResponse::new)
    }
}

impl ::protobuf::Clear for WaitQueueDoneResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitQueueDoneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitQueueDoneResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeepAliveRequest {
    // message fields
    pub context_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeepAliveRequest {
    fn default() -> &'a KeepAliveRequest {
        <KeepAliveRequest as ::protobuf::Message>::default_instance()
    }
}

impl KeepAliveRequest {
    pub fn new() -> KeepAliveRequest {
        ::std::default::Default::default()
    }

    // fixed64 context_id = 1;


    pub fn get_context_id(&self) -> u64 {
        self.context_id
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = v;
    }
}

impl ::protobuf::Message for KeepAliveRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.context_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.context_id != 0 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.context_id != 0 {
            os.write_fixed64(1, self.context_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeepAliveRequest {
        KeepAliveRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "context_id",
                |m: &KeepAliveRequest| { &m.context_id },
                |m: &mut KeepAliveRequest| { &mut m.context_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeepAliveRequest>(
                "KeepAliveRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeepAliveRequest {
        static instance: ::protobuf::rt::LazyV2<KeepAliveRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeepAliveRequest::new)
    }
}

impl ::protobuf::Clear for KeepAliveRequest {
    fn clear(&mut self) {
        self.context_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeepAliveRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeepAliveRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeepAliveResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeepAliveResponse {
    fn default() -> &'a KeepAliveResponse {
        <KeepAliveResponse as ::protobuf::Message>::default_instance()
    }
}

impl KeepAliveResponse {
    pub fn new() -> KeepAliveResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for KeepAliveResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeepAliveResponse {
        KeepAliveResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeepAliveResponse>(
                "KeepAliveResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeepAliveResponse {
        static instance: ::protobuf::rt::LazyV2<KeepAliveResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeepAliveResponse::new)
    }
}

impl ::protobuf::Clear for KeepAliveResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeepAliveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeepAliveResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseContextRequest {
    // message fields
    pub context_id: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseContextRequest {
    fn default() -> &'a CloseContextRequest {
        <CloseContextRequest as ::protobuf::Message>::default_instance()
    }
}

impl CloseContextRequest {
    pub fn new() -> CloseContextRequest {
        ::std::default::Default::default()
    }

    // fixed64 context_id = 1;


    pub fn get_context_id(&self) -> u64 {
        self.context_id
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = v;
    }
}

impl ::protobuf::Message for CloseContextRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.context_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.context_id != 0 {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.context_id != 0 {
            os.write_fixed64(1, self.context_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseContextRequest {
        CloseContextRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "context_id",
                |m: &CloseContextRequest| { &m.context_id },
                |m: &mut CloseContextRequest| { &mut m.context_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloseContextRequest>(
                "CloseContextRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloseContextRequest {
        static instance: ::protobuf::rt::LazyV2<CloseContextRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloseContextRequest::new)
    }
}

impl ::protobuf::Clear for CloseContextRequest {
    fn clear(&mut self) {
        self.context_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseContextRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseContextRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloseContextResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloseContextResponse {
    fn default() -> &'a CloseContextResponse {
        <CloseContextResponse as ::protobuf::Message>::default_instance()
    }
}

impl CloseContextResponse {
    pub fn new() -> CloseContextResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CloseContextResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloseContextResponse {
        CloseContextResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloseContextResponse>(
                "CloseContextResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloseContextResponse {
        static instance: ::protobuf::rt::LazyV2<CloseContextResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloseContextResponse::new)
    }
}

impl ::protobuf::Clear for CloseContextResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloseContextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloseContextResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterFunctionRequest {
    // message fields
    pub context_id: u64,
    pub function_def: ::protobuf::SingularPtrField<super::function::FunctionDef>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterFunctionRequest {
    fn default() -> &'a RegisterFunctionRequest {
        <RegisterFunctionRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterFunctionRequest {
    pub fn new() -> RegisterFunctionRequest {
        ::std::default::Default::default()
    }

    // fixed64 context_id = 1;


    pub fn get_context_id(&self) -> u64 {
        self.context_id
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = v;
    }

    // .tensorflow.FunctionDef function_def = 2;


    pub fn get_function_def(&self) -> &super::function::FunctionDef {
        self.function_def.as_ref().unwrap_or_else(|| <super::function::FunctionDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_function_def(&mut self) {
        self.function_def.clear();
    }

    pub fn has_function_def(&self) -> bool {
        self.function_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_function_def(&mut self, v: super::function::FunctionDef) {
        self.function_def = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function_def(&mut self) -> &mut super::function::FunctionDef {
        if self.function_def.is_none() {
            self.function_def.set_default();
        }
        self.function_def.as_mut().unwrap()
    }

    // Take field
    pub fn take_function_def(&mut self) -> super::function::FunctionDef {
        self.function_def.take().unwrap_or_else(|| super::function::FunctionDef::new())
    }
}

impl ::protobuf::Message for RegisterFunctionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.function_def {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.context_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.function_def)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.context_id != 0 {
            my_size += 9;
        }
        if let Some(ref v) = self.function_def.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.context_id != 0 {
            os.write_fixed64(1, self.context_id)?;
        }
        if let Some(ref v) = self.function_def.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterFunctionRequest {
        RegisterFunctionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "context_id",
                |m: &RegisterFunctionRequest| { &m.context_id },
                |m: &mut RegisterFunctionRequest| { &mut m.context_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::function::FunctionDef>>(
                "function_def",
                |m: &RegisterFunctionRequest| { &m.function_def },
                |m: &mut RegisterFunctionRequest| { &mut m.function_def },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterFunctionRequest>(
                "RegisterFunctionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterFunctionRequest {
        static instance: ::protobuf::rt::LazyV2<RegisterFunctionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterFunctionRequest::new)
    }
}

impl ::protobuf::Clear for RegisterFunctionRequest {
    fn clear(&mut self) {
        self.context_id = 0;
        self.function_def.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterFunctionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterFunctionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterFunctionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterFunctionResponse {
    fn default() -> &'a RegisterFunctionResponse {
        <RegisterFunctionResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterFunctionResponse {
    pub fn new() -> RegisterFunctionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for RegisterFunctionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterFunctionResponse {
        RegisterFunctionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterFunctionResponse>(
                "RegisterFunctionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterFunctionResponse {
        static instance: ::protobuf::rt::LazyV2<RegisterFunctionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterFunctionResponse::new)
    }
}

impl ::protobuf::Clear for RegisterFunctionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterFunctionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterFunctionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendTensorOp {
    // message fields
    pub op_id: i64,
    pub tensors: ::protobuf::RepeatedField<super::tensor::TensorProto>,
    pub device_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendTensorOp {
    fn default() -> &'a SendTensorOp {
        <SendTensorOp as ::protobuf::Message>::default_instance()
    }
}

impl SendTensorOp {
    pub fn new() -> SendTensorOp {
        ::std::default::Default::default()
    }

    // int64 op_id = 1;


    pub fn get_op_id(&self) -> i64 {
        self.op_id
    }
    pub fn clear_op_id(&mut self) {
        self.op_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_op_id(&mut self, v: i64) {
        self.op_id = v;
    }

    // repeated .tensorflow.TensorProto tensors = 2;


    pub fn get_tensors(&self) -> &[super::tensor::TensorProto] {
        &self.tensors
    }
    pub fn clear_tensors(&mut self) {
        self.tensors.clear();
    }

    // Param is passed by value, moved
    pub fn set_tensors(&mut self, v: ::protobuf::RepeatedField<super::tensor::TensorProto>) {
        self.tensors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tensors(&mut self) -> &mut ::protobuf::RepeatedField<super::tensor::TensorProto> {
        &mut self.tensors
    }

    // Take field
    pub fn take_tensors(&mut self) -> ::protobuf::RepeatedField<super::tensor::TensorProto> {
        ::std::mem::replace(&mut self.tensors, ::protobuf::RepeatedField::new())
    }

    // string device_name = 3;


    pub fn get_device_name(&self) -> &str {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendTensorOp {
    fn is_initialized(&self) -> bool {
        for v in &self.tensors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.op_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tensors)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.op_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.op_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.device_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.op_id != 0 {
            os.write_int64(1, self.op_id)?;
        }
        for v in &self.tensors {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.device_name.is_empty() {
            os.write_string(3, &self.device_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendTensorOp {
        SendTensorOp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "op_id",
                |m: &SendTensorOp| { &m.op_id },
                |m: &mut SendTensorOp| { &mut m.op_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor::TensorProto>>(
                "tensors",
                |m: &SendTensorOp| { &m.tensors },
                |m: &mut SendTensorOp| { &mut m.tensors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &SendTensorOp| { &m.device_name },
                |m: &mut SendTensorOp| { &mut m.device_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendTensorOp>(
                "SendTensorOp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendTensorOp {
        static instance: ::protobuf::rt::LazyV2<SendTensorOp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendTensorOp::new)
    }
}

impl ::protobuf::Clear for SendTensorOp {
    fn clear(&mut self) {
        self.op_id = 0;
        self.tensors.clear();
        self.device_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendTensorOp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendTensorOp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendTensorRequest {
    // message fields
    pub context_id: u64,
    pub op_id: i64,
    pub tensors: ::protobuf::RepeatedField<super::tensor::TensorProto>,
    pub device_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendTensorRequest {
    fn default() -> &'a SendTensorRequest {
        <SendTensorRequest as ::protobuf::Message>::default_instance()
    }
}

impl SendTensorRequest {
    pub fn new() -> SendTensorRequest {
        ::std::default::Default::default()
    }

    // fixed64 context_id = 1;


    pub fn get_context_id(&self) -> u64 {
        self.context_id
    }
    pub fn clear_context_id(&mut self) {
        self.context_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_context_id(&mut self, v: u64) {
        self.context_id = v;
    }

    // int64 op_id = 2;


    pub fn get_op_id(&self) -> i64 {
        self.op_id
    }
    pub fn clear_op_id(&mut self) {
        self.op_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_op_id(&mut self, v: i64) {
        self.op_id = v;
    }

    // repeated .tensorflow.TensorProto tensors = 3;


    pub fn get_tensors(&self) -> &[super::tensor::TensorProto] {
        &self.tensors
    }
    pub fn clear_tensors(&mut self) {
        self.tensors.clear();
    }

    // Param is passed by value, moved
    pub fn set_tensors(&mut self, v: ::protobuf::RepeatedField<super::tensor::TensorProto>) {
        self.tensors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tensors(&mut self) -> &mut ::protobuf::RepeatedField<super::tensor::TensorProto> {
        &mut self.tensors
    }

    // Take field
    pub fn take_tensors(&mut self) -> ::protobuf::RepeatedField<super::tensor::TensorProto> {
        ::std::mem::replace(&mut self.tensors, ::protobuf::RepeatedField::new())
    }

    // string device_name = 4;


    pub fn get_device_name(&self) -> &str {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::std::string::String) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_name(&mut self) -> &mut ::std::string::String {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SendTensorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tensors {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.context_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.op_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tensors)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.context_id != 0 {
            my_size += 9;
        }
        if self.op_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.op_id, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tensors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.device_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.device_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.context_id != 0 {
            os.write_fixed64(1, self.context_id)?;
        }
        if self.op_id != 0 {
            os.write_int64(2, self.op_id)?;
        }
        for v in &self.tensors {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.device_name.is_empty() {
            os.write_string(4, &self.device_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendTensorRequest {
        SendTensorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "context_id",
                |m: &SendTensorRequest| { &m.context_id },
                |m: &mut SendTensorRequest| { &mut m.context_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "op_id",
                |m: &SendTensorRequest| { &m.op_id },
                |m: &mut SendTensorRequest| { &mut m.op_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor::TensorProto>>(
                "tensors",
                |m: &SendTensorRequest| { &m.tensors },
                |m: &mut SendTensorRequest| { &mut m.tensors },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &SendTensorRequest| { &m.device_name },
                |m: &mut SendTensorRequest| { &mut m.device_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendTensorRequest>(
                "SendTensorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendTensorRequest {
        static instance: ::protobuf::rt::LazyV2<SendTensorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendTensorRequest::new)
    }
}

impl ::protobuf::Clear for SendTensorRequest {
    fn clear(&mut self) {
        self.context_id = 0;
        self.op_id = 0;
        self.tensors.clear();
        self.device_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendTensorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendTensorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SendTensorResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SendTensorResponse {
    fn default() -> &'a SendTensorResponse {
        <SendTensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl SendTensorResponse {
    pub fn new() -> SendTensorResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for SendTensorResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SendTensorResponse {
        SendTensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SendTensorResponse>(
                "SendTensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SendTensorResponse {
        static instance: ::protobuf::rt::LazyV2<SendTensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SendTensorResponse::new)
    }
}

impl ::protobuf::Clear for SendTensorResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SendTensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SendTensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n,tensorflow/core/protobuf/eager_service.proto\x12\x10tensorflow.eager\
    \x1a*tensorflow/core/framework/attr_value.proto\x1a1tensorflow/core/fram\
    ework/device_attributes.proto\x1a(tensorflow/core/framework/function.pro\
    to\x1a&tensorflow/core/framework/tensor.proto\x1a,tensorflow/core/framew\
    ork/tensor_shape.proto\x1a%tensorflow/core/framework/types.proto\x1a(ten\
    sorflow/core/framework/versions.proto\x1a0tensorflow/core/protobuf/tenso\
    rflow_server.proto\"\xa9\x01\n\x12RemoteTensorHandle\x12\x13\n\x05op_id\
    \x18\x01\x20\x01(\x03R\x04opId\x12\x1d\n\noutput_num\x18\x02\x20\x01(\
    \x05R\toutputNum\x12\x16\n\x06device\x18\x03\x20\x01(\tR\x06device\x12\
    \x1b\n\top_device\x18\x04\x20\x01(\tR\x08opDevice\x12*\n\x05dtype\x18\
    \x05\x20\x01(\x0e2\x14.tensorflow.DataTypeR\x05dtype\"\xba\x02\n\tOperat\
    ion\x12\x0e\n\x02id\x18\x01\x20\x01(\x03R\x02id\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12<\n\x06inputs\x18\x03\x20\x03(\x0b2$.tensorf\
    low.eager.RemoteTensorHandleR\x06inputs\x12$\n\x0econtrol_op_ids\x18\x04\
    \x20\x03(\x03R\x0ccontrolOpIds\x12<\n\x05attrs\x18\x05\x20\x03(\x0b2&.te\
    nsorflow.eager.Operation.AttrsEntryR\x05attrs\x12\x16\n\x06device\x18\
    \x06\x20\x01(\tR\x06device\x1aO\n\nAttrsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12+\n\x05value\x18\x02\x20\x01(\x0b2\x15.tensorflow\
    .AttrValueR\x05value:\x028\x01\"\xe5\x01\n\tQueueItem\x12P\n\x10handle_t\
    o_decref\x18\x01\x20\x01(\x0b2$.tensorflow.eager.RemoteTensorHandleH\0R\
    \x0ehandleToDecref\x12;\n\toperation\x18\x02\x20\x01(\x0b2\x1b.tensorflo\
    w.eager.OperationH\0R\toperation\x12A\n\x0bsend_tensor\x18\x03\x20\x01(\
    \x0b2\x1e.tensorflow.eager.SendTensorOpH\0R\nsendTensorB\x06\n\x04item\"\
    C\n\rQueueResponse\x122\n\x05shape\x18\x01\x20\x03(\x0b2\x1c.tensorflow.\
    TensorShapeProtoR\x05shape\"\xc2\x02\n\x14CreateContextRequest\x124\n\ns\
    erver_def\x18\x01\x20\x01(\x0b2\x15.tensorflow.ServerDefR\tserverDef\x12\
    \x14\n\x05async\x18\x02\x20\x01(\x08R\x05async\x12&\n\x0fkeep_alive_secs\
    \x18\x03\x20\x01(\x03R\rkeepAliveSecs\x127\n\x0bversion_def\x18\x04\x20\
    \x01(\x0b2\x16.tensorflow.VersionDefR\nversionDef\x12X\n\x19cluster_devi\
    ce_attributes\x18\x06\x20\x03(\x0b2\x1c.tensorflow.DeviceAttributesR\x17\
    clusterDeviceAttributes\x12\x1d\n\ncontext_id\x18\x07\x20\x01(\x06R\tcon\
    textIdJ\x04\x08\x05\x10\x06\"h\n\x15CreateContextResponse\x12I\n\x11devi\
    ce_attributes\x18\x02\x20\x03(\x0b2\x1c.tensorflow.DeviceAttributesR\x10\
    deviceAttributesJ\x04\x08\x01\x10\x02\"b\n\x0eEnqueueRequest\x12\x1d\n\n\
    context_id\x18\x01\x20\x01(\x06R\tcontextId\x121\n\x05queue\x18\x03\x20\
    \x03(\x0b2\x1b.tensorflow.eager.QueueItemR\x05queue\"Y\n\x0fEnqueueRespo\
    nse\x12F\n\x0equeue_response\x18\x01\x20\x03(\x0b2\x1f.tensorflow.eager.\
    QueueResponseR\rqueueResponse\"J\n\x14WaitQueueDoneRequest\x12\x1d\n\nco\
    ntext_id\x18\x01\x20\x01(\x06R\tcontextId\x12\x13\n\x05op_id\x18\x02\x20\
    \x03(\x03R\x04opId\"\x17\n\x15WaitQueueDoneResponse\"1\n\x10KeepAliveReq\
    uest\x12\x1d\n\ncontext_id\x18\x01\x20\x01(\x06R\tcontextId\"\x13\n\x11K\
    eepAliveResponse\"4\n\x13CloseContextRequest\x12\x1d\n\ncontext_id\x18\
    \x01\x20\x01(\x06R\tcontextId\"\x16\n\x14CloseContextResponse\"t\n\x17Re\
    gisterFunctionRequest\x12\x1d\n\ncontext_id\x18\x01\x20\x01(\x06R\tconte\
    xtId\x12:\n\x0cfunction_def\x18\x02\x20\x01(\x0b2\x17.tensorflow.Functio\
    nDefR\x0bfunctionDef\"\x1a\n\x18RegisterFunctionResponse\"w\n\x0cSendTen\
    sorOp\x12\x13\n\x05op_id\x18\x01\x20\x01(\x03R\x04opId\x121\n\x07tensors\
    \x18\x02\x20\x03(\x0b2\x17.tensorflow.TensorProtoR\x07tensors\x12\x1f\n\
    \x0bdevice_name\x18\x03\x20\x01(\tR\ndeviceName\"\x9b\x01\n\x11SendTenso\
    rRequest\x12\x1d\n\ncontext_id\x18\x01\x20\x01(\x06R\tcontextId\x12\x13\
    \n\x05op_id\x18\x02\x20\x01(\x03R\x04opId\x121\n\x07tensors\x18\x03\x20\
    \x03(\x0b2\x17.tensorflow.TensorProtoR\x07tensors\x12\x1f\n\x0bdevice_na\
    me\x18\x04\x20\x01(\tR\ndeviceName\"\x14\n\x12SendTensorResponse2\xfd\
    \x05\n\x0cEagerService\x12`\n\rCreateContext\x12&.tensorflow.eager.Creat\
    eContextRequest\x1a'.tensorflow.eager.CreateContextResponse\x12N\n\x07En\
    queue\x12\x20.tensorflow.eager.EnqueueRequest\x1a!.tensorflow.eager.Enqu\
    eueResponse\x12[\n\x10StreamingEnqueue\x12\x20.tensorflow.eager.EnqueueR\
    equest\x1a!.tensorflow.eager.EnqueueResponse(\x010\x01\x12`\n\rWaitQueue\
    Done\x12&.tensorflow.eager.WaitQueueDoneRequest\x1a'.tensorflow.eager.Wa\
    itQueueDoneResponse\x12T\n\tKeepAlive\x12\".tensorflow.eager.KeepAliveRe\
    quest\x1a#.tensorflow.eager.KeepAliveResponse\x12]\n\x0cCloseContext\x12\
    %.tensorflow.eager.CloseContextRequest\x1a&.tensorflow.eager.CloseContex\
    tResponse\x12i\n\x10RegisterFunction\x12).tensorflow.eager.RegisterFunct\
    ionRequest\x1a*.tensorflow.eager.RegisterFunctionResponse\x12\\\n\nSendT\
    ensor\x12#.tensorflow.eager.SendTensorRequest\x1a$.tensorflow.eager.Send\
    TensorResponse\"\x03\x88\x02\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
