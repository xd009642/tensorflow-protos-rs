// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/protobuf/tpu/optimization_parameters.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct ClippingLimits {
    // message fields
    pub lower: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    pub upper: ::protobuf::SingularPtrField<::protobuf::well_known_types::FloatValue>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClippingLimits {
    fn default() -> &'a ClippingLimits {
        <ClippingLimits as ::protobuf::Message>::default_instance()
    }
}

impl ClippingLimits {
    pub fn new() -> ClippingLimits {
        ::std::default::Default::default()
    }

    // .google.protobuf.FloatValue lower = 1;


    pub fn get_lower(&self) -> &::protobuf::well_known_types::FloatValue {
        self.lower.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lower(&mut self) {
        self.lower.clear();
    }

    pub fn has_lower(&self) -> bool {
        self.lower.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lower(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.lower = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lower(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.lower.is_none() {
            self.lower.set_default();
        }
        self.lower.as_mut().unwrap()
    }

    // Take field
    pub fn take_lower(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.lower.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }

    // .google.protobuf.FloatValue upper = 2;


    pub fn get_upper(&self) -> &::protobuf::well_known_types::FloatValue {
        self.upper.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::FloatValue as ::protobuf::Message>::default_instance())
    }
    pub fn clear_upper(&mut self) {
        self.upper.clear();
    }

    pub fn has_upper(&self) -> bool {
        self.upper.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upper(&mut self, v: ::protobuf::well_known_types::FloatValue) {
        self.upper = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upper(&mut self) -> &mut ::protobuf::well_known_types::FloatValue {
        if self.upper.is_none() {
            self.upper.set_default();
        }
        self.upper.as_mut().unwrap()
    }

    // Take field
    pub fn take_upper(&mut self) -> ::protobuf::well_known_types::FloatValue {
        self.upper.take().unwrap_or_else(|| ::protobuf::well_known_types::FloatValue::new())
    }
}

impl ::protobuf::Message for ClippingLimits {
    fn is_initialized(&self) -> bool {
        for v in &self.lower {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.upper {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lower)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.upper)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.lower.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.upper.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.lower.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.upper.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClippingLimits {
        ClippingLimits::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "lower",
                |m: &ClippingLimits| { &m.lower },
                |m: &mut ClippingLimits| { &mut m.lower },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::FloatValue>>(
                "upper",
                |m: &ClippingLimits| { &m.upper },
                |m: &mut ClippingLimits| { &mut m.upper },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClippingLimits>(
                "ClippingLimits",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClippingLimits {
        static instance: ::protobuf::rt::LazyV2<ClippingLimits> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClippingLimits::new)
    }
}

impl ::protobuf::Clear for ClippingLimits {
    fn clear(&mut self) {
        self.lower.clear();
        self.upper.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClippingLimits {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClippingLimits {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DynamicLearningRate {
    // message fields
    pub tag: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DynamicLearningRate {
    fn default() -> &'a DynamicLearningRate {
        <DynamicLearningRate as ::protobuf::Message>::default_instance()
    }
}

impl DynamicLearningRate {
    pub fn new() -> DynamicLearningRate {
        ::std::default::Default::default()
    }

    // int32 tag = 1;


    pub fn get_tag(&self) -> i32 {
        self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag = 0;
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: i32) {
        self.tag = v;
    }
}

impl ::protobuf::Message for DynamicLearningRate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tag = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.tag != 0 {
            my_size += ::protobuf::rt::value_size(1, self.tag, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.tag != 0 {
            os.write_int32(1, self.tag)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DynamicLearningRate {
        DynamicLearningRate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "tag",
                |m: &DynamicLearningRate| { &m.tag },
                |m: &mut DynamicLearningRate| { &mut m.tag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DynamicLearningRate>(
                "DynamicLearningRate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DynamicLearningRate {
        static instance: ::protobuf::rt::LazyV2<DynamicLearningRate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DynamicLearningRate::new)
    }
}

impl ::protobuf::Clear for DynamicLearningRate {
    fn clear(&mut self) {
        self.tag = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DynamicLearningRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DynamicLearningRate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LearningRate {
    // message oneof groups
    pub learning_rate: ::std::option::Option<LearningRate_oneof_learning_rate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LearningRate {
    fn default() -> &'a LearningRate {
        <LearningRate as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum LearningRate_oneof_learning_rate {
    constant(f32),
    dynamic(DynamicLearningRate),
}

impl LearningRate {
    pub fn new() -> LearningRate {
        ::std::default::Default::default()
    }

    // float constant = 1;


    pub fn get_constant(&self) -> f32 {
        match self.learning_rate {
            ::std::option::Option::Some(LearningRate_oneof_learning_rate::constant(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_constant(&mut self) {
        self.learning_rate = ::std::option::Option::None;
    }

    pub fn has_constant(&self) -> bool {
        match self.learning_rate {
            ::std::option::Option::Some(LearningRate_oneof_learning_rate::constant(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_constant(&mut self, v: f32) {
        self.learning_rate = ::std::option::Option::Some(LearningRate_oneof_learning_rate::constant(v))
    }

    // .tensorflow.tpu.DynamicLearningRate dynamic = 2;


    pub fn get_dynamic(&self) -> &DynamicLearningRate {
        match self.learning_rate {
            ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(ref v)) => v,
            _ => <DynamicLearningRate as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dynamic(&mut self) {
        self.learning_rate = ::std::option::Option::None;
    }

    pub fn has_dynamic(&self) -> bool {
        match self.learning_rate {
            ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dynamic(&mut self, v: DynamicLearningRate) {
        self.learning_rate = ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dynamic(&mut self) -> &mut DynamicLearningRate {
        if let ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(_)) = self.learning_rate {
        } else {
            self.learning_rate = ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(DynamicLearningRate::new()));
        }
        match self.learning_rate {
            ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dynamic(&mut self) -> DynamicLearningRate {
        if self.has_dynamic() {
            match self.learning_rate.take() {
                ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(v)) => v,
                _ => panic!(),
            }
        } else {
            DynamicLearningRate::new()
        }
    }
}

impl ::protobuf::Message for LearningRate {
    fn is_initialized(&self) -> bool {
        if let Some(LearningRate_oneof_learning_rate::dynamic(ref v)) = self.learning_rate {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.learning_rate = ::std::option::Option::Some(LearningRate_oneof_learning_rate::constant(is.read_float()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.learning_rate = ::std::option::Option::Some(LearningRate_oneof_learning_rate::dynamic(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.learning_rate {
            match v {
                &LearningRate_oneof_learning_rate::constant(v) => {
                    my_size += 5;
                },
                &LearningRate_oneof_learning_rate::dynamic(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.learning_rate {
            match v {
                &LearningRate_oneof_learning_rate::constant(v) => {
                    os.write_float(1, v)?;
                },
                &LearningRate_oneof_learning_rate::dynamic(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LearningRate {
        LearningRate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "constant",
                LearningRate::has_constant,
                LearningRate::get_constant,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DynamicLearningRate>(
                "dynamic",
                LearningRate::has_dynamic,
                LearningRate::get_dynamic,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LearningRate>(
                "LearningRate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LearningRate {
        static instance: ::protobuf::rt::LazyV2<LearningRate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LearningRate::new)
    }
}

impl ::protobuf::Clear for LearningRate {
    fn clear(&mut self) {
        self.learning_rate = ::std::option::Option::None;
        self.learning_rate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LearningRate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LearningRate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdagradParameters {
    // message fields
    pub initial_accumulator: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdagradParameters {
    fn default() -> &'a AdagradParameters {
        <AdagradParameters as ::protobuf::Message>::default_instance()
    }
}

impl AdagradParameters {
    pub fn new() -> AdagradParameters {
        ::std::default::Default::default()
    }

    // float initial_accumulator = 1;


    pub fn get_initial_accumulator(&self) -> f32 {
        self.initial_accumulator
    }
    pub fn clear_initial_accumulator(&mut self) {
        self.initial_accumulator = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_accumulator(&mut self, v: f32) {
        self.initial_accumulator = v;
    }
}

impl ::protobuf::Message for AdagradParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_accumulator = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.initial_accumulator != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.initial_accumulator != 0. {
            os.write_float(1, self.initial_accumulator)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdagradParameters {
        AdagradParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_accumulator",
                |m: &AdagradParameters| { &m.initial_accumulator },
                |m: &mut AdagradParameters| { &mut m.initial_accumulator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdagradParameters>(
                "AdagradParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdagradParameters {
        static instance: ::protobuf::rt::LazyV2<AdagradParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdagradParameters::new)
    }
}

impl ::protobuf::Clear for AdagradParameters {
    fn clear(&mut self) {
        self.initial_accumulator = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdagradParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdagradParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BoundedAdagradParameters {
    // message fields
    pub update_accumulator_first: bool,
    pub max_var_update: f32,
    pub max_accumulator: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BoundedAdagradParameters {
    fn default() -> &'a BoundedAdagradParameters {
        <BoundedAdagradParameters as ::protobuf::Message>::default_instance()
    }
}

impl BoundedAdagradParameters {
    pub fn new() -> BoundedAdagradParameters {
        ::std::default::Default::default()
    }

    // bool update_accumulator_first = 1;


    pub fn get_update_accumulator_first(&self) -> bool {
        self.update_accumulator_first
    }
    pub fn clear_update_accumulator_first(&mut self) {
        self.update_accumulator_first = false;
    }

    // Param is passed by value, moved
    pub fn set_update_accumulator_first(&mut self, v: bool) {
        self.update_accumulator_first = v;
    }

    // float max_var_update = 2;


    pub fn get_max_var_update(&self) -> f32 {
        self.max_var_update
    }
    pub fn clear_max_var_update(&mut self) {
        self.max_var_update = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_var_update(&mut self, v: f32) {
        self.max_var_update = v;
    }

    // float max_accumulator = 3;


    pub fn get_max_accumulator(&self) -> f32 {
        self.max_accumulator
    }
    pub fn clear_max_accumulator(&mut self) {
        self.max_accumulator = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_accumulator(&mut self, v: f32) {
        self.max_accumulator = v;
    }
}

impl ::protobuf::Message for BoundedAdagradParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.update_accumulator_first = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_var_update = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_accumulator = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.update_accumulator_first != false {
            my_size += 2;
        }
        if self.max_var_update != 0. {
            my_size += 5;
        }
        if self.max_accumulator != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.update_accumulator_first != false {
            os.write_bool(1, self.update_accumulator_first)?;
        }
        if self.max_var_update != 0. {
            os.write_float(2, self.max_var_update)?;
        }
        if self.max_accumulator != 0. {
            os.write_float(3, self.max_accumulator)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BoundedAdagradParameters {
        BoundedAdagradParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "update_accumulator_first",
                |m: &BoundedAdagradParameters| { &m.update_accumulator_first },
                |m: &mut BoundedAdagradParameters| { &mut m.update_accumulator_first },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_var_update",
                |m: &BoundedAdagradParameters| { &m.max_var_update },
                |m: &mut BoundedAdagradParameters| { &mut m.max_var_update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_accumulator",
                |m: &BoundedAdagradParameters| { &m.max_accumulator },
                |m: &mut BoundedAdagradParameters| { &mut m.max_accumulator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BoundedAdagradParameters>(
                "BoundedAdagradParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BoundedAdagradParameters {
        static instance: ::protobuf::rt::LazyV2<BoundedAdagradParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BoundedAdagradParameters::new)
    }
}

impl ::protobuf::Clear for BoundedAdagradParameters {
    fn clear(&mut self) {
        self.update_accumulator_first = false;
        self.max_var_update = 0.;
        self.max_accumulator = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BoundedAdagradParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BoundedAdagradParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StochasticGradientDescentParameters {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StochasticGradientDescentParameters {
    fn default() -> &'a StochasticGradientDescentParameters {
        <StochasticGradientDescentParameters as ::protobuf::Message>::default_instance()
    }
}

impl StochasticGradientDescentParameters {
    pub fn new() -> StochasticGradientDescentParameters {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for StochasticGradientDescentParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StochasticGradientDescentParameters {
        StochasticGradientDescentParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StochasticGradientDescentParameters>(
                "StochasticGradientDescentParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StochasticGradientDescentParameters {
        static instance: ::protobuf::rt::LazyV2<StochasticGradientDescentParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StochasticGradientDescentParameters::new)
    }
}

impl ::protobuf::Clear for StochasticGradientDescentParameters {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StochasticGradientDescentParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StochasticGradientDescentParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FtrlParameters {
    // message fields
    pub l1: f32,
    pub l2: f32,
    pub lr_power: f32,
    pub initial_accum: f32,
    pub initial_linear: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FtrlParameters {
    fn default() -> &'a FtrlParameters {
        <FtrlParameters as ::protobuf::Message>::default_instance()
    }
}

impl FtrlParameters {
    pub fn new() -> FtrlParameters {
        ::std::default::Default::default()
    }

    // float l1 = 1;


    pub fn get_l1(&self) -> f32 {
        self.l1
    }
    pub fn clear_l1(&mut self) {
        self.l1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_l1(&mut self, v: f32) {
        self.l1 = v;
    }

    // float l2 = 2;


    pub fn get_l2(&self) -> f32 {
        self.l2
    }
    pub fn clear_l2(&mut self) {
        self.l2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_l2(&mut self, v: f32) {
        self.l2 = v;
    }

    // float lr_power = 3;


    pub fn get_lr_power(&self) -> f32 {
        self.lr_power
    }
    pub fn clear_lr_power(&mut self) {
        self.lr_power = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lr_power(&mut self, v: f32) {
        self.lr_power = v;
    }

    // float initial_accum = 4;


    pub fn get_initial_accum(&self) -> f32 {
        self.initial_accum
    }
    pub fn clear_initial_accum(&mut self) {
        self.initial_accum = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_accum(&mut self, v: f32) {
        self.initial_accum = v;
    }

    // float initial_linear = 5;


    pub fn get_initial_linear(&self) -> f32 {
        self.initial_linear
    }
    pub fn clear_initial_linear(&mut self) {
        self.initial_linear = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_linear(&mut self, v: f32) {
        self.initial_linear = v;
    }
}

impl ::protobuf::Message for FtrlParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.l1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.l2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.lr_power = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_accum = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_linear = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.l1 != 0. {
            my_size += 5;
        }
        if self.l2 != 0. {
            my_size += 5;
        }
        if self.lr_power != 0. {
            my_size += 5;
        }
        if self.initial_accum != 0. {
            my_size += 5;
        }
        if self.initial_linear != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.l1 != 0. {
            os.write_float(1, self.l1)?;
        }
        if self.l2 != 0. {
            os.write_float(2, self.l2)?;
        }
        if self.lr_power != 0. {
            os.write_float(3, self.lr_power)?;
        }
        if self.initial_accum != 0. {
            os.write_float(4, self.initial_accum)?;
        }
        if self.initial_linear != 0. {
            os.write_float(5, self.initial_linear)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FtrlParameters {
        FtrlParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "l1",
                |m: &FtrlParameters| { &m.l1 },
                |m: &mut FtrlParameters| { &mut m.l1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "l2",
                |m: &FtrlParameters| { &m.l2 },
                |m: &mut FtrlParameters| { &mut m.l2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "lr_power",
                |m: &FtrlParameters| { &m.lr_power },
                |m: &mut FtrlParameters| { &mut m.lr_power },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_accum",
                |m: &FtrlParameters| { &m.initial_accum },
                |m: &mut FtrlParameters| { &mut m.initial_accum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_linear",
                |m: &FtrlParameters| { &m.initial_linear },
                |m: &mut FtrlParameters| { &mut m.initial_linear },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FtrlParameters>(
                "FtrlParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FtrlParameters {
        static instance: ::protobuf::rt::LazyV2<FtrlParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FtrlParameters::new)
    }
}

impl ::protobuf::Clear for FtrlParameters {
    fn clear(&mut self) {
        self.l1 = 0.;
        self.l2 = 0.;
        self.lr_power = 0.;
        self.initial_accum = 0.;
        self.initial_linear = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FtrlParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FtrlParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdamParameters {
    // message fields
    pub beta1: f32,
    pub beta2: f32,
    pub epsilon: f32,
    pub initial_m: f32,
    pub initial_v: f32,
    pub use_non_lazy_adam: bool,
    pub use_sum_inside_sqrt: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdamParameters {
    fn default() -> &'a AdamParameters {
        <AdamParameters as ::protobuf::Message>::default_instance()
    }
}

impl AdamParameters {
    pub fn new() -> AdamParameters {
        ::std::default::Default::default()
    }

    // float beta1 = 3;


    pub fn get_beta1(&self) -> f32 {
        self.beta1
    }
    pub fn clear_beta1(&mut self) {
        self.beta1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_beta1(&mut self, v: f32) {
        self.beta1 = v;
    }

    // float beta2 = 4;


    pub fn get_beta2(&self) -> f32 {
        self.beta2
    }
    pub fn clear_beta2(&mut self) {
        self.beta2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_beta2(&mut self, v: f32) {
        self.beta2 = v;
    }

    // float epsilon = 5;


    pub fn get_epsilon(&self) -> f32 {
        self.epsilon
    }
    pub fn clear_epsilon(&mut self) {
        self.epsilon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_epsilon(&mut self, v: f32) {
        self.epsilon = v;
    }

    // float initial_m = 6;


    pub fn get_initial_m(&self) -> f32 {
        self.initial_m
    }
    pub fn clear_initial_m(&mut self) {
        self.initial_m = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_m(&mut self, v: f32) {
        self.initial_m = v;
    }

    // float initial_v = 7;


    pub fn get_initial_v(&self) -> f32 {
        self.initial_v
    }
    pub fn clear_initial_v(&mut self) {
        self.initial_v = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_v(&mut self, v: f32) {
        self.initial_v = v;
    }

    // bool use_non_lazy_adam = 8;


    pub fn get_use_non_lazy_adam(&self) -> bool {
        self.use_non_lazy_adam
    }
    pub fn clear_use_non_lazy_adam(&mut self) {
        self.use_non_lazy_adam = false;
    }

    // Param is passed by value, moved
    pub fn set_use_non_lazy_adam(&mut self, v: bool) {
        self.use_non_lazy_adam = v;
    }

    // bool use_sum_inside_sqrt = 10;


    pub fn get_use_sum_inside_sqrt(&self) -> bool {
        self.use_sum_inside_sqrt
    }
    pub fn clear_use_sum_inside_sqrt(&mut self) {
        self.use_sum_inside_sqrt = false;
    }

    // Param is passed by value, moved
    pub fn set_use_sum_inside_sqrt(&mut self, v: bool) {
        self.use_sum_inside_sqrt = v;
    }
}

impl ::protobuf::Message for AdamParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.beta1 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.beta2 = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.epsilon = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_m = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_v = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_non_lazy_adam = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_sum_inside_sqrt = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.beta1 != 0. {
            my_size += 5;
        }
        if self.beta2 != 0. {
            my_size += 5;
        }
        if self.epsilon != 0. {
            my_size += 5;
        }
        if self.initial_m != 0. {
            my_size += 5;
        }
        if self.initial_v != 0. {
            my_size += 5;
        }
        if self.use_non_lazy_adam != false {
            my_size += 2;
        }
        if self.use_sum_inside_sqrt != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.beta1 != 0. {
            os.write_float(3, self.beta1)?;
        }
        if self.beta2 != 0. {
            os.write_float(4, self.beta2)?;
        }
        if self.epsilon != 0. {
            os.write_float(5, self.epsilon)?;
        }
        if self.initial_m != 0. {
            os.write_float(6, self.initial_m)?;
        }
        if self.initial_v != 0. {
            os.write_float(7, self.initial_v)?;
        }
        if self.use_non_lazy_adam != false {
            os.write_bool(8, self.use_non_lazy_adam)?;
        }
        if self.use_sum_inside_sqrt != false {
            os.write_bool(10, self.use_sum_inside_sqrt)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdamParameters {
        AdamParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "beta1",
                |m: &AdamParameters| { &m.beta1 },
                |m: &mut AdamParameters| { &mut m.beta1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "beta2",
                |m: &AdamParameters| { &m.beta2 },
                |m: &mut AdamParameters| { &mut m.beta2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "epsilon",
                |m: &AdamParameters| { &m.epsilon },
                |m: &mut AdamParameters| { &mut m.epsilon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_m",
                |m: &AdamParameters| { &m.initial_m },
                |m: &mut AdamParameters| { &mut m.initial_m },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_v",
                |m: &AdamParameters| { &m.initial_v },
                |m: &mut AdamParameters| { &mut m.initial_v },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_non_lazy_adam",
                |m: &AdamParameters| { &m.use_non_lazy_adam },
                |m: &mut AdamParameters| { &mut m.use_non_lazy_adam },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_sum_inside_sqrt",
                |m: &AdamParameters| { &m.use_sum_inside_sqrt },
                |m: &mut AdamParameters| { &mut m.use_sum_inside_sqrt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdamParameters>(
                "AdamParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdamParameters {
        static instance: ::protobuf::rt::LazyV2<AdamParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdamParameters::new)
    }
}

impl ::protobuf::Clear for AdamParameters {
    fn clear(&mut self) {
        self.beta1 = 0.;
        self.beta2 = 0.;
        self.epsilon = 0.;
        self.initial_m = 0.;
        self.initial_v = 0.;
        self.use_non_lazy_adam = false;
        self.use_sum_inside_sqrt = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdamParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdamParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MomentumParameters {
    // message fields
    pub momentum: f32,
    pub use_nesterov: bool,
    pub initial_accum: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MomentumParameters {
    fn default() -> &'a MomentumParameters {
        <MomentumParameters as ::protobuf::Message>::default_instance()
    }
}

impl MomentumParameters {
    pub fn new() -> MomentumParameters {
        ::std::default::Default::default()
    }

    // float momentum = 1;


    pub fn get_momentum(&self) -> f32 {
        self.momentum
    }
    pub fn clear_momentum(&mut self) {
        self.momentum = 0.;
    }

    // Param is passed by value, moved
    pub fn set_momentum(&mut self, v: f32) {
        self.momentum = v;
    }

    // bool use_nesterov = 2;


    pub fn get_use_nesterov(&self) -> bool {
        self.use_nesterov
    }
    pub fn clear_use_nesterov(&mut self) {
        self.use_nesterov = false;
    }

    // Param is passed by value, moved
    pub fn set_use_nesterov(&mut self, v: bool) {
        self.use_nesterov = v;
    }

    // float initial_accum = 3;


    pub fn get_initial_accum(&self) -> f32 {
        self.initial_accum
    }
    pub fn clear_initial_accum(&mut self) {
        self.initial_accum = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_accum(&mut self, v: f32) {
        self.initial_accum = v;
    }
}

impl ::protobuf::Message for MomentumParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.momentum = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_nesterov = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_accum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.momentum != 0. {
            my_size += 5;
        }
        if self.use_nesterov != false {
            my_size += 2;
        }
        if self.initial_accum != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.momentum != 0. {
            os.write_float(1, self.momentum)?;
        }
        if self.use_nesterov != false {
            os.write_bool(2, self.use_nesterov)?;
        }
        if self.initial_accum != 0. {
            os.write_float(3, self.initial_accum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MomentumParameters {
        MomentumParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "momentum",
                |m: &MomentumParameters| { &m.momentum },
                |m: &mut MomentumParameters| { &mut m.momentum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_nesterov",
                |m: &MomentumParameters| { &m.use_nesterov },
                |m: &mut MomentumParameters| { &mut m.use_nesterov },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_accum",
                |m: &MomentumParameters| { &m.initial_accum },
                |m: &mut MomentumParameters| { &mut m.initial_accum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MomentumParameters>(
                "MomentumParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MomentumParameters {
        static instance: ::protobuf::rt::LazyV2<MomentumParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MomentumParameters::new)
    }
}

impl ::protobuf::Clear for MomentumParameters {
    fn clear(&mut self) {
        self.momentum = 0.;
        self.use_nesterov = false;
        self.initial_accum = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MomentumParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MomentumParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RmsPropParameters {
    // message fields
    pub rho: f32,
    pub momentum: f32,
    pub epsilon: f32,
    pub initial_ms: f32,
    pub initial_mom: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RmsPropParameters {
    fn default() -> &'a RmsPropParameters {
        <RmsPropParameters as ::protobuf::Message>::default_instance()
    }
}

impl RmsPropParameters {
    pub fn new() -> RmsPropParameters {
        ::std::default::Default::default()
    }

    // float rho = 1;


    pub fn get_rho(&self) -> f32 {
        self.rho
    }
    pub fn clear_rho(&mut self) {
        self.rho = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rho(&mut self, v: f32) {
        self.rho = v;
    }

    // float momentum = 2;


    pub fn get_momentum(&self) -> f32 {
        self.momentum
    }
    pub fn clear_momentum(&mut self) {
        self.momentum = 0.;
    }

    // Param is passed by value, moved
    pub fn set_momentum(&mut self, v: f32) {
        self.momentum = v;
    }

    // float epsilon = 3;


    pub fn get_epsilon(&self) -> f32 {
        self.epsilon
    }
    pub fn clear_epsilon(&mut self) {
        self.epsilon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_epsilon(&mut self, v: f32) {
        self.epsilon = v;
    }

    // float initial_ms = 4;


    pub fn get_initial_ms(&self) -> f32 {
        self.initial_ms
    }
    pub fn clear_initial_ms(&mut self) {
        self.initial_ms = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_ms(&mut self, v: f32) {
        self.initial_ms = v;
    }

    // float initial_mom = 5;


    pub fn get_initial_mom(&self) -> f32 {
        self.initial_mom
    }
    pub fn clear_initial_mom(&mut self) {
        self.initial_mom = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_mom(&mut self, v: f32) {
        self.initial_mom = v;
    }
}

impl ::protobuf::Message for RmsPropParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rho = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.momentum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.epsilon = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_ms = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_mom = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rho != 0. {
            my_size += 5;
        }
        if self.momentum != 0. {
            my_size += 5;
        }
        if self.epsilon != 0. {
            my_size += 5;
        }
        if self.initial_ms != 0. {
            my_size += 5;
        }
        if self.initial_mom != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rho != 0. {
            os.write_float(1, self.rho)?;
        }
        if self.momentum != 0. {
            os.write_float(2, self.momentum)?;
        }
        if self.epsilon != 0. {
            os.write_float(3, self.epsilon)?;
        }
        if self.initial_ms != 0. {
            os.write_float(4, self.initial_ms)?;
        }
        if self.initial_mom != 0. {
            os.write_float(5, self.initial_mom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RmsPropParameters {
        RmsPropParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "rho",
                |m: &RmsPropParameters| { &m.rho },
                |m: &mut RmsPropParameters| { &mut m.rho },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "momentum",
                |m: &RmsPropParameters| { &m.momentum },
                |m: &mut RmsPropParameters| { &mut m.momentum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "epsilon",
                |m: &RmsPropParameters| { &m.epsilon },
                |m: &mut RmsPropParameters| { &mut m.epsilon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_ms",
                |m: &RmsPropParameters| { &m.initial_ms },
                |m: &mut RmsPropParameters| { &mut m.initial_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_mom",
                |m: &RmsPropParameters| { &m.initial_mom },
                |m: &mut RmsPropParameters| { &mut m.initial_mom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RmsPropParameters>(
                "RmsPropParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RmsPropParameters {
        static instance: ::protobuf::rt::LazyV2<RmsPropParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RmsPropParameters::new)
    }
}

impl ::protobuf::Clear for RmsPropParameters {
    fn clear(&mut self) {
        self.rho = 0.;
        self.momentum = 0.;
        self.epsilon = 0.;
        self.initial_ms = 0.;
        self.initial_mom = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RmsPropParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RmsPropParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CenteredRmsPropParameters {
    // message fields
    pub rho: f32,
    pub momentum: f32,
    pub epsilon: f32,
    pub initial_ms: f32,
    pub initial_mom: f32,
    pub initial_mg: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CenteredRmsPropParameters {
    fn default() -> &'a CenteredRmsPropParameters {
        <CenteredRmsPropParameters as ::protobuf::Message>::default_instance()
    }
}

impl CenteredRmsPropParameters {
    pub fn new() -> CenteredRmsPropParameters {
        ::std::default::Default::default()
    }

    // float rho = 1;


    pub fn get_rho(&self) -> f32 {
        self.rho
    }
    pub fn clear_rho(&mut self) {
        self.rho = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rho(&mut self, v: f32) {
        self.rho = v;
    }

    // float momentum = 2;


    pub fn get_momentum(&self) -> f32 {
        self.momentum
    }
    pub fn clear_momentum(&mut self) {
        self.momentum = 0.;
    }

    // Param is passed by value, moved
    pub fn set_momentum(&mut self, v: f32) {
        self.momentum = v;
    }

    // float epsilon = 3;


    pub fn get_epsilon(&self) -> f32 {
        self.epsilon
    }
    pub fn clear_epsilon(&mut self) {
        self.epsilon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_epsilon(&mut self, v: f32) {
        self.epsilon = v;
    }

    // float initial_ms = 4;


    pub fn get_initial_ms(&self) -> f32 {
        self.initial_ms
    }
    pub fn clear_initial_ms(&mut self) {
        self.initial_ms = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_ms(&mut self, v: f32) {
        self.initial_ms = v;
    }

    // float initial_mom = 5;


    pub fn get_initial_mom(&self) -> f32 {
        self.initial_mom
    }
    pub fn clear_initial_mom(&mut self) {
        self.initial_mom = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_mom(&mut self, v: f32) {
        self.initial_mom = v;
    }

    // float initial_mg = 6;


    pub fn get_initial_mg(&self) -> f32 {
        self.initial_mg
    }
    pub fn clear_initial_mg(&mut self) {
        self.initial_mg = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_mg(&mut self, v: f32) {
        self.initial_mg = v;
    }
}

impl ::protobuf::Message for CenteredRmsPropParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rho = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.momentum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.epsilon = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_ms = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_mom = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_mg = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rho != 0. {
            my_size += 5;
        }
        if self.momentum != 0. {
            my_size += 5;
        }
        if self.epsilon != 0. {
            my_size += 5;
        }
        if self.initial_ms != 0. {
            my_size += 5;
        }
        if self.initial_mom != 0. {
            my_size += 5;
        }
        if self.initial_mg != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rho != 0. {
            os.write_float(1, self.rho)?;
        }
        if self.momentum != 0. {
            os.write_float(2, self.momentum)?;
        }
        if self.epsilon != 0. {
            os.write_float(3, self.epsilon)?;
        }
        if self.initial_ms != 0. {
            os.write_float(4, self.initial_ms)?;
        }
        if self.initial_mom != 0. {
            os.write_float(5, self.initial_mom)?;
        }
        if self.initial_mg != 0. {
            os.write_float(6, self.initial_mg)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CenteredRmsPropParameters {
        CenteredRmsPropParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "rho",
                |m: &CenteredRmsPropParameters| { &m.rho },
                |m: &mut CenteredRmsPropParameters| { &mut m.rho },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "momentum",
                |m: &CenteredRmsPropParameters| { &m.momentum },
                |m: &mut CenteredRmsPropParameters| { &mut m.momentum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "epsilon",
                |m: &CenteredRmsPropParameters| { &m.epsilon },
                |m: &mut CenteredRmsPropParameters| { &mut m.epsilon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_ms",
                |m: &CenteredRmsPropParameters| { &m.initial_ms },
                |m: &mut CenteredRmsPropParameters| { &mut m.initial_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_mom",
                |m: &CenteredRmsPropParameters| { &m.initial_mom },
                |m: &mut CenteredRmsPropParameters| { &mut m.initial_mom },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_mg",
                |m: &CenteredRmsPropParameters| { &m.initial_mg },
                |m: &mut CenteredRmsPropParameters| { &mut m.initial_mg },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CenteredRmsPropParameters>(
                "CenteredRmsPropParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CenteredRmsPropParameters {
        static instance: ::protobuf::rt::LazyV2<CenteredRmsPropParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CenteredRmsPropParameters::new)
    }
}

impl ::protobuf::Clear for CenteredRmsPropParameters {
    fn clear(&mut self) {
        self.rho = 0.;
        self.momentum = 0.;
        self.epsilon = 0.;
        self.initial_ms = 0.;
        self.initial_mom = 0.;
        self.initial_mg = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CenteredRmsPropParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CenteredRmsPropParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MdlAdagradLightParameters {
    // message fields
    pub l2: f32,
    pub lr_power: f32,
    pub min_servable_mdl_benefit: f32,
    pub mdl_mix_in_margin: f32,
    pub mdl_benefit_rampup_coeff: f32,
    pub mdl_min_weight: f32,
    pub benefit_revisit_scale: f32,
    pub max_event_benefit: f32,
    pub max_total_benefit: f32,
    pub mdl_hard_limit: f32,
    pub hard_limit_min_benefit: bool,
    pub mdl_regularize: bool,
    pub initial_accumulator: f32,
    pub initial_weight: f32,
    pub initial_benefit: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MdlAdagradLightParameters {
    fn default() -> &'a MdlAdagradLightParameters {
        <MdlAdagradLightParameters as ::protobuf::Message>::default_instance()
    }
}

impl MdlAdagradLightParameters {
    pub fn new() -> MdlAdagradLightParameters {
        ::std::default::Default::default()
    }

    // float l2 = 1;


    pub fn get_l2(&self) -> f32 {
        self.l2
    }
    pub fn clear_l2(&mut self) {
        self.l2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_l2(&mut self, v: f32) {
        self.l2 = v;
    }

    // float lr_power = 2;


    pub fn get_lr_power(&self) -> f32 {
        self.lr_power
    }
    pub fn clear_lr_power(&mut self) {
        self.lr_power = 0.;
    }

    // Param is passed by value, moved
    pub fn set_lr_power(&mut self, v: f32) {
        self.lr_power = v;
    }

    // float min_servable_mdl_benefit = 3;


    pub fn get_min_servable_mdl_benefit(&self) -> f32 {
        self.min_servable_mdl_benefit
    }
    pub fn clear_min_servable_mdl_benefit(&mut self) {
        self.min_servable_mdl_benefit = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min_servable_mdl_benefit(&mut self, v: f32) {
        self.min_servable_mdl_benefit = v;
    }

    // float mdl_mix_in_margin = 4;


    pub fn get_mdl_mix_in_margin(&self) -> f32 {
        self.mdl_mix_in_margin
    }
    pub fn clear_mdl_mix_in_margin(&mut self) {
        self.mdl_mix_in_margin = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mdl_mix_in_margin(&mut self, v: f32) {
        self.mdl_mix_in_margin = v;
    }

    // float mdl_benefit_rampup_coeff = 5;


    pub fn get_mdl_benefit_rampup_coeff(&self) -> f32 {
        self.mdl_benefit_rampup_coeff
    }
    pub fn clear_mdl_benefit_rampup_coeff(&mut self) {
        self.mdl_benefit_rampup_coeff = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mdl_benefit_rampup_coeff(&mut self, v: f32) {
        self.mdl_benefit_rampup_coeff = v;
    }

    // float mdl_min_weight = 6;


    pub fn get_mdl_min_weight(&self) -> f32 {
        self.mdl_min_weight
    }
    pub fn clear_mdl_min_weight(&mut self) {
        self.mdl_min_weight = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mdl_min_weight(&mut self, v: f32) {
        self.mdl_min_weight = v;
    }

    // float benefit_revisit_scale = 7;


    pub fn get_benefit_revisit_scale(&self) -> f32 {
        self.benefit_revisit_scale
    }
    pub fn clear_benefit_revisit_scale(&mut self) {
        self.benefit_revisit_scale = 0.;
    }

    // Param is passed by value, moved
    pub fn set_benefit_revisit_scale(&mut self, v: f32) {
        self.benefit_revisit_scale = v;
    }

    // float max_event_benefit = 8;


    pub fn get_max_event_benefit(&self) -> f32 {
        self.max_event_benefit
    }
    pub fn clear_max_event_benefit(&mut self) {
        self.max_event_benefit = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_event_benefit(&mut self, v: f32) {
        self.max_event_benefit = v;
    }

    // float max_total_benefit = 9;


    pub fn get_max_total_benefit(&self) -> f32 {
        self.max_total_benefit
    }
    pub fn clear_max_total_benefit(&mut self) {
        self.max_total_benefit = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max_total_benefit(&mut self, v: f32) {
        self.max_total_benefit = v;
    }

    // float mdl_hard_limit = 10;


    pub fn get_mdl_hard_limit(&self) -> f32 {
        self.mdl_hard_limit
    }
    pub fn clear_mdl_hard_limit(&mut self) {
        self.mdl_hard_limit = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mdl_hard_limit(&mut self, v: f32) {
        self.mdl_hard_limit = v;
    }

    // bool hard_limit_min_benefit = 11;


    pub fn get_hard_limit_min_benefit(&self) -> bool {
        self.hard_limit_min_benefit
    }
    pub fn clear_hard_limit_min_benefit(&mut self) {
        self.hard_limit_min_benefit = false;
    }

    // Param is passed by value, moved
    pub fn set_hard_limit_min_benefit(&mut self, v: bool) {
        self.hard_limit_min_benefit = v;
    }

    // bool mdl_regularize = 12;


    pub fn get_mdl_regularize(&self) -> bool {
        self.mdl_regularize
    }
    pub fn clear_mdl_regularize(&mut self) {
        self.mdl_regularize = false;
    }

    // Param is passed by value, moved
    pub fn set_mdl_regularize(&mut self, v: bool) {
        self.mdl_regularize = v;
    }

    // float initial_accumulator = 13;


    pub fn get_initial_accumulator(&self) -> f32 {
        self.initial_accumulator
    }
    pub fn clear_initial_accumulator(&mut self) {
        self.initial_accumulator = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_accumulator(&mut self, v: f32) {
        self.initial_accumulator = v;
    }

    // float initial_weight = 14;


    pub fn get_initial_weight(&self) -> f32 {
        self.initial_weight
    }
    pub fn clear_initial_weight(&mut self) {
        self.initial_weight = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_weight(&mut self, v: f32) {
        self.initial_weight = v;
    }

    // float initial_benefit = 15;


    pub fn get_initial_benefit(&self) -> f32 {
        self.initial_benefit
    }
    pub fn clear_initial_benefit(&mut self) {
        self.initial_benefit = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_benefit(&mut self, v: f32) {
        self.initial_benefit = v;
    }
}

impl ::protobuf::Message for MdlAdagradLightParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.l2 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.lr_power = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.min_servable_mdl_benefit = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mdl_mix_in_margin = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mdl_benefit_rampup_coeff = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mdl_min_weight = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.benefit_revisit_scale = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_event_benefit = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.max_total_benefit = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.mdl_hard_limit = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hard_limit_min_benefit = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.mdl_regularize = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_accumulator = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_weight = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_benefit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.l2 != 0. {
            my_size += 5;
        }
        if self.lr_power != 0. {
            my_size += 5;
        }
        if self.min_servable_mdl_benefit != 0. {
            my_size += 5;
        }
        if self.mdl_mix_in_margin != 0. {
            my_size += 5;
        }
        if self.mdl_benefit_rampup_coeff != 0. {
            my_size += 5;
        }
        if self.mdl_min_weight != 0. {
            my_size += 5;
        }
        if self.benefit_revisit_scale != 0. {
            my_size += 5;
        }
        if self.max_event_benefit != 0. {
            my_size += 5;
        }
        if self.max_total_benefit != 0. {
            my_size += 5;
        }
        if self.mdl_hard_limit != 0. {
            my_size += 5;
        }
        if self.hard_limit_min_benefit != false {
            my_size += 2;
        }
        if self.mdl_regularize != false {
            my_size += 2;
        }
        if self.initial_accumulator != 0. {
            my_size += 5;
        }
        if self.initial_weight != 0. {
            my_size += 5;
        }
        if self.initial_benefit != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.l2 != 0. {
            os.write_float(1, self.l2)?;
        }
        if self.lr_power != 0. {
            os.write_float(2, self.lr_power)?;
        }
        if self.min_servable_mdl_benefit != 0. {
            os.write_float(3, self.min_servable_mdl_benefit)?;
        }
        if self.mdl_mix_in_margin != 0. {
            os.write_float(4, self.mdl_mix_in_margin)?;
        }
        if self.mdl_benefit_rampup_coeff != 0. {
            os.write_float(5, self.mdl_benefit_rampup_coeff)?;
        }
        if self.mdl_min_weight != 0. {
            os.write_float(6, self.mdl_min_weight)?;
        }
        if self.benefit_revisit_scale != 0. {
            os.write_float(7, self.benefit_revisit_scale)?;
        }
        if self.max_event_benefit != 0. {
            os.write_float(8, self.max_event_benefit)?;
        }
        if self.max_total_benefit != 0. {
            os.write_float(9, self.max_total_benefit)?;
        }
        if self.mdl_hard_limit != 0. {
            os.write_float(10, self.mdl_hard_limit)?;
        }
        if self.hard_limit_min_benefit != false {
            os.write_bool(11, self.hard_limit_min_benefit)?;
        }
        if self.mdl_regularize != false {
            os.write_bool(12, self.mdl_regularize)?;
        }
        if self.initial_accumulator != 0. {
            os.write_float(13, self.initial_accumulator)?;
        }
        if self.initial_weight != 0. {
            os.write_float(14, self.initial_weight)?;
        }
        if self.initial_benefit != 0. {
            os.write_float(15, self.initial_benefit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MdlAdagradLightParameters {
        MdlAdagradLightParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "l2",
                |m: &MdlAdagradLightParameters| { &m.l2 },
                |m: &mut MdlAdagradLightParameters| { &mut m.l2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "lr_power",
                |m: &MdlAdagradLightParameters| { &m.lr_power },
                |m: &mut MdlAdagradLightParameters| { &mut m.lr_power },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "min_servable_mdl_benefit",
                |m: &MdlAdagradLightParameters| { &m.min_servable_mdl_benefit },
                |m: &mut MdlAdagradLightParameters| { &mut m.min_servable_mdl_benefit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mdl_mix_in_margin",
                |m: &MdlAdagradLightParameters| { &m.mdl_mix_in_margin },
                |m: &mut MdlAdagradLightParameters| { &mut m.mdl_mix_in_margin },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mdl_benefit_rampup_coeff",
                |m: &MdlAdagradLightParameters| { &m.mdl_benefit_rampup_coeff },
                |m: &mut MdlAdagradLightParameters| { &mut m.mdl_benefit_rampup_coeff },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mdl_min_weight",
                |m: &MdlAdagradLightParameters| { &m.mdl_min_weight },
                |m: &mut MdlAdagradLightParameters| { &mut m.mdl_min_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "benefit_revisit_scale",
                |m: &MdlAdagradLightParameters| { &m.benefit_revisit_scale },
                |m: &mut MdlAdagradLightParameters| { &mut m.benefit_revisit_scale },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_event_benefit",
                |m: &MdlAdagradLightParameters| { &m.max_event_benefit },
                |m: &mut MdlAdagradLightParameters| { &mut m.max_event_benefit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "max_total_benefit",
                |m: &MdlAdagradLightParameters| { &m.max_total_benefit },
                |m: &mut MdlAdagradLightParameters| { &mut m.max_total_benefit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "mdl_hard_limit",
                |m: &MdlAdagradLightParameters| { &m.mdl_hard_limit },
                |m: &mut MdlAdagradLightParameters| { &mut m.mdl_hard_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hard_limit_min_benefit",
                |m: &MdlAdagradLightParameters| { &m.hard_limit_min_benefit },
                |m: &mut MdlAdagradLightParameters| { &mut m.hard_limit_min_benefit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "mdl_regularize",
                |m: &MdlAdagradLightParameters| { &m.mdl_regularize },
                |m: &mut MdlAdagradLightParameters| { &mut m.mdl_regularize },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_accumulator",
                |m: &MdlAdagradLightParameters| { &m.initial_accumulator },
                |m: &mut MdlAdagradLightParameters| { &mut m.initial_accumulator },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_weight",
                |m: &MdlAdagradLightParameters| { &m.initial_weight },
                |m: &mut MdlAdagradLightParameters| { &mut m.initial_weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_benefit",
                |m: &MdlAdagradLightParameters| { &m.initial_benefit },
                |m: &mut MdlAdagradLightParameters| { &mut m.initial_benefit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MdlAdagradLightParameters>(
                "MdlAdagradLightParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MdlAdagradLightParameters {
        static instance: ::protobuf::rt::LazyV2<MdlAdagradLightParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MdlAdagradLightParameters::new)
    }
}

impl ::protobuf::Clear for MdlAdagradLightParameters {
    fn clear(&mut self) {
        self.l2 = 0.;
        self.lr_power = 0.;
        self.min_servable_mdl_benefit = 0.;
        self.mdl_mix_in_margin = 0.;
        self.mdl_benefit_rampup_coeff = 0.;
        self.mdl_min_weight = 0.;
        self.benefit_revisit_scale = 0.;
        self.max_event_benefit = 0.;
        self.max_total_benefit = 0.;
        self.mdl_hard_limit = 0.;
        self.hard_limit_min_benefit = false;
        self.mdl_regularize = false;
        self.initial_accumulator = 0.;
        self.initial_weight = 0.;
        self.initial_benefit = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MdlAdagradLightParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MdlAdagradLightParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AdadeltaParameters {
    // message fields
    pub rho: f32,
    pub epsilon: f32,
    pub initial_accumulator: f32,
    pub initial_update: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AdadeltaParameters {
    fn default() -> &'a AdadeltaParameters {
        <AdadeltaParameters as ::protobuf::Message>::default_instance()
    }
}

impl AdadeltaParameters {
    pub fn new() -> AdadeltaParameters {
        ::std::default::Default::default()
    }

    // float rho = 1;


    pub fn get_rho(&self) -> f32 {
        self.rho
    }
    pub fn clear_rho(&mut self) {
        self.rho = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rho(&mut self, v: f32) {
        self.rho = v;
    }

    // float epsilon = 2;


    pub fn get_epsilon(&self) -> f32 {
        self.epsilon
    }
    pub fn clear_epsilon(&mut self) {
        self.epsilon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_epsilon(&mut self, v: f32) {
        self.epsilon = v;
    }

    // float initial_accumulator = 3;


    pub fn get_initial_accumulator(&self) -> f32 {
        self.initial_accumulator
    }
    pub fn clear_initial_accumulator(&mut self) {
        self.initial_accumulator = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_accumulator(&mut self, v: f32) {
        self.initial_accumulator = v;
    }

    // float initial_update = 4;


    pub fn get_initial_update(&self) -> f32 {
        self.initial_update
    }
    pub fn clear_initial_update(&mut self) {
        self.initial_update = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_update(&mut self, v: f32) {
        self.initial_update = v;
    }
}

impl ::protobuf::Message for AdadeltaParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.rho = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.epsilon = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_accumulator = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_update = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rho != 0. {
            my_size += 5;
        }
        if self.epsilon != 0. {
            my_size += 5;
        }
        if self.initial_accumulator != 0. {
            my_size += 5;
        }
        if self.initial_update != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rho != 0. {
            os.write_float(1, self.rho)?;
        }
        if self.epsilon != 0. {
            os.write_float(2, self.epsilon)?;
        }
        if self.initial_accumulator != 0. {
            os.write_float(3, self.initial_accumulator)?;
        }
        if self.initial_update != 0. {
            os.write_float(4, self.initial_update)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AdadeltaParameters {
        AdadeltaParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "rho",
                |m: &AdadeltaParameters| { &m.rho },
                |m: &mut AdadeltaParameters| { &mut m.rho },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "epsilon",
                |m: &AdadeltaParameters| { &m.epsilon },
                |m: &mut AdadeltaParameters| { &mut m.epsilon },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_accumulator",
                |m: &AdadeltaParameters| { &m.initial_accumulator },
                |m: &mut AdadeltaParameters| { &mut m.initial_accumulator },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_update",
                |m: &AdadeltaParameters| { &m.initial_update },
                |m: &mut AdadeltaParameters| { &mut m.initial_update },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AdadeltaParameters>(
                "AdadeltaParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AdadeltaParameters {
        static instance: ::protobuf::rt::LazyV2<AdadeltaParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AdadeltaParameters::new)
    }
}

impl ::protobuf::Clear for AdadeltaParameters {
    fn clear(&mut self) {
        self.rho = 0.;
        self.epsilon = 0.;
        self.initial_accumulator = 0.;
        self.initial_update = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AdadeltaParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AdadeltaParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProximalAdagradParameters {
    // message fields
    pub l1: f32,
    pub l2: f32,
    pub initial_accumulator: f32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProximalAdagradParameters {
    fn default() -> &'a ProximalAdagradParameters {
        <ProximalAdagradParameters as ::protobuf::Message>::default_instance()
    }
}

impl ProximalAdagradParameters {
    pub fn new() -> ProximalAdagradParameters {
        ::std::default::Default::default()
    }

    // float l1 = 1;


    pub fn get_l1(&self) -> f32 {
        self.l1
    }
    pub fn clear_l1(&mut self) {
        self.l1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_l1(&mut self, v: f32) {
        self.l1 = v;
    }

    // float l2 = 2;


    pub fn get_l2(&self) -> f32 {
        self.l2
    }
    pub fn clear_l2(&mut self) {
        self.l2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_l2(&mut self, v: f32) {
        self.l2 = v;
    }

    // float initial_accumulator = 3;


    pub fn get_initial_accumulator(&self) -> f32 {
        self.initial_accumulator
    }
    pub fn clear_initial_accumulator(&mut self) {
        self.initial_accumulator = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_accumulator(&mut self, v: f32) {
        self.initial_accumulator = v;
    }
}

impl ::protobuf::Message for ProximalAdagradParameters {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.l1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.l2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_accumulator = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.l1 != 0. {
            my_size += 5;
        }
        if self.l2 != 0. {
            my_size += 5;
        }
        if self.initial_accumulator != 0. {
            my_size += 5;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.l1 != 0. {
            os.write_float(1, self.l1)?;
        }
        if self.l2 != 0. {
            os.write_float(2, self.l2)?;
        }
        if self.initial_accumulator != 0. {
            os.write_float(3, self.initial_accumulator)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProximalAdagradParameters {
        ProximalAdagradParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "l1",
                |m: &ProximalAdagradParameters| { &m.l1 },
                |m: &mut ProximalAdagradParameters| { &mut m.l1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "l2",
                |m: &ProximalAdagradParameters| { &m.l2 },
                |m: &mut ProximalAdagradParameters| { &mut m.l2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_accumulator",
                |m: &ProximalAdagradParameters| { &m.initial_accumulator },
                |m: &mut ProximalAdagradParameters| { &mut m.initial_accumulator },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProximalAdagradParameters>(
                "ProximalAdagradParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProximalAdagradParameters {
        static instance: ::protobuf::rt::LazyV2<ProximalAdagradParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProximalAdagradParameters::new)
    }
}

impl ::protobuf::Clear for ProximalAdagradParameters {
    fn clear(&mut self) {
        self.l1 = 0.;
        self.l2 = 0.;
        self.initial_accumulator = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProximalAdagradParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProximalAdagradParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnlineYogiParameters {
    // message fields
    pub l1: f32,
    pub l2: f32,
    pub beta2: f32,
    pub initial_v: f32,
    pub initial_linear: f32,
    // message oneof groups
    pub activation: ::std::option::Option<OnlineYogiParameters_oneof_activation>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnlineYogiParameters {
    fn default() -> &'a OnlineYogiParameters {
        <OnlineYogiParameters as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OnlineYogiParameters_oneof_activation {
    sign(OnlineYogiParameters_SignActivation),
    tanh(OnlineYogiParameters_TanhActivation),
}

impl OnlineYogiParameters {
    pub fn new() -> OnlineYogiParameters {
        ::std::default::Default::default()
    }

    // float l1 = 1;


    pub fn get_l1(&self) -> f32 {
        self.l1
    }
    pub fn clear_l1(&mut self) {
        self.l1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_l1(&mut self, v: f32) {
        self.l1 = v;
    }

    // float l2 = 2;


    pub fn get_l2(&self) -> f32 {
        self.l2
    }
    pub fn clear_l2(&mut self) {
        self.l2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_l2(&mut self, v: f32) {
        self.l2 = v;
    }

    // float beta2 = 3;


    pub fn get_beta2(&self) -> f32 {
        self.beta2
    }
    pub fn clear_beta2(&mut self) {
        self.beta2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_beta2(&mut self, v: f32) {
        self.beta2 = v;
    }

    // float initial_v = 4;


    pub fn get_initial_v(&self) -> f32 {
        self.initial_v
    }
    pub fn clear_initial_v(&mut self) {
        self.initial_v = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_v(&mut self, v: f32) {
        self.initial_v = v;
    }

    // float initial_linear = 5;


    pub fn get_initial_linear(&self) -> f32 {
        self.initial_linear
    }
    pub fn clear_initial_linear(&mut self) {
        self.initial_linear = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_linear(&mut self, v: f32) {
        self.initial_linear = v;
    }

    // .tensorflow.tpu.OnlineYogiParameters.SignActivation sign = 6;


    pub fn get_sign(&self) -> &OnlineYogiParameters_SignActivation {
        match self.activation {
            ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(ref v)) => v,
            _ => <OnlineYogiParameters_SignActivation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sign(&mut self) {
        self.activation = ::std::option::Option::None;
    }

    pub fn has_sign(&self) -> bool {
        match self.activation {
            ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sign(&mut self, v: OnlineYogiParameters_SignActivation) {
        self.activation = ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sign(&mut self) -> &mut OnlineYogiParameters_SignActivation {
        if let ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(_)) = self.activation {
        } else {
            self.activation = ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(OnlineYogiParameters_SignActivation::new()));
        }
        match self.activation {
            ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sign(&mut self) -> OnlineYogiParameters_SignActivation {
        if self.has_sign() {
            match self.activation.take() {
                ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(v)) => v,
                _ => panic!(),
            }
        } else {
            OnlineYogiParameters_SignActivation::new()
        }
    }

    // .tensorflow.tpu.OnlineYogiParameters.TanhActivation tanh = 7;


    pub fn get_tanh(&self) -> &OnlineYogiParameters_TanhActivation {
        match self.activation {
            ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(ref v)) => v,
            _ => <OnlineYogiParameters_TanhActivation as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_tanh(&mut self) {
        self.activation = ::std::option::Option::None;
    }

    pub fn has_tanh(&self) -> bool {
        match self.activation {
            ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tanh(&mut self, v: OnlineYogiParameters_TanhActivation) {
        self.activation = ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tanh(&mut self) -> &mut OnlineYogiParameters_TanhActivation {
        if let ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(_)) = self.activation {
        } else {
            self.activation = ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(OnlineYogiParameters_TanhActivation::new()));
        }
        match self.activation {
            ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tanh(&mut self) -> OnlineYogiParameters_TanhActivation {
        if self.has_tanh() {
            match self.activation.take() {
                ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(v)) => v,
                _ => panic!(),
            }
        } else {
            OnlineYogiParameters_TanhActivation::new()
        }
    }
}

impl ::protobuf::Message for OnlineYogiParameters {
    fn is_initialized(&self) -> bool {
        if let Some(OnlineYogiParameters_oneof_activation::sign(ref v)) = self.activation {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OnlineYogiParameters_oneof_activation::tanh(ref v)) = self.activation {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.l1 = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.l2 = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.beta2 = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_v = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.initial_linear = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.activation = ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::sign(is.read_message()?));
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.activation = ::std::option::Option::Some(OnlineYogiParameters_oneof_activation::tanh(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.l1 != 0. {
            my_size += 5;
        }
        if self.l2 != 0. {
            my_size += 5;
        }
        if self.beta2 != 0. {
            my_size += 5;
        }
        if self.initial_v != 0. {
            my_size += 5;
        }
        if self.initial_linear != 0. {
            my_size += 5;
        }
        if let ::std::option::Option::Some(ref v) = self.activation {
            match v {
                &OnlineYogiParameters_oneof_activation::sign(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OnlineYogiParameters_oneof_activation::tanh(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.l1 != 0. {
            os.write_float(1, self.l1)?;
        }
        if self.l2 != 0. {
            os.write_float(2, self.l2)?;
        }
        if self.beta2 != 0. {
            os.write_float(3, self.beta2)?;
        }
        if self.initial_v != 0. {
            os.write_float(4, self.initial_v)?;
        }
        if self.initial_linear != 0. {
            os.write_float(5, self.initial_linear)?;
        }
        if let ::std::option::Option::Some(ref v) = self.activation {
            match v {
                &OnlineYogiParameters_oneof_activation::sign(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OnlineYogiParameters_oneof_activation::tanh(ref v) => {
                    os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnlineYogiParameters {
        OnlineYogiParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "l1",
                |m: &OnlineYogiParameters| { &m.l1 },
                |m: &mut OnlineYogiParameters| { &mut m.l1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "l2",
                |m: &OnlineYogiParameters| { &m.l2 },
                |m: &mut OnlineYogiParameters| { &mut m.l2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "beta2",
                |m: &OnlineYogiParameters| { &m.beta2 },
                |m: &mut OnlineYogiParameters| { &mut m.beta2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_v",
                |m: &OnlineYogiParameters| { &m.initial_v },
                |m: &mut OnlineYogiParameters| { &mut m.initial_v },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "initial_linear",
                |m: &OnlineYogiParameters| { &m.initial_linear },
                |m: &mut OnlineYogiParameters| { &mut m.initial_linear },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OnlineYogiParameters_SignActivation>(
                "sign",
                OnlineYogiParameters::has_sign,
                OnlineYogiParameters::get_sign,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OnlineYogiParameters_TanhActivation>(
                "tanh",
                OnlineYogiParameters::has_tanh,
                OnlineYogiParameters::get_tanh,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnlineYogiParameters>(
                "OnlineYogiParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OnlineYogiParameters {
        static instance: ::protobuf::rt::LazyV2<OnlineYogiParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OnlineYogiParameters::new)
    }
}

impl ::protobuf::Clear for OnlineYogiParameters {
    fn clear(&mut self) {
        self.l1 = 0.;
        self.l2 = 0.;
        self.beta2 = 0.;
        self.initial_v = 0.;
        self.initial_linear = 0.;
        self.activation = ::std::option::Option::None;
        self.activation = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnlineYogiParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineYogiParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnlineYogiParameters_SignActivation {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnlineYogiParameters_SignActivation {
    fn default() -> &'a OnlineYogiParameters_SignActivation {
        <OnlineYogiParameters_SignActivation as ::protobuf::Message>::default_instance()
    }
}

impl OnlineYogiParameters_SignActivation {
    pub fn new() -> OnlineYogiParameters_SignActivation {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OnlineYogiParameters_SignActivation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnlineYogiParameters_SignActivation {
        OnlineYogiParameters_SignActivation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnlineYogiParameters_SignActivation>(
                "OnlineYogiParameters.SignActivation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OnlineYogiParameters_SignActivation {
        static instance: ::protobuf::rt::LazyV2<OnlineYogiParameters_SignActivation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OnlineYogiParameters_SignActivation::new)
    }
}

impl ::protobuf::Clear for OnlineYogiParameters_SignActivation {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnlineYogiParameters_SignActivation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineYogiParameters_SignActivation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OnlineYogiParameters_TanhActivation {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OnlineYogiParameters_TanhActivation {
    fn default() -> &'a OnlineYogiParameters_TanhActivation {
        <OnlineYogiParameters_TanhActivation as ::protobuf::Message>::default_instance()
    }
}

impl OnlineYogiParameters_TanhActivation {
    pub fn new() -> OnlineYogiParameters_TanhActivation {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for OnlineYogiParameters_TanhActivation {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OnlineYogiParameters_TanhActivation {
        OnlineYogiParameters_TanhActivation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OnlineYogiParameters_TanhActivation>(
                "OnlineYogiParameters.TanhActivation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OnlineYogiParameters_TanhActivation {
        static instance: ::protobuf::rt::LazyV2<OnlineYogiParameters_TanhActivation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OnlineYogiParameters_TanhActivation::new)
    }
}

impl ::protobuf::Clear for OnlineYogiParameters_TanhActivation {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OnlineYogiParameters_TanhActivation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OnlineYogiParameters_TanhActivation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GradientAccumulationStatus {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GradientAccumulationStatus {
    fn default() -> &'a GradientAccumulationStatus {
        <GradientAccumulationStatus as ::protobuf::Message>::default_instance()
    }
}

impl GradientAccumulationStatus {
    pub fn new() -> GradientAccumulationStatus {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GradientAccumulationStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GradientAccumulationStatus {
        GradientAccumulationStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GradientAccumulationStatus>(
                "GradientAccumulationStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GradientAccumulationStatus {
        static instance: ::protobuf::rt::LazyV2<GradientAccumulationStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GradientAccumulationStatus::new)
    }
}

impl ::protobuf::Clear for GradientAccumulationStatus {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GradientAccumulationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GradientAccumulationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum GradientAccumulationStatus_Status {
    UNSPECIFIED = 0,
    ENABLED = 1,
    DISABLED = 2,
}

impl ::protobuf::ProtobufEnum for GradientAccumulationStatus_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<GradientAccumulationStatus_Status> {
        match value {
            0 => ::std::option::Option::Some(GradientAccumulationStatus_Status::UNSPECIFIED),
            1 => ::std::option::Option::Some(GradientAccumulationStatus_Status::ENABLED),
            2 => ::std::option::Option::Some(GradientAccumulationStatus_Status::DISABLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [GradientAccumulationStatus_Status] = &[
            GradientAccumulationStatus_Status::UNSPECIFIED,
            GradientAccumulationStatus_Status::ENABLED,
            GradientAccumulationStatus_Status::DISABLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<GradientAccumulationStatus_Status>("GradientAccumulationStatus.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for GradientAccumulationStatus_Status {
}

impl ::std::default::Default for GradientAccumulationStatus_Status {
    fn default() -> Self {
        GradientAccumulationStatus_Status::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for GradientAccumulationStatus_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HotIdReplicationConfiguration {
    // message fields
    pub status: HotIdReplicationConfiguration_Status,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HotIdReplicationConfiguration {
    fn default() -> &'a HotIdReplicationConfiguration {
        <HotIdReplicationConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl HotIdReplicationConfiguration {
    pub fn new() -> HotIdReplicationConfiguration {
        ::std::default::Default::default()
    }

    // .tensorflow.tpu.HotIdReplicationConfiguration.Status status = 1;


    pub fn get_status(&self) -> HotIdReplicationConfiguration_Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = HotIdReplicationConfiguration_Status::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: HotIdReplicationConfiguration_Status) {
        self.status = v;
    }
}

impl ::protobuf::Message for HotIdReplicationConfiguration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != HotIdReplicationConfiguration_Status::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != HotIdReplicationConfiguration_Status::UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HotIdReplicationConfiguration {
        HotIdReplicationConfiguration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HotIdReplicationConfiguration_Status>>(
                "status",
                |m: &HotIdReplicationConfiguration| { &m.status },
                |m: &mut HotIdReplicationConfiguration| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HotIdReplicationConfiguration>(
                "HotIdReplicationConfiguration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HotIdReplicationConfiguration {
        static instance: ::protobuf::rt::LazyV2<HotIdReplicationConfiguration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HotIdReplicationConfiguration::new)
    }
}

impl ::protobuf::Clear for HotIdReplicationConfiguration {
    fn clear(&mut self) {
        self.status = HotIdReplicationConfiguration_Status::UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HotIdReplicationConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HotIdReplicationConfiguration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HotIdReplicationConfiguration_Status {
    UNSPECIFIED = 0,
    ENABLED = 1,
    DISABLED = 2,
}

impl ::protobuf::ProtobufEnum for HotIdReplicationConfiguration_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HotIdReplicationConfiguration_Status> {
        match value {
            0 => ::std::option::Option::Some(HotIdReplicationConfiguration_Status::UNSPECIFIED),
            1 => ::std::option::Option::Some(HotIdReplicationConfiguration_Status::ENABLED),
            2 => ::std::option::Option::Some(HotIdReplicationConfiguration_Status::DISABLED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HotIdReplicationConfiguration_Status] = &[
            HotIdReplicationConfiguration_Status::UNSPECIFIED,
            HotIdReplicationConfiguration_Status::ENABLED,
            HotIdReplicationConfiguration_Status::DISABLED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HotIdReplicationConfiguration_Status>("HotIdReplicationConfiguration.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HotIdReplicationConfiguration_Status {
}

impl ::std::default::Default for HotIdReplicationConfiguration_Status {
    fn default() -> Self {
        HotIdReplicationConfiguration_Status::UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for HotIdReplicationConfiguration_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OptimizationParameters {
    // message fields
    pub learning_rate: ::protobuf::SingularPtrField<LearningRate>,
    pub clipping_limits: ::protobuf::SingularPtrField<ClippingLimits>,
    pub gradient_clipping_limits: ::protobuf::SingularPtrField<ClippingLimits>,
    pub weight_decay_factor: f32,
    pub gradient_accumulation_status: GradientAccumulationStatus_Status,
    pub hot_id_replication_configuration: ::protobuf::SingularPtrField<HotIdReplicationConfiguration>,
    // message oneof groups
    pub parameters: ::std::option::Option<OptimizationParameters_oneof_parameters>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OptimizationParameters {
    fn default() -> &'a OptimizationParameters {
        <OptimizationParameters as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OptimizationParameters_oneof_parameters {
    adagrad(AdagradParameters),
    bounded_adagrad(BoundedAdagradParameters),
    stochastic_gradient_descent(StochasticGradientDescentParameters),
    ftrl(FtrlParameters),
    adam(AdamParameters),
    momentum(MomentumParameters),
    rms_prop(RmsPropParameters),
    centered_rms_prop(CenteredRmsPropParameters),
    mdl_adagrad_light(MdlAdagradLightParameters),
    adadelta(AdadeltaParameters),
    proximal_adagrad(ProximalAdagradParameters),
    online_yogi(OnlineYogiParameters),
}

impl OptimizationParameters {
    pub fn new() -> OptimizationParameters {
        ::std::default::Default::default()
    }

    // .tensorflow.tpu.LearningRate learning_rate = 13;


    pub fn get_learning_rate(&self) -> &LearningRate {
        self.learning_rate.as_ref().unwrap_or_else(|| <LearningRate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_learning_rate(&mut self) {
        self.learning_rate.clear();
    }

    pub fn has_learning_rate(&self) -> bool {
        self.learning_rate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_learning_rate(&mut self, v: LearningRate) {
        self.learning_rate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_learning_rate(&mut self) -> &mut LearningRate {
        if self.learning_rate.is_none() {
            self.learning_rate.set_default();
        }
        self.learning_rate.as_mut().unwrap()
    }

    // Take field
    pub fn take_learning_rate(&mut self) -> LearningRate {
        self.learning_rate.take().unwrap_or_else(|| LearningRate::new())
    }

    // .tensorflow.tpu.ClippingLimits clipping_limits = 2;


    pub fn get_clipping_limits(&self) -> &ClippingLimits {
        self.clipping_limits.as_ref().unwrap_or_else(|| <ClippingLimits as ::protobuf::Message>::default_instance())
    }
    pub fn clear_clipping_limits(&mut self) {
        self.clipping_limits.clear();
    }

    pub fn has_clipping_limits(&self) -> bool {
        self.clipping_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clipping_limits(&mut self, v: ClippingLimits) {
        self.clipping_limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clipping_limits(&mut self) -> &mut ClippingLimits {
        if self.clipping_limits.is_none() {
            self.clipping_limits.set_default();
        }
        self.clipping_limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_clipping_limits(&mut self) -> ClippingLimits {
        self.clipping_limits.take().unwrap_or_else(|| ClippingLimits::new())
    }

    // .tensorflow.tpu.ClippingLimits gradient_clipping_limits = 7;


    pub fn get_gradient_clipping_limits(&self) -> &ClippingLimits {
        self.gradient_clipping_limits.as_ref().unwrap_or_else(|| <ClippingLimits as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gradient_clipping_limits(&mut self) {
        self.gradient_clipping_limits.clear();
    }

    pub fn has_gradient_clipping_limits(&self) -> bool {
        self.gradient_clipping_limits.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gradient_clipping_limits(&mut self, v: ClippingLimits) {
        self.gradient_clipping_limits = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gradient_clipping_limits(&mut self) -> &mut ClippingLimits {
        if self.gradient_clipping_limits.is_none() {
            self.gradient_clipping_limits.set_default();
        }
        self.gradient_clipping_limits.as_mut().unwrap()
    }

    // Take field
    pub fn take_gradient_clipping_limits(&mut self) -> ClippingLimits {
        self.gradient_clipping_limits.take().unwrap_or_else(|| ClippingLimits::new())
    }

    // float weight_decay_factor = 16;


    pub fn get_weight_decay_factor(&self) -> f32 {
        self.weight_decay_factor
    }
    pub fn clear_weight_decay_factor(&mut self) {
        self.weight_decay_factor = 0.;
    }

    // Param is passed by value, moved
    pub fn set_weight_decay_factor(&mut self, v: f32) {
        self.weight_decay_factor = v;
    }

    // .tensorflow.tpu.GradientAccumulationStatus.Status gradient_accumulation_status = 17;


    pub fn get_gradient_accumulation_status(&self) -> GradientAccumulationStatus_Status {
        self.gradient_accumulation_status
    }
    pub fn clear_gradient_accumulation_status(&mut self) {
        self.gradient_accumulation_status = GradientAccumulationStatus_Status::UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_gradient_accumulation_status(&mut self, v: GradientAccumulationStatus_Status) {
        self.gradient_accumulation_status = v;
    }

    // .tensorflow.tpu.HotIdReplicationConfiguration hot_id_replication_configuration = 18;


    pub fn get_hot_id_replication_configuration(&self) -> &HotIdReplicationConfiguration {
        self.hot_id_replication_configuration.as_ref().unwrap_or_else(|| <HotIdReplicationConfiguration as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hot_id_replication_configuration(&mut self) {
        self.hot_id_replication_configuration.clear();
    }

    pub fn has_hot_id_replication_configuration(&self) -> bool {
        self.hot_id_replication_configuration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hot_id_replication_configuration(&mut self, v: HotIdReplicationConfiguration) {
        self.hot_id_replication_configuration = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hot_id_replication_configuration(&mut self) -> &mut HotIdReplicationConfiguration {
        if self.hot_id_replication_configuration.is_none() {
            self.hot_id_replication_configuration.set_default();
        }
        self.hot_id_replication_configuration.as_mut().unwrap()
    }

    // Take field
    pub fn take_hot_id_replication_configuration(&mut self) -> HotIdReplicationConfiguration {
        self.hot_id_replication_configuration.take().unwrap_or_else(|| HotIdReplicationConfiguration::new())
    }

    // .tensorflow.tpu.AdagradParameters adagrad = 3;


    pub fn get_adagrad(&self) -> &AdagradParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(ref v)) => v,
            _ => <AdagradParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_adagrad(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_adagrad(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_adagrad(&mut self, v: AdagradParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_adagrad(&mut self) -> &mut AdagradParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(AdagradParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_adagrad(&mut self) -> AdagradParameters {
        if self.has_adagrad() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(v)) => v,
                _ => panic!(),
            }
        } else {
            AdagradParameters::new()
        }
    }

    // .tensorflow.tpu.BoundedAdagradParameters bounded_adagrad = 19;


    pub fn get_bounded_adagrad(&self) -> &BoundedAdagradParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(ref v)) => v,
            _ => <BoundedAdagradParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bounded_adagrad(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_bounded_adagrad(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bounded_adagrad(&mut self, v: BoundedAdagradParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bounded_adagrad(&mut self) -> &mut BoundedAdagradParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(BoundedAdagradParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bounded_adagrad(&mut self) -> BoundedAdagradParameters {
        if self.has_bounded_adagrad() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(v)) => v,
                _ => panic!(),
            }
        } else {
            BoundedAdagradParameters::new()
        }
    }

    // .tensorflow.tpu.StochasticGradientDescentParameters stochastic_gradient_descent = 4;


    pub fn get_stochastic_gradient_descent(&self) -> &StochasticGradientDescentParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(ref v)) => v,
            _ => <StochasticGradientDescentParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_stochastic_gradient_descent(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_stochastic_gradient_descent(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_stochastic_gradient_descent(&mut self, v: StochasticGradientDescentParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(v))
    }

    // Mutable pointer to the field.
    pub fn mut_stochastic_gradient_descent(&mut self) -> &mut StochasticGradientDescentParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(StochasticGradientDescentParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_stochastic_gradient_descent(&mut self) -> StochasticGradientDescentParameters {
        if self.has_stochastic_gradient_descent() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(v)) => v,
                _ => panic!(),
            }
        } else {
            StochasticGradientDescentParameters::new()
        }
    }

    // .tensorflow.tpu.FtrlParameters ftrl = 5;


    pub fn get_ftrl(&self) -> &FtrlParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(ref v)) => v,
            _ => <FtrlParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_ftrl(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_ftrl(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ftrl(&mut self, v: FtrlParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ftrl(&mut self) -> &mut FtrlParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(FtrlParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ftrl(&mut self) -> FtrlParameters {
        if self.has_ftrl() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(v)) => v,
                _ => panic!(),
            }
        } else {
            FtrlParameters::new()
        }
    }

    // .tensorflow.tpu.AdamParameters adam = 6;


    pub fn get_adam(&self) -> &AdamParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(ref v)) => v,
            _ => <AdamParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_adam(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_adam(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_adam(&mut self, v: AdamParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(v))
    }

    // Mutable pointer to the field.
    pub fn mut_adam(&mut self) -> &mut AdamParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(AdamParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_adam(&mut self) -> AdamParameters {
        if self.has_adam() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(v)) => v,
                _ => panic!(),
            }
        } else {
            AdamParameters::new()
        }
    }

    // .tensorflow.tpu.MomentumParameters momentum = 8;


    pub fn get_momentum(&self) -> &MomentumParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(ref v)) => v,
            _ => <MomentumParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_momentum(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_momentum(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_momentum(&mut self, v: MomentumParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(v))
    }

    // Mutable pointer to the field.
    pub fn mut_momentum(&mut self) -> &mut MomentumParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(MomentumParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_momentum(&mut self) -> MomentumParameters {
        if self.has_momentum() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(v)) => v,
                _ => panic!(),
            }
        } else {
            MomentumParameters::new()
        }
    }

    // .tensorflow.tpu.RmsPropParameters rms_prop = 9;


    pub fn get_rms_prop(&self) -> &RmsPropParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(ref v)) => v,
            _ => <RmsPropParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_rms_prop(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_rms_prop(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_rms_prop(&mut self, v: RmsPropParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_rms_prop(&mut self) -> &mut RmsPropParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(RmsPropParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_rms_prop(&mut self) -> RmsPropParameters {
        if self.has_rms_prop() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(v)) => v,
                _ => panic!(),
            }
        } else {
            RmsPropParameters::new()
        }
    }

    // .tensorflow.tpu.CenteredRmsPropParameters centered_rms_prop = 10;


    pub fn get_centered_rms_prop(&self) -> &CenteredRmsPropParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(ref v)) => v,
            _ => <CenteredRmsPropParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_centered_rms_prop(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_centered_rms_prop(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_centered_rms_prop(&mut self, v: CenteredRmsPropParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(v))
    }

    // Mutable pointer to the field.
    pub fn mut_centered_rms_prop(&mut self) -> &mut CenteredRmsPropParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(CenteredRmsPropParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_centered_rms_prop(&mut self) -> CenteredRmsPropParameters {
        if self.has_centered_rms_prop() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(v)) => v,
                _ => panic!(),
            }
        } else {
            CenteredRmsPropParameters::new()
        }
    }

    // .tensorflow.tpu.MdlAdagradLightParameters mdl_adagrad_light = 11;


    pub fn get_mdl_adagrad_light(&self) -> &MdlAdagradLightParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(ref v)) => v,
            _ => <MdlAdagradLightParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_mdl_adagrad_light(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_mdl_adagrad_light(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_mdl_adagrad_light(&mut self, v: MdlAdagradLightParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(v))
    }

    // Mutable pointer to the field.
    pub fn mut_mdl_adagrad_light(&mut self) -> &mut MdlAdagradLightParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(MdlAdagradLightParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_mdl_adagrad_light(&mut self) -> MdlAdagradLightParameters {
        if self.has_mdl_adagrad_light() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(v)) => v,
                _ => panic!(),
            }
        } else {
            MdlAdagradLightParameters::new()
        }
    }

    // .tensorflow.tpu.AdadeltaParameters adadelta = 12;


    pub fn get_adadelta(&self) -> &AdadeltaParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(ref v)) => v,
            _ => <AdadeltaParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_adadelta(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_adadelta(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_adadelta(&mut self, v: AdadeltaParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(v))
    }

    // Mutable pointer to the field.
    pub fn mut_adadelta(&mut self) -> &mut AdadeltaParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(AdadeltaParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_adadelta(&mut self) -> AdadeltaParameters {
        if self.has_adadelta() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(v)) => v,
                _ => panic!(),
            }
        } else {
            AdadeltaParameters::new()
        }
    }

    // .tensorflow.tpu.ProximalAdagradParameters proximal_adagrad = 14;


    pub fn get_proximal_adagrad(&self) -> &ProximalAdagradParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(ref v)) => v,
            _ => <ProximalAdagradParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_proximal_adagrad(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_proximal_adagrad(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_proximal_adagrad(&mut self, v: ProximalAdagradParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(v))
    }

    // Mutable pointer to the field.
    pub fn mut_proximal_adagrad(&mut self) -> &mut ProximalAdagradParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(ProximalAdagradParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_proximal_adagrad(&mut self) -> ProximalAdagradParameters {
        if self.has_proximal_adagrad() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(v)) => v,
                _ => panic!(),
            }
        } else {
            ProximalAdagradParameters::new()
        }
    }

    // .tensorflow.tpu.OnlineYogiParameters online_yogi = 20;


    pub fn get_online_yogi(&self) -> &OnlineYogiParameters {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(ref v)) => v,
            _ => <OnlineYogiParameters as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_online_yogi(&mut self) {
        self.parameters = ::std::option::Option::None;
    }

    pub fn has_online_yogi(&self) -> bool {
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_online_yogi(&mut self, v: OnlineYogiParameters) {
        self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(v))
    }

    // Mutable pointer to the field.
    pub fn mut_online_yogi(&mut self) -> &mut OnlineYogiParameters {
        if let ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(_)) = self.parameters {
        } else {
            self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(OnlineYogiParameters::new()));
        }
        match self.parameters {
            ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_online_yogi(&mut self) -> OnlineYogiParameters {
        if self.has_online_yogi() {
            match self.parameters.take() {
                ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(v)) => v,
                _ => panic!(),
            }
        } else {
            OnlineYogiParameters::new()
        }
    }
}

impl ::protobuf::Message for OptimizationParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.learning_rate {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.clipping_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gradient_clipping_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hot_id_replication_configuration {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(OptimizationParameters_oneof_parameters::adagrad(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::bounded_adagrad(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::ftrl(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::adam(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::momentum(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::rms_prop(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::centered_rms_prop(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::adadelta(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::proximal_adagrad(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OptimizationParameters_oneof_parameters::online_yogi(ref v)) = self.parameters {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.learning_rate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clipping_limits)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gradient_clipping_limits)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.weight_decay_factor = tmp;
                },
                17 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.gradient_accumulation_status, 17, &mut self.unknown_fields)?
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hot_id_replication_configuration)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adagrad(is.read_message()?));
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::bounded_adagrad(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::stochastic_gradient_descent(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::ftrl(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adam(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::momentum(is.read_message()?));
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::rms_prop(is.read_message()?));
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::centered_rms_prop(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::mdl_adagrad_light(is.read_message()?));
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::adadelta(is.read_message()?));
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::proximal_adagrad(is.read_message()?));
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.parameters = ::std::option::Option::Some(OptimizationParameters_oneof_parameters::online_yogi(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.learning_rate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.clipping_limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gradient_clipping_limits.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.weight_decay_factor != 0. {
            my_size += 6;
        }
        if self.gradient_accumulation_status != GradientAccumulationStatus_Status::UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(17, self.gradient_accumulation_status);
        }
        if let Some(ref v) = self.hot_id_replication_configuration.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.parameters {
            match v {
                &OptimizationParameters_oneof_parameters::adagrad(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::bounded_adagrad(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::stochastic_gradient_descent(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::ftrl(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::adam(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::momentum(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::rms_prop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::centered_rms_prop(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::mdl_adagrad_light(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::adadelta(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::proximal_adagrad(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OptimizationParameters_oneof_parameters::online_yogi(ref v) => {
                    let len = v.compute_size();
                    my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.learning_rate.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.clipping_limits.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gradient_clipping_limits.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.weight_decay_factor != 0. {
            os.write_float(16, self.weight_decay_factor)?;
        }
        if self.gradient_accumulation_status != GradientAccumulationStatus_Status::UNSPECIFIED {
            os.write_enum(17, ::protobuf::ProtobufEnum::value(&self.gradient_accumulation_status))?;
        }
        if let Some(ref v) = self.hot_id_replication_configuration.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.parameters {
            match v {
                &OptimizationParameters_oneof_parameters::adagrad(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::bounded_adagrad(ref v) => {
                    os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::stochastic_gradient_descent(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::ftrl(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::adam(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::momentum(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::rms_prop(ref v) => {
                    os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::centered_rms_prop(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::mdl_adagrad_light(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::adadelta(ref v) => {
                    os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::proximal_adagrad(ref v) => {
                    os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OptimizationParameters_oneof_parameters::online_yogi(ref v) => {
                    os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OptimizationParameters {
        OptimizationParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LearningRate>>(
                "learning_rate",
                |m: &OptimizationParameters| { &m.learning_rate },
                |m: &mut OptimizationParameters| { &mut m.learning_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClippingLimits>>(
                "clipping_limits",
                |m: &OptimizationParameters| { &m.clipping_limits },
                |m: &mut OptimizationParameters| { &mut m.clipping_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClippingLimits>>(
                "gradient_clipping_limits",
                |m: &OptimizationParameters| { &m.gradient_clipping_limits },
                |m: &mut OptimizationParameters| { &mut m.gradient_clipping_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "weight_decay_factor",
                |m: &OptimizationParameters| { &m.weight_decay_factor },
                |m: &mut OptimizationParameters| { &mut m.weight_decay_factor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<GradientAccumulationStatus_Status>>(
                "gradient_accumulation_status",
                |m: &OptimizationParameters| { &m.gradient_accumulation_status },
                |m: &mut OptimizationParameters| { &mut m.gradient_accumulation_status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HotIdReplicationConfiguration>>(
                "hot_id_replication_configuration",
                |m: &OptimizationParameters| { &m.hot_id_replication_configuration },
                |m: &mut OptimizationParameters| { &mut m.hot_id_replication_configuration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AdagradParameters>(
                "adagrad",
                OptimizationParameters::has_adagrad,
                OptimizationParameters::get_adagrad,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BoundedAdagradParameters>(
                "bounded_adagrad",
                OptimizationParameters::has_bounded_adagrad,
                OptimizationParameters::get_bounded_adagrad,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StochasticGradientDescentParameters>(
                "stochastic_gradient_descent",
                OptimizationParameters::has_stochastic_gradient_descent,
                OptimizationParameters::get_stochastic_gradient_descent,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, FtrlParameters>(
                "ftrl",
                OptimizationParameters::has_ftrl,
                OptimizationParameters::get_ftrl,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AdamParameters>(
                "adam",
                OptimizationParameters::has_adam,
                OptimizationParameters::get_adam,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MomentumParameters>(
                "momentum",
                OptimizationParameters::has_momentum,
                OptimizationParameters::get_momentum,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RmsPropParameters>(
                "rms_prop",
                OptimizationParameters::has_rms_prop,
                OptimizationParameters::get_rms_prop,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CenteredRmsPropParameters>(
                "centered_rms_prop",
                OptimizationParameters::has_centered_rms_prop,
                OptimizationParameters::get_centered_rms_prop,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, MdlAdagradLightParameters>(
                "mdl_adagrad_light",
                OptimizationParameters::has_mdl_adagrad_light,
                OptimizationParameters::get_mdl_adagrad_light,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, AdadeltaParameters>(
                "adadelta",
                OptimizationParameters::has_adadelta,
                OptimizationParameters::get_adadelta,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, ProximalAdagradParameters>(
                "proximal_adagrad",
                OptimizationParameters::has_proximal_adagrad,
                OptimizationParameters::get_proximal_adagrad,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, OnlineYogiParameters>(
                "online_yogi",
                OptimizationParameters::has_online_yogi,
                OptimizationParameters::get_online_yogi,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OptimizationParameters>(
                "OptimizationParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OptimizationParameters {
        static instance: ::protobuf::rt::LazyV2<OptimizationParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OptimizationParameters::new)
    }
}

impl ::protobuf::Clear for OptimizationParameters {
    fn clear(&mut self) {
        self.learning_rate.clear();
        self.clipping_limits.clear();
        self.gradient_clipping_limits.clear();
        self.weight_decay_factor = 0.;
        self.gradient_accumulation_status = GradientAccumulationStatus_Status::UNSPECIFIED;
        self.hot_id_replication_configuration.clear();
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.parameters = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OptimizationParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OptimizationParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StateVariableSpecification {
    // message fields
    pub name: ::std::string::String,
    // message oneof groups
    pub usage: ::std::option::Option<StateVariableSpecification_oneof_usage>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StateVariableSpecification {
    fn default() -> &'a StateVariableSpecification {
        <StateVariableSpecification as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum StateVariableSpecification_oneof_usage {
    user_defined(StateVariableSpecification_UserDefined),
    fill_with_constant(StateVariableSpecification_FillWithConstant),
}

impl StateVariableSpecification {
    pub fn new() -> StateVariableSpecification {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .tensorflow.tpu.StateVariableSpecification.UserDefined user_defined = 2;


    pub fn get_user_defined(&self) -> &StateVariableSpecification_UserDefined {
        match self.usage {
            ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(ref v)) => v,
            _ => <StateVariableSpecification_UserDefined as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_user_defined(&mut self) {
        self.usage = ::std::option::Option::None;
    }

    pub fn has_user_defined(&self) -> bool {
        match self.usage {
            ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_user_defined(&mut self, v: StateVariableSpecification_UserDefined) {
        self.usage = ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(v))
    }

    // Mutable pointer to the field.
    pub fn mut_user_defined(&mut self) -> &mut StateVariableSpecification_UserDefined {
        if let ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(_)) = self.usage {
        } else {
            self.usage = ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(StateVariableSpecification_UserDefined::new()));
        }
        match self.usage {
            ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_user_defined(&mut self) -> StateVariableSpecification_UserDefined {
        if self.has_user_defined() {
            match self.usage.take() {
                ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(v)) => v,
                _ => panic!(),
            }
        } else {
            StateVariableSpecification_UserDefined::new()
        }
    }

    // .tensorflow.tpu.StateVariableSpecification.FillWithConstant fill_with_constant = 3;


    pub fn get_fill_with_constant(&self) -> &StateVariableSpecification_FillWithConstant {
        match self.usage {
            ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(ref v)) => v,
            _ => <StateVariableSpecification_FillWithConstant as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_fill_with_constant(&mut self) {
        self.usage = ::std::option::Option::None;
    }

    pub fn has_fill_with_constant(&self) -> bool {
        match self.usage {
            ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_fill_with_constant(&mut self, v: StateVariableSpecification_FillWithConstant) {
        self.usage = ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(v))
    }

    // Mutable pointer to the field.
    pub fn mut_fill_with_constant(&mut self) -> &mut StateVariableSpecification_FillWithConstant {
        if let ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(_)) = self.usage {
        } else {
            self.usage = ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(StateVariableSpecification_FillWithConstant::new()));
        }
        match self.usage {
            ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_fill_with_constant(&mut self) -> StateVariableSpecification_FillWithConstant {
        if self.has_fill_with_constant() {
            match self.usage.take() {
                ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(v)) => v,
                _ => panic!(),
            }
        } else {
            StateVariableSpecification_FillWithConstant::new()
        }
    }
}

impl ::protobuf::Message for StateVariableSpecification {
    fn is_initialized(&self) -> bool {
        if let Some(StateVariableSpecification_oneof_usage::user_defined(ref v)) = self.usage {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(StateVariableSpecification_oneof_usage::fill_with_constant(ref v)) = self.usage {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.usage = ::std::option::Option::Some(StateVariableSpecification_oneof_usage::user_defined(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.usage = ::std::option::Option::Some(StateVariableSpecification_oneof_usage::fill_with_constant(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let ::std::option::Option::Some(ref v) = self.usage {
            match v {
                &StateVariableSpecification_oneof_usage::user_defined(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &StateVariableSpecification_oneof_usage::fill_with_constant(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let ::std::option::Option::Some(ref v) = self.usage {
            match v {
                &StateVariableSpecification_oneof_usage::user_defined(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &StateVariableSpecification_oneof_usage::fill_with_constant(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StateVariableSpecification {
        StateVariableSpecification::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &StateVariableSpecification| { &m.name },
                |m: &mut StateVariableSpecification| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StateVariableSpecification_UserDefined>(
                "user_defined",
                StateVariableSpecification::has_user_defined,
                StateVariableSpecification::get_user_defined,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, StateVariableSpecification_FillWithConstant>(
                "fill_with_constant",
                StateVariableSpecification::has_fill_with_constant,
                StateVariableSpecification::get_fill_with_constant,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StateVariableSpecification>(
                "StateVariableSpecification",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StateVariableSpecification {
        static instance: ::protobuf::rt::LazyV2<StateVariableSpecification> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StateVariableSpecification::new)
    }
}

impl ::protobuf::Clear for StateVariableSpecification {
    fn clear(&mut self) {
        self.name.clear();
        self.usage = ::std::option::Option::None;
        self.usage = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StateVariableSpecification {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateVariableSpecification {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StateVariableSpecification_UserDefined {
    // message fields
    pub padding_initial_value: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StateVariableSpecification_UserDefined {
    fn default() -> &'a StateVariableSpecification_UserDefined {
        <StateVariableSpecification_UserDefined as ::protobuf::Message>::default_instance()
    }
}

impl StateVariableSpecification_UserDefined {
    pub fn new() -> StateVariableSpecification_UserDefined {
        ::std::default::Default::default()
    }

    // double padding_initial_value = 1;


    pub fn get_padding_initial_value(&self) -> f64 {
        self.padding_initial_value
    }
    pub fn clear_padding_initial_value(&mut self) {
        self.padding_initial_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_padding_initial_value(&mut self, v: f64) {
        self.padding_initial_value = v;
    }
}

impl ::protobuf::Message for StateVariableSpecification_UserDefined {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.padding_initial_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.padding_initial_value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.padding_initial_value != 0. {
            os.write_double(1, self.padding_initial_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StateVariableSpecification_UserDefined {
        StateVariableSpecification_UserDefined::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "padding_initial_value",
                |m: &StateVariableSpecification_UserDefined| { &m.padding_initial_value },
                |m: &mut StateVariableSpecification_UserDefined| { &mut m.padding_initial_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StateVariableSpecification_UserDefined>(
                "StateVariableSpecification.UserDefined",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StateVariableSpecification_UserDefined {
        static instance: ::protobuf::rt::LazyV2<StateVariableSpecification_UserDefined> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StateVariableSpecification_UserDefined::new)
    }
}

impl ::protobuf::Clear for StateVariableSpecification_UserDefined {
    fn clear(&mut self) {
        self.padding_initial_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StateVariableSpecification_UserDefined {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateVariableSpecification_UserDefined {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StateVariableSpecification_FillWithConstant {
    // message fields
    pub initial_value: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StateVariableSpecification_FillWithConstant {
    fn default() -> &'a StateVariableSpecification_FillWithConstant {
        <StateVariableSpecification_FillWithConstant as ::protobuf::Message>::default_instance()
    }
}

impl StateVariableSpecification_FillWithConstant {
    pub fn new() -> StateVariableSpecification_FillWithConstant {
        ::std::default::Default::default()
    }

    // double initial_value = 1;


    pub fn get_initial_value(&self) -> f64 {
        self.initial_value
    }
    pub fn clear_initial_value(&mut self) {
        self.initial_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_initial_value(&mut self, v: f64) {
        self.initial_value = v;
    }
}

impl ::protobuf::Message for StateVariableSpecification_FillWithConstant {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.initial_value = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.initial_value != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.initial_value != 0. {
            os.write_double(1, self.initial_value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StateVariableSpecification_FillWithConstant {
        StateVariableSpecification_FillWithConstant::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "initial_value",
                |m: &StateVariableSpecification_FillWithConstant| { &m.initial_value },
                |m: &mut StateVariableSpecification_FillWithConstant| { &mut m.initial_value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StateVariableSpecification_FillWithConstant>(
                "StateVariableSpecification.FillWithConstant",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StateVariableSpecification_FillWithConstant {
        static instance: ::protobuf::rt::LazyV2<StateVariableSpecification_FillWithConstant> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StateVariableSpecification_FillWithConstant::new)
    }
}

impl ::protobuf::Clear for StateVariableSpecification_FillWithConstant {
    fn clear(&mut self) {
        self.initial_value = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StateVariableSpecification_FillWithConstant {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StateVariableSpecification_FillWithConstant {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n:tensorflow/core/protobuf/tpu/optimization_parameters.proto\x12\x0eten\
    sorflow.tpu\x1a\x1egoogle/protobuf/wrappers.proto\"v\n\x0eClippingLimits\
    \x121\n\x05lower\x18\x01\x20\x01(\x0b2\x1b.google.protobuf.FloatValueR\
    \x05lower\x121\n\x05upper\x18\x02\x20\x01(\x0b2\x1b.google.protobuf.Floa\
    tValueR\x05upper\"'\n\x13DynamicLearningRate\x12\x10\n\x03tag\x18\x01\
    \x20\x01(\x05R\x03tag\"~\n\x0cLearningRate\x12\x1c\n\x08constant\x18\x01\
    \x20\x01(\x02H\0R\x08constant\x12?\n\x07dynamic\x18\x02\x20\x01(\x0b2#.t\
    ensorflow.tpu.DynamicLearningRateH\0R\x07dynamicB\x0f\n\rlearning_rate\"\
    D\n\x11AdagradParameters\x12/\n\x13initial_accumulator\x18\x01\x20\x01(\
    \x02R\x12initialAccumulator\"\xa3\x01\n\x18BoundedAdagradParameters\x128\
    \n\x18update_accumulator_first\x18\x01\x20\x01(\x08R\x16updateAccumulato\
    rFirst\x12$\n\x0emax_var_update\x18\x02\x20\x01(\x02R\x0cmaxVarUpdate\
    \x12'\n\x0fmax_accumulator\x18\x03\x20\x01(\x02R\x0emaxAccumulator\"%\n#\
    StochasticGradientDescentParameters\"\x97\x01\n\x0eFtrlParameters\x12\
    \x0e\n\x02l1\x18\x01\x20\x01(\x02R\x02l1\x12\x0e\n\x02l2\x18\x02\x20\x01\
    (\x02R\x02l2\x12\x19\n\x08lr_power\x18\x03\x20\x01(\x02R\x07lrPower\x12#\
    \n\rinitial_accum\x18\x04\x20\x01(\x02R\x0cinitialAccum\x12%\n\x0einitia\
    l_linear\x18\x05\x20\x01(\x02R\rinitialLinear\"\xea\x01\n\x0eAdamParamet\
    ers\x12\x14\n\x05beta1\x18\x03\x20\x01(\x02R\x05beta1\x12\x14\n\x05beta2\
    \x18\x04\x20\x01(\x02R\x05beta2\x12\x18\n\x07epsilon\x18\x05\x20\x01(\
    \x02R\x07epsilon\x12\x1b\n\tinitial_m\x18\x06\x20\x01(\x02R\x08initialM\
    \x12\x1b\n\tinitial_v\x18\x07\x20\x01(\x02R\x08initialV\x12)\n\x11use_no\
    n_lazy_adam\x18\x08\x20\x01(\x08R\x0euseNonLazyAdam\x12-\n\x13use_sum_in\
    side_sqrt\x18\n\x20\x01(\x08R\x10useSumInsideSqrt\"x\n\x12MomentumParame\
    ters\x12\x1a\n\x08momentum\x18\x01\x20\x01(\x02R\x08momentum\x12!\n\x0cu\
    se_nesterov\x18\x02\x20\x01(\x08R\x0buseNesterov\x12#\n\rinitial_accum\
    \x18\x03\x20\x01(\x02R\x0cinitialAccum\"\x9b\x01\n\x11RmsPropParameters\
    \x12\x10\n\x03rho\x18\x01\x20\x01(\x02R\x03rho\x12\x1a\n\x08momentum\x18\
    \x02\x20\x01(\x02R\x08momentum\x12\x18\n\x07epsilon\x18\x03\x20\x01(\x02\
    R\x07epsilon\x12\x1d\n\ninitial_ms\x18\x04\x20\x01(\x02R\tinitialMs\x12\
    \x1f\n\x0binitial_mom\x18\x05\x20\x01(\x02R\ninitialMom\"\xc2\x01\n\x19C\
    enteredRmsPropParameters\x12\x10\n\x03rho\x18\x01\x20\x01(\x02R\x03rho\
    \x12\x1a\n\x08momentum\x18\x02\x20\x01(\x02R\x08momentum\x12\x18\n\x07ep\
    silon\x18\x03\x20\x01(\x02R\x07epsilon\x12\x1d\n\ninitial_ms\x18\x04\x20\
    \x01(\x02R\tinitialMs\x12\x1f\n\x0binitial_mom\x18\x05\x20\x01(\x02R\nin\
    itialMom\x12\x1d\n\ninitial_mg\x18\x06\x20\x01(\x02R\tinitialMg\"\x98\
    \x05\n\x19MdlAdagradLightParameters\x12\x0e\n\x02l2\x18\x01\x20\x01(\x02\
    R\x02l2\x12\x19\n\x08lr_power\x18\x02\x20\x01(\x02R\x07lrPower\x127\n\
    \x18min_servable_mdl_benefit\x18\x03\x20\x01(\x02R\x15minServableMdlBene\
    fit\x12)\n\x11mdl_mix_in_margin\x18\x04\x20\x01(\x02R\x0emdlMixInMargin\
    \x127\n\x18mdl_benefit_rampup_coeff\x18\x05\x20\x01(\x02R\x15mdlBenefitR\
    ampupCoeff\x12$\n\x0emdl_min_weight\x18\x06\x20\x01(\x02R\x0cmdlMinWeigh\
    t\x122\n\x15benefit_revisit_scale\x18\x07\x20\x01(\x02R\x13benefitRevisi\
    tScale\x12*\n\x11max_event_benefit\x18\x08\x20\x01(\x02R\x0fmaxEventBene\
    fit\x12*\n\x11max_total_benefit\x18\t\x20\x01(\x02R\x0fmaxTotalBenefit\
    \x12$\n\x0emdl_hard_limit\x18\n\x20\x01(\x02R\x0cmdlHardLimit\x123\n\x16\
    hard_limit_min_benefit\x18\x0b\x20\x01(\x08R\x13hardLimitMinBenefit\x12%\
    \n\x0emdl_regularize\x18\x0c\x20\x01(\x08R\rmdlRegularize\x12/\n\x13init\
    ial_accumulator\x18\r\x20\x01(\x02R\x12initialAccumulator\x12%\n\x0einit\
    ial_weight\x18\x0e\x20\x01(\x02R\rinitialWeight\x12'\n\x0finitial_benefi\
    t\x18\x0f\x20\x01(\x02R\x0einitialBenefit\"\x98\x01\n\x12AdadeltaParamet\
    ers\x12\x10\n\x03rho\x18\x01\x20\x01(\x02R\x03rho\x12\x18\n\x07epsilon\
    \x18\x02\x20\x01(\x02R\x07epsilon\x12/\n\x13initial_accumulator\x18\x03\
    \x20\x01(\x02R\x12initialAccumulator\x12%\n\x0einitial_update\x18\x04\
    \x20\x01(\x02R\rinitialUpdate\"l\n\x19ProximalAdagradParameters\x12\x0e\
    \n\x02l1\x18\x01\x20\x01(\x02R\x02l1\x12\x0e\n\x02l2\x18\x02\x20\x01(\
    \x02R\x02l2\x12/\n\x13initial_accumulator\x18\x03\x20\x01(\x02R\x12initi\
    alAccumulator\"\xd8\x02\n\x14OnlineYogiParameters\x12\x0e\n\x02l1\x18\
    \x01\x20\x01(\x02R\x02l1\x12\x0e\n\x02l2\x18\x02\x20\x01(\x02R\x02l2\x12\
    \x14\n\x05beta2\x18\x03\x20\x01(\x02R\x05beta2\x12\x1b\n\tinitial_v\x18\
    \x04\x20\x01(\x02R\x08initialV\x12%\n\x0einitial_linear\x18\x05\x20\x01(\
    \x02R\rinitialLinear\x12I\n\x04sign\x18\x06\x20\x01(\x0b23.tensorflow.tp\
    u.OnlineYogiParameters.SignActivationH\0R\x04sign\x12I\n\x04tanh\x18\x07\
    \x20\x01(\x0b23.tensorflow.tpu.OnlineYogiParameters.TanhActivationH\0R\
    \x04tanh\x1a\x10\n\x0eSignActivation\x1a\x10\n\x0eTanhActivationB\x0c\n\
    \nactivation\"R\n\x1aGradientAccumulationStatus\"4\n\x06Status\x12\x0f\n\
    \x0bUNSPECIFIED\x10\0\x12\x0b\n\x07ENABLED\x10\x01\x12\x0c\n\x08DISABLED\
    \x10\x02\"\xa3\x01\n\x1dHotIdReplicationConfiguration\x12L\n\x06status\
    \x18\x01\x20\x01(\x0e24.tensorflow.tpu.HotIdReplicationConfiguration.Sta\
    tusR\x06status\"4\n\x06Status\x12\x0f\n\x0bUNSPECIFIED\x10\0\x12\x0b\n\
    \x07ENABLED\x10\x01\x12\x0c\n\x08DISABLED\x10\x02\"\xc3\x0b\n\x16Optimiz\
    ationParameters\x12A\n\rlearning_rate\x18\r\x20\x01(\x0b2\x1c.tensorflow\
    .tpu.LearningRateR\x0clearningRate\x12G\n\x0fclipping_limits\x18\x02\x20\
    \x01(\x0b2\x1e.tensorflow.tpu.ClippingLimitsR\x0eclippingLimits\x12X\n\
    \x18gradient_clipping_limits\x18\x07\x20\x01(\x0b2\x1e.tensorflow.tpu.Cl\
    ippingLimitsR\x16gradientClippingLimits\x12.\n\x13weight_decay_factor\
    \x18\x10\x20\x01(\x02R\x11weightDecayFactor\x12s\n\x1cgradient_accumulat\
    ion_status\x18\x11\x20\x01(\x0e21.tensorflow.tpu.GradientAccumulationSta\
    tus.StatusR\x1agradientAccumulationStatus\x12v\n\x20hot_id_replication_c\
    onfiguration\x18\x12\x20\x01(\x0b2-.tensorflow.tpu.HotIdReplicationConfi\
    gurationR\x1dhotIdReplicationConfiguration\x12=\n\x07adagrad\x18\x03\x20\
    \x01(\x0b2!.tensorflow.tpu.AdagradParametersH\0R\x07adagrad\x12S\n\x0fbo\
    unded_adagrad\x18\x13\x20\x01(\x0b2(.tensorflow.tpu.BoundedAdagradParame\
    tersH\0R\x0eboundedAdagrad\x12u\n\x1bstochastic_gradient_descent\x18\x04\
    \x20\x01(\x0b23.tensorflow.tpu.StochasticGradientDescentParametersH\0R\
    \x19stochasticGradientDescent\x124\n\x04ftrl\x18\x05\x20\x01(\x0b2\x1e.t\
    ensorflow.tpu.FtrlParametersH\0R\x04ftrl\x124\n\x04adam\x18\x06\x20\x01(\
    \x0b2\x1e.tensorflow.tpu.AdamParametersH\0R\x04adam\x12@\n\x08momentum\
    \x18\x08\x20\x01(\x0b2\".tensorflow.tpu.MomentumParametersH\0R\x08moment\
    um\x12>\n\x08rms_prop\x18\t\x20\x01(\x0b2!.tensorflow.tpu.RmsPropParamet\
    ersH\0R\x07rmsProp\x12W\n\x11centered_rms_prop\x18\n\x20\x01(\x0b2).tens\
    orflow.tpu.CenteredRmsPropParametersH\0R\x0fcenteredRmsProp\x12W\n\x11md\
    l_adagrad_light\x18\x0b\x20\x01(\x0b2).tensorflow.tpu.MdlAdagradLightPar\
    ametersH\0R\x0fmdlAdagradLight\x12@\n\x08adadelta\x18\x0c\x20\x01(\x0b2\
    \".tensorflow.tpu.AdadeltaParametersH\0R\x08adadelta\x12V\n\x10proximal_\
    adagrad\x18\x0e\x20\x01(\x0b2).tensorflow.tpu.ProximalAdagradParametersH\
    \0R\x0fproximalAdagrad\x12G\n\x0bonline_yogi\x18\x14\x20\x01(\x0b2$.tens\
    orflow.tpu.OnlineYogiParametersH\0R\nonlineYogiB\x0c\n\nparametersJ\x04\
    \x08\x01\x10\x02J\x04\x08\x0f\x10\x10\"\xff\x02\n\x1aStateVariableSpecif\
    ication\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12[\n\x0cuser_def\
    ined\x18\x02\x20\x01(\x0b26.tensorflow.tpu.StateVariableSpecification.Us\
    erDefinedH\0R\x0buserDefined\x12k\n\x12fill_with_constant\x18\x03\x20\
    \x01(\x0b2;.tensorflow.tpu.StateVariableSpecification.FillWithConstantH\
    \0R\x10fillWithConstant\x1aA\n\x0bUserDefined\x122\n\x15padding_initial_\
    value\x18\x01\x20\x01(\x01R\x13paddingInitialValue\x1a7\n\x10FillWithCon\
    stant\x12#\n\rinitial_value\x18\x01\x20\x01(\x01R\x0cinitialValueB\x07\n\
    \x05usageb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
