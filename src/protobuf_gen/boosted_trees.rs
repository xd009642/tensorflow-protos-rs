// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/kernels/boosted_trees/boosted_trees.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct Node {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<NodeMetadata>,
    // message oneof groups
    pub node: ::std::option::Option<Node_oneof_node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Node_oneof_node {
    leaf(Leaf),
    bucketized_split(BucketizedSplit),
    categorical_split(CategoricalSplit),
    dense_split(DenseSplit),
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // .tensorflow.boosted_trees.Leaf leaf = 1;


    pub fn get_leaf(&self) -> &Leaf {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::leaf(ref v)) => v,
            _ => <Leaf as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_leaf(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_leaf(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::leaf(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_leaf(&mut self, v: Leaf) {
        self.node = ::std::option::Option::Some(Node_oneof_node::leaf(v))
    }

    // Mutable pointer to the field.
    pub fn mut_leaf(&mut self) -> &mut Leaf {
        if let ::std::option::Option::Some(Node_oneof_node::leaf(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(Node_oneof_node::leaf(Leaf::new()));
        }
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::leaf(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_leaf(&mut self) -> Leaf {
        if self.has_leaf() {
            match self.node.take() {
                ::std::option::Option::Some(Node_oneof_node::leaf(v)) => v,
                _ => panic!(),
            }
        } else {
            Leaf::new()
        }
    }

    // .tensorflow.boosted_trees.BucketizedSplit bucketized_split = 2;


    pub fn get_bucketized_split(&self) -> &BucketizedSplit {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::bucketized_split(ref v)) => v,
            _ => <BucketizedSplit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_bucketized_split(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_bucketized_split(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::bucketized_split(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_bucketized_split(&mut self, v: BucketizedSplit) {
        self.node = ::std::option::Option::Some(Node_oneof_node::bucketized_split(v))
    }

    // Mutable pointer to the field.
    pub fn mut_bucketized_split(&mut self) -> &mut BucketizedSplit {
        if let ::std::option::Option::Some(Node_oneof_node::bucketized_split(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(Node_oneof_node::bucketized_split(BucketizedSplit::new()));
        }
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::bucketized_split(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_bucketized_split(&mut self) -> BucketizedSplit {
        if self.has_bucketized_split() {
            match self.node.take() {
                ::std::option::Option::Some(Node_oneof_node::bucketized_split(v)) => v,
                _ => panic!(),
            }
        } else {
            BucketizedSplit::new()
        }
    }

    // .tensorflow.boosted_trees.CategoricalSplit categorical_split = 3;


    pub fn get_categorical_split(&self) -> &CategoricalSplit {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::categorical_split(ref v)) => v,
            _ => <CategoricalSplit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_categorical_split(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_categorical_split(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::categorical_split(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_categorical_split(&mut self, v: CategoricalSplit) {
        self.node = ::std::option::Option::Some(Node_oneof_node::categorical_split(v))
    }

    // Mutable pointer to the field.
    pub fn mut_categorical_split(&mut self) -> &mut CategoricalSplit {
        if let ::std::option::Option::Some(Node_oneof_node::categorical_split(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(Node_oneof_node::categorical_split(CategoricalSplit::new()));
        }
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::categorical_split(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_categorical_split(&mut self) -> CategoricalSplit {
        if self.has_categorical_split() {
            match self.node.take() {
                ::std::option::Option::Some(Node_oneof_node::categorical_split(v)) => v,
                _ => panic!(),
            }
        } else {
            CategoricalSplit::new()
        }
    }

    // .tensorflow.boosted_trees.DenseSplit dense_split = 4;


    pub fn get_dense_split(&self) -> &DenseSplit {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::dense_split(ref v)) => v,
            _ => <DenseSplit as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_dense_split(&mut self) {
        self.node = ::std::option::Option::None;
    }

    pub fn has_dense_split(&self) -> bool {
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::dense_split(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_dense_split(&mut self, v: DenseSplit) {
        self.node = ::std::option::Option::Some(Node_oneof_node::dense_split(v))
    }

    // Mutable pointer to the field.
    pub fn mut_dense_split(&mut self) -> &mut DenseSplit {
        if let ::std::option::Option::Some(Node_oneof_node::dense_split(_)) = self.node {
        } else {
            self.node = ::std::option::Option::Some(Node_oneof_node::dense_split(DenseSplit::new()));
        }
        match self.node {
            ::std::option::Option::Some(Node_oneof_node::dense_split(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_dense_split(&mut self) -> DenseSplit {
        if self.has_dense_split() {
            match self.node.take() {
                ::std::option::Option::Some(Node_oneof_node::dense_split(v)) => v,
                _ => panic!(),
            }
        } else {
            DenseSplit::new()
        }
    }

    // .tensorflow.boosted_trees.NodeMetadata metadata = 777;


    pub fn get_metadata(&self) -> &NodeMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <NodeMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: NodeMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut NodeMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> NodeMetadata {
        self.metadata.take().unwrap_or_else(|| NodeMetadata::new())
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        if let Some(Node_oneof_node::leaf(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Node_oneof_node::bucketized_split(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Node_oneof_node::categorical_split(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Node_oneof_node::dense_split(ref v)) = self.node {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(Node_oneof_node::leaf(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(Node_oneof_node::bucketized_split(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(Node_oneof_node::categorical_split(is.read_message()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.node = ::std::option::Option::Some(Node_oneof_node::dense_split(is.read_message()?));
                },
                777 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &Node_oneof_node::leaf(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Node_oneof_node::bucketized_split(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Node_oneof_node::categorical_split(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Node_oneof_node::dense_split(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(777, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.node {
            match v {
                &Node_oneof_node::leaf(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Node_oneof_node::bucketized_split(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Node_oneof_node::categorical_split(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Node_oneof_node::dense_split(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Leaf>(
                "leaf",
                Node::has_leaf,
                Node::get_leaf,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, BucketizedSplit>(
                "bucketized_split",
                Node::has_bucketized_split,
                Node::get_bucketized_split,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, CategoricalSplit>(
                "categorical_split",
                Node::has_categorical_split,
                Node::get_categorical_split,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DenseSplit>(
                "dense_split",
                Node::has_dense_split,
                Node::get_dense_split,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeMetadata>>(
                "metadata",
                |m: &Node| { &m.metadata },
                |m: &mut Node| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Node>(
                "Node",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Node {
        static instance: ::protobuf::rt::LazyV2<Node> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Node::new)
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.node = ::std::option::Option::None;
        self.node = ::std::option::Option::None;
        self.node = ::std::option::Option::None;
        self.node = ::std::option::Option::None;
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeMetadata {
    // message fields
    pub gain: f32,
    pub original_leaf: ::protobuf::SingularPtrField<Leaf>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeMetadata {
    fn default() -> &'a NodeMetadata {
        <NodeMetadata as ::protobuf::Message>::default_instance()
    }
}

impl NodeMetadata {
    pub fn new() -> NodeMetadata {
        ::std::default::Default::default()
    }

    // float gain = 1;


    pub fn get_gain(&self) -> f32 {
        self.gain
    }
    pub fn clear_gain(&mut self) {
        self.gain = 0.;
    }

    // Param is passed by value, moved
    pub fn set_gain(&mut self, v: f32) {
        self.gain = v;
    }

    // .tensorflow.boosted_trees.Leaf original_leaf = 2;


    pub fn get_original_leaf(&self) -> &Leaf {
        self.original_leaf.as_ref().unwrap_or_else(|| <Leaf as ::protobuf::Message>::default_instance())
    }
    pub fn clear_original_leaf(&mut self) {
        self.original_leaf.clear();
    }

    pub fn has_original_leaf(&self) -> bool {
        self.original_leaf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_leaf(&mut self, v: Leaf) {
        self.original_leaf = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_leaf(&mut self) -> &mut Leaf {
        if self.original_leaf.is_none() {
            self.original_leaf.set_default();
        }
        self.original_leaf.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_leaf(&mut self) -> Leaf {
        self.original_leaf.take().unwrap_or_else(|| Leaf::new())
    }
}

impl ::protobuf::Message for NodeMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.original_leaf {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.gain = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_leaf)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.gain != 0. {
            my_size += 5;
        }
        if let Some(ref v) = self.original_leaf.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.gain != 0. {
            os.write_float(1, self.gain)?;
        }
        if let Some(ref v) = self.original_leaf.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeMetadata {
        NodeMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "gain",
                |m: &NodeMetadata| { &m.gain },
                |m: &mut NodeMetadata| { &mut m.gain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Leaf>>(
                "original_leaf",
                |m: &NodeMetadata| { &m.original_leaf },
                |m: &mut NodeMetadata| { &mut m.original_leaf },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeMetadata>(
                "NodeMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeMetadata {
        static instance: ::protobuf::rt::LazyV2<NodeMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeMetadata::new)
    }
}

impl ::protobuf::Clear for NodeMetadata {
    fn clear(&mut self) {
        self.gain = 0.;
        self.original_leaf.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Leaf {
    // message fields
    pub scalar: f32,
    // message oneof groups
    pub leaf: ::std::option::Option<Leaf_oneof_leaf>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Leaf {
    fn default() -> &'a Leaf {
        <Leaf as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Leaf_oneof_leaf {
    vector(Vector),
    sparse_vector(SparseVector),
}

impl Leaf {
    pub fn new() -> Leaf {
        ::std::default::Default::default()
    }

    // .tensorflow.boosted_trees.Vector vector = 1;


    pub fn get_vector(&self) -> &Vector {
        match self.leaf {
            ::std::option::Option::Some(Leaf_oneof_leaf::vector(ref v)) => v,
            _ => <Vector as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_vector(&mut self) {
        self.leaf = ::std::option::Option::None;
    }

    pub fn has_vector(&self) -> bool {
        match self.leaf {
            ::std::option::Option::Some(Leaf_oneof_leaf::vector(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_vector(&mut self, v: Vector) {
        self.leaf = ::std::option::Option::Some(Leaf_oneof_leaf::vector(v))
    }

    // Mutable pointer to the field.
    pub fn mut_vector(&mut self) -> &mut Vector {
        if let ::std::option::Option::Some(Leaf_oneof_leaf::vector(_)) = self.leaf {
        } else {
            self.leaf = ::std::option::Option::Some(Leaf_oneof_leaf::vector(Vector::new()));
        }
        match self.leaf {
            ::std::option::Option::Some(Leaf_oneof_leaf::vector(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_vector(&mut self) -> Vector {
        if self.has_vector() {
            match self.leaf.take() {
                ::std::option::Option::Some(Leaf_oneof_leaf::vector(v)) => v,
                _ => panic!(),
            }
        } else {
            Vector::new()
        }
    }

    // .tensorflow.boosted_trees.SparseVector sparse_vector = 2;


    pub fn get_sparse_vector(&self) -> &SparseVector {
        match self.leaf {
            ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(ref v)) => v,
            _ => <SparseVector as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_sparse_vector(&mut self) {
        self.leaf = ::std::option::Option::None;
    }

    pub fn has_sparse_vector(&self) -> bool {
        match self.leaf {
            ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_sparse_vector(&mut self, v: SparseVector) {
        self.leaf = ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(v))
    }

    // Mutable pointer to the field.
    pub fn mut_sparse_vector(&mut self) -> &mut SparseVector {
        if let ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(_)) = self.leaf {
        } else {
            self.leaf = ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(SparseVector::new()));
        }
        match self.leaf {
            ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_sparse_vector(&mut self) -> SparseVector {
        if self.has_sparse_vector() {
            match self.leaf.take() {
                ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(v)) => v,
                _ => panic!(),
            }
        } else {
            SparseVector::new()
        }
    }

    // float scalar = 3;


    pub fn get_scalar(&self) -> f32 {
        self.scalar
    }
    pub fn clear_scalar(&mut self) {
        self.scalar = 0.;
    }

    // Param is passed by value, moved
    pub fn set_scalar(&mut self, v: f32) {
        self.scalar = v;
    }
}

impl ::protobuf::Message for Leaf {
    fn is_initialized(&self) -> bool {
        if let Some(Leaf_oneof_leaf::vector(ref v)) = self.leaf {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Leaf_oneof_leaf::sparse_vector(ref v)) = self.leaf {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaf = ::std::option::Option::Some(Leaf_oneof_leaf::vector(is.read_message()?));
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.leaf = ::std::option::Option::Some(Leaf_oneof_leaf::sparse_vector(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.scalar = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.scalar != 0. {
            my_size += 5;
        }
        if let ::std::option::Option::Some(ref v) = self.leaf {
            match v {
                &Leaf_oneof_leaf::vector(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Leaf_oneof_leaf::sparse_vector(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.scalar != 0. {
            os.write_float(3, self.scalar)?;
        }
        if let ::std::option::Option::Some(ref v) = self.leaf {
            match v {
                &Leaf_oneof_leaf::vector(ref v) => {
                    os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Leaf_oneof_leaf::sparse_vector(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Leaf {
        Leaf::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Vector>(
                "vector",
                Leaf::has_vector,
                Leaf::get_vector,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, SparseVector>(
                "sparse_vector",
                Leaf::has_sparse_vector,
                Leaf::get_sparse_vector,
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "scalar",
                |m: &Leaf| { &m.scalar },
                |m: &mut Leaf| { &mut m.scalar },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Leaf>(
                "Leaf",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Leaf {
        static instance: ::protobuf::rt::LazyV2<Leaf> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Leaf::new)
    }
}

impl ::protobuf::Clear for Leaf {
    fn clear(&mut self) {
        self.leaf = ::std::option::Option::None;
        self.leaf = ::std::option::Option::None;
        self.scalar = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Leaf {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Leaf {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Vector {
    // message fields
    pub value: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Vector {
    fn default() -> &'a Vector {
        <Vector as ::protobuf::Message>::default_instance()
    }
}

impl Vector {
    pub fn new() -> Vector {
        ::std::default::Default::default()
    }

    // repeated float value = 1;


    pub fn get_value(&self) -> &[f32] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<f32>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Vector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 5 * self.value.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_float(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Vector {
        Vector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &Vector| { &m.value },
                |m: &mut Vector| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Vector>(
                "Vector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Vector {
        static instance: ::protobuf::rt::LazyV2<Vector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Vector::new)
    }
}

impl ::protobuf::Clear for Vector {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Vector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Vector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SparseVector {
    // message fields
    pub index: ::std::vec::Vec<i32>,
    pub value: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SparseVector {
    fn default() -> &'a SparseVector {
        <SparseVector as ::protobuf::Message>::default_instance()
    }
}

impl SparseVector {
    pub fn new() -> SparseVector {
        ::std::default::Default::default()
    }

    // repeated int32 index = 1;


    pub fn get_index(&self) -> &[i32] {
        &self.index
    }
    pub fn clear_index(&mut self) {
        self.index.clear();
    }

    // Param is passed by value, moved
    pub fn set_index(&mut self, v: ::std::vec::Vec<i32>) {
        self.index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_index(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.index
    }

    // Take field
    pub fn take_index(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.index, ::std::vec::Vec::new())
    }

    // repeated float value = 2;


    pub fn get_value(&self) -> &[f32] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<f32>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SparseVector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.index)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.index {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 5 * self.value.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.index {
            os.write_int32(1, *v)?;
        };
        for v in &self.value {
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SparseVector {
        SparseVector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "index",
                |m: &SparseVector| { &m.index },
                |m: &mut SparseVector| { &mut m.index },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "value",
                |m: &SparseVector| { &m.value },
                |m: &mut SparseVector| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SparseVector>(
                "SparseVector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SparseVector {
        static instance: ::protobuf::rt::LazyV2<SparseVector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SparseVector::new)
    }
}

impl ::protobuf::Clear for SparseVector {
    fn clear(&mut self) {
        self.index.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SparseVector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SparseVector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BucketizedSplit {
    // message fields
    pub feature_id: i32,
    pub threshold: i32,
    pub dimension_id: i32,
    pub default_direction: DefaultDirection,
    pub left_id: i32,
    pub right_id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BucketizedSplit {
    fn default() -> &'a BucketizedSplit {
        <BucketizedSplit as ::protobuf::Message>::default_instance()
    }
}

impl BucketizedSplit {
    pub fn new() -> BucketizedSplit {
        ::std::default::Default::default()
    }

    // int32 feature_id = 1;


    pub fn get_feature_id(&self) -> i32 {
        self.feature_id
    }
    pub fn clear_feature_id(&mut self) {
        self.feature_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_feature_id(&mut self, v: i32) {
        self.feature_id = v;
    }

    // int32 threshold = 2;


    pub fn get_threshold(&self) -> i32 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: i32) {
        self.threshold = v;
    }

    // int32 dimension_id = 5;


    pub fn get_dimension_id(&self) -> i32 {
        self.dimension_id
    }
    pub fn clear_dimension_id(&mut self) {
        self.dimension_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dimension_id(&mut self, v: i32) {
        self.dimension_id = v;
    }

    // .tensorflow.boosted_trees.DefaultDirection default_direction = 6;


    pub fn get_default_direction(&self) -> DefaultDirection {
        self.default_direction
    }
    pub fn clear_default_direction(&mut self) {
        self.default_direction = DefaultDirection::DEFAULT_LEFT;
    }

    // Param is passed by value, moved
    pub fn set_default_direction(&mut self, v: DefaultDirection) {
        self.default_direction = v;
    }

    // int32 left_id = 3;


    pub fn get_left_id(&self) -> i32 {
        self.left_id
    }
    pub fn clear_left_id(&mut self) {
        self.left_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_left_id(&mut self, v: i32) {
        self.left_id = v;
    }

    // int32 right_id = 4;


    pub fn get_right_id(&self) -> i32 {
        self.right_id
    }
    pub fn clear_right_id(&mut self) {
        self.right_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_right_id(&mut self, v: i32) {
        self.right_id = v;
    }
}

impl ::protobuf::Message for BucketizedSplit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.feature_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.threshold = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dimension_id = tmp;
                },
                6 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.default_direction, 6, &mut self.unknown_fields)?
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.left_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.right_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.feature_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.feature_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.threshold != 0 {
            my_size += ::protobuf::rt::value_size(2, self.threshold, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dimension_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dimension_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.default_direction != DefaultDirection::DEFAULT_LEFT {
            my_size += ::protobuf::rt::enum_size(6, self.default_direction);
        }
        if self.left_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.left_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.right_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.feature_id != 0 {
            os.write_int32(1, self.feature_id)?;
        }
        if self.threshold != 0 {
            os.write_int32(2, self.threshold)?;
        }
        if self.dimension_id != 0 {
            os.write_int32(5, self.dimension_id)?;
        }
        if self.default_direction != DefaultDirection::DEFAULT_LEFT {
            os.write_enum(6, ::protobuf::ProtobufEnum::value(&self.default_direction))?;
        }
        if self.left_id != 0 {
            os.write_int32(3, self.left_id)?;
        }
        if self.right_id != 0 {
            os.write_int32(4, self.right_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BucketizedSplit {
        BucketizedSplit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "feature_id",
                |m: &BucketizedSplit| { &m.feature_id },
                |m: &mut BucketizedSplit| { &mut m.feature_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "threshold",
                |m: &BucketizedSplit| { &m.threshold },
                |m: &mut BucketizedSplit| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dimension_id",
                |m: &BucketizedSplit| { &m.dimension_id },
                |m: &mut BucketizedSplit| { &mut m.dimension_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DefaultDirection>>(
                "default_direction",
                |m: &BucketizedSplit| { &m.default_direction },
                |m: &mut BucketizedSplit| { &mut m.default_direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "left_id",
                |m: &BucketizedSplit| { &m.left_id },
                |m: &mut BucketizedSplit| { &mut m.left_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "right_id",
                |m: &BucketizedSplit| { &m.right_id },
                |m: &mut BucketizedSplit| { &mut m.right_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BucketizedSplit>(
                "BucketizedSplit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BucketizedSplit {
        static instance: ::protobuf::rt::LazyV2<BucketizedSplit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BucketizedSplit::new)
    }
}

impl ::protobuf::Clear for BucketizedSplit {
    fn clear(&mut self) {
        self.feature_id = 0;
        self.threshold = 0;
        self.dimension_id = 0;
        self.default_direction = DefaultDirection::DEFAULT_LEFT;
        self.left_id = 0;
        self.right_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BucketizedSplit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BucketizedSplit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CategoricalSplit {
    // message fields
    pub feature_id: i32,
    pub value: i32,
    pub dimension_id: i32,
    pub left_id: i32,
    pub right_id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CategoricalSplit {
    fn default() -> &'a CategoricalSplit {
        <CategoricalSplit as ::protobuf::Message>::default_instance()
    }
}

impl CategoricalSplit {
    pub fn new() -> CategoricalSplit {
        ::std::default::Default::default()
    }

    // int32 feature_id = 1;


    pub fn get_feature_id(&self) -> i32 {
        self.feature_id
    }
    pub fn clear_feature_id(&mut self) {
        self.feature_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_feature_id(&mut self, v: i32) {
        self.feature_id = v;
    }

    // int32 value = 2;


    pub fn get_value(&self) -> i32 {
        self.value
    }
    pub fn clear_value(&mut self) {
        self.value = 0;
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: i32) {
        self.value = v;
    }

    // int32 dimension_id = 5;


    pub fn get_dimension_id(&self) -> i32 {
        self.dimension_id
    }
    pub fn clear_dimension_id(&mut self) {
        self.dimension_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_dimension_id(&mut self, v: i32) {
        self.dimension_id = v;
    }

    // int32 left_id = 3;


    pub fn get_left_id(&self) -> i32 {
        self.left_id
    }
    pub fn clear_left_id(&mut self) {
        self.left_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_left_id(&mut self, v: i32) {
        self.left_id = v;
    }

    // int32 right_id = 4;


    pub fn get_right_id(&self) -> i32 {
        self.right_id
    }
    pub fn clear_right_id(&mut self) {
        self.right_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_right_id(&mut self, v: i32) {
        self.right_id = v;
    }
}

impl ::protobuf::Message for CategoricalSplit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.feature_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.value = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dimension_id = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.left_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.right_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.feature_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.feature_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.value != 0 {
            my_size += ::protobuf::rt::value_size(2, self.value, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dimension_id != 0 {
            my_size += ::protobuf::rt::value_size(5, self.dimension_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.left_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.left_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.right_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.feature_id != 0 {
            os.write_int32(1, self.feature_id)?;
        }
        if self.value != 0 {
            os.write_int32(2, self.value)?;
        }
        if self.dimension_id != 0 {
            os.write_int32(5, self.dimension_id)?;
        }
        if self.left_id != 0 {
            os.write_int32(3, self.left_id)?;
        }
        if self.right_id != 0 {
            os.write_int32(4, self.right_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CategoricalSplit {
        CategoricalSplit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "feature_id",
                |m: &CategoricalSplit| { &m.feature_id },
                |m: &mut CategoricalSplit| { &mut m.feature_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "value",
                |m: &CategoricalSplit| { &m.value },
                |m: &mut CategoricalSplit| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dimension_id",
                |m: &CategoricalSplit| { &m.dimension_id },
                |m: &mut CategoricalSplit| { &mut m.dimension_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "left_id",
                |m: &CategoricalSplit| { &m.left_id },
                |m: &mut CategoricalSplit| { &mut m.left_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "right_id",
                |m: &CategoricalSplit| { &m.right_id },
                |m: &mut CategoricalSplit| { &mut m.right_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CategoricalSplit>(
                "CategoricalSplit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CategoricalSplit {
        static instance: ::protobuf::rt::LazyV2<CategoricalSplit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CategoricalSplit::new)
    }
}

impl ::protobuf::Clear for CategoricalSplit {
    fn clear(&mut self) {
        self.feature_id = 0;
        self.value = 0;
        self.dimension_id = 0;
        self.left_id = 0;
        self.right_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CategoricalSplit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CategoricalSplit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DenseSplit {
    // message fields
    pub feature_id: i32,
    pub threshold: f32,
    pub left_id: i32,
    pub right_id: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DenseSplit {
    fn default() -> &'a DenseSplit {
        <DenseSplit as ::protobuf::Message>::default_instance()
    }
}

impl DenseSplit {
    pub fn new() -> DenseSplit {
        ::std::default::Default::default()
    }

    // int32 feature_id = 1;


    pub fn get_feature_id(&self) -> i32 {
        self.feature_id
    }
    pub fn clear_feature_id(&mut self) {
        self.feature_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_feature_id(&mut self, v: i32) {
        self.feature_id = v;
    }

    // float threshold = 2;


    pub fn get_threshold(&self) -> f32 {
        self.threshold
    }
    pub fn clear_threshold(&mut self) {
        self.threshold = 0.;
    }

    // Param is passed by value, moved
    pub fn set_threshold(&mut self, v: f32) {
        self.threshold = v;
    }

    // int32 left_id = 3;


    pub fn get_left_id(&self) -> i32 {
        self.left_id
    }
    pub fn clear_left_id(&mut self) {
        self.left_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_left_id(&mut self, v: i32) {
        self.left_id = v;
    }

    // int32 right_id = 4;


    pub fn get_right_id(&self) -> i32 {
        self.right_id
    }
    pub fn clear_right_id(&mut self) {
        self.right_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_right_id(&mut self, v: i32) {
        self.right_id = v;
    }
}

impl ::protobuf::Message for DenseSplit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.feature_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.threshold = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.left_id = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.right_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.feature_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.feature_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.threshold != 0. {
            my_size += 5;
        }
        if self.left_id != 0 {
            my_size += ::protobuf::rt::value_size(3, self.left_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.right_id != 0 {
            my_size += ::protobuf::rt::value_size(4, self.right_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.feature_id != 0 {
            os.write_int32(1, self.feature_id)?;
        }
        if self.threshold != 0. {
            os.write_float(2, self.threshold)?;
        }
        if self.left_id != 0 {
            os.write_int32(3, self.left_id)?;
        }
        if self.right_id != 0 {
            os.write_int32(4, self.right_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DenseSplit {
        DenseSplit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "feature_id",
                |m: &DenseSplit| { &m.feature_id },
                |m: &mut DenseSplit| { &mut m.feature_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "threshold",
                |m: &DenseSplit| { &m.threshold },
                |m: &mut DenseSplit| { &mut m.threshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "left_id",
                |m: &DenseSplit| { &m.left_id },
                |m: &mut DenseSplit| { &mut m.left_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "right_id",
                |m: &DenseSplit| { &m.right_id },
                |m: &mut DenseSplit| { &mut m.right_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DenseSplit>(
                "DenseSplit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DenseSplit {
        static instance: ::protobuf::rt::LazyV2<DenseSplit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DenseSplit::new)
    }
}

impl ::protobuf::Clear for DenseSplit {
    fn clear(&mut self) {
        self.feature_id = 0;
        self.threshold = 0.;
        self.left_id = 0;
        self.right_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DenseSplit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DenseSplit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tree {
    // message fields
    pub nodes: ::protobuf::RepeatedField<Node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tree {
    fn default() -> &'a Tree {
        <Tree as ::protobuf::Message>::default_instance()
    }
}

impl Tree {
    pub fn new() -> Tree {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.boosted_trees.Node nodes = 1;


    pub fn get_nodes(&self) -> &[Node] {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.nodes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Tree {
    fn is_initialized(&self) -> bool {
        for v in &self.nodes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tree {
        Tree::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                "nodes",
                |m: &Tree| { &m.nodes },
                |m: &mut Tree| { &mut m.nodes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tree>(
                "Tree",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tree {
        static instance: ::protobuf::rt::LazyV2<Tree> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tree::new)
    }
}

impl ::protobuf::Clear for Tree {
    fn clear(&mut self) {
        self.nodes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tree {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tree {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TreeMetadata {
    // message fields
    pub num_layers_grown: i32,
    pub is_finalized: bool,
    pub post_pruned_nodes_meta: ::protobuf::RepeatedField<TreeMetadata_PostPruneNodeUpdate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TreeMetadata {
    fn default() -> &'a TreeMetadata {
        <TreeMetadata as ::protobuf::Message>::default_instance()
    }
}

impl TreeMetadata {
    pub fn new() -> TreeMetadata {
        ::std::default::Default::default()
    }

    // int32 num_layers_grown = 2;


    pub fn get_num_layers_grown(&self) -> i32 {
        self.num_layers_grown
    }
    pub fn clear_num_layers_grown(&mut self) {
        self.num_layers_grown = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_layers_grown(&mut self, v: i32) {
        self.num_layers_grown = v;
    }

    // bool is_finalized = 3;


    pub fn get_is_finalized(&self) -> bool {
        self.is_finalized
    }
    pub fn clear_is_finalized(&mut self) {
        self.is_finalized = false;
    }

    // Param is passed by value, moved
    pub fn set_is_finalized(&mut self, v: bool) {
        self.is_finalized = v;
    }

    // repeated .tensorflow.boosted_trees.TreeMetadata.PostPruneNodeUpdate post_pruned_nodes_meta = 4;


    pub fn get_post_pruned_nodes_meta(&self) -> &[TreeMetadata_PostPruneNodeUpdate] {
        &self.post_pruned_nodes_meta
    }
    pub fn clear_post_pruned_nodes_meta(&mut self) {
        self.post_pruned_nodes_meta.clear();
    }

    // Param is passed by value, moved
    pub fn set_post_pruned_nodes_meta(&mut self, v: ::protobuf::RepeatedField<TreeMetadata_PostPruneNodeUpdate>) {
        self.post_pruned_nodes_meta = v;
    }

    // Mutable pointer to the field.
    pub fn mut_post_pruned_nodes_meta(&mut self) -> &mut ::protobuf::RepeatedField<TreeMetadata_PostPruneNodeUpdate> {
        &mut self.post_pruned_nodes_meta
    }

    // Take field
    pub fn take_post_pruned_nodes_meta(&mut self) -> ::protobuf::RepeatedField<TreeMetadata_PostPruneNodeUpdate> {
        ::std::mem::replace(&mut self.post_pruned_nodes_meta, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TreeMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.post_pruned_nodes_meta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_layers_grown = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_finalized = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.post_pruned_nodes_meta)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_layers_grown != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_layers_grown, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_finalized != false {
            my_size += 2;
        }
        for value in &self.post_pruned_nodes_meta {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_layers_grown != 0 {
            os.write_int32(2, self.num_layers_grown)?;
        }
        if self.is_finalized != false {
            os.write_bool(3, self.is_finalized)?;
        }
        for v in &self.post_pruned_nodes_meta {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TreeMetadata {
        TreeMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_layers_grown",
                |m: &TreeMetadata| { &m.num_layers_grown },
                |m: &mut TreeMetadata| { &mut m.num_layers_grown },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_finalized",
                |m: &TreeMetadata| { &m.is_finalized },
                |m: &mut TreeMetadata| { &mut m.is_finalized },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TreeMetadata_PostPruneNodeUpdate>>(
                "post_pruned_nodes_meta",
                |m: &TreeMetadata| { &m.post_pruned_nodes_meta },
                |m: &mut TreeMetadata| { &mut m.post_pruned_nodes_meta },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TreeMetadata>(
                "TreeMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TreeMetadata {
        static instance: ::protobuf::rt::LazyV2<TreeMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TreeMetadata::new)
    }
}

impl ::protobuf::Clear for TreeMetadata {
    fn clear(&mut self) {
        self.num_layers_grown = 0;
        self.is_finalized = false;
        self.post_pruned_nodes_meta.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TreeMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TreeMetadata_PostPruneNodeUpdate {
    // message fields
    pub new_node_id: i32,
    pub logit_change: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TreeMetadata_PostPruneNodeUpdate {
    fn default() -> &'a TreeMetadata_PostPruneNodeUpdate {
        <TreeMetadata_PostPruneNodeUpdate as ::protobuf::Message>::default_instance()
    }
}

impl TreeMetadata_PostPruneNodeUpdate {
    pub fn new() -> TreeMetadata_PostPruneNodeUpdate {
        ::std::default::Default::default()
    }

    // int32 new_node_id = 1;


    pub fn get_new_node_id(&self) -> i32 {
        self.new_node_id
    }
    pub fn clear_new_node_id(&mut self) {
        self.new_node_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_node_id(&mut self, v: i32) {
        self.new_node_id = v;
    }

    // repeated float logit_change = 2;


    pub fn get_logit_change(&self) -> &[f32] {
        &self.logit_change
    }
    pub fn clear_logit_change(&mut self) {
        self.logit_change.clear();
    }

    // Param is passed by value, moved
    pub fn set_logit_change(&mut self, v: ::std::vec::Vec<f32>) {
        self.logit_change = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logit_change(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.logit_change
    }

    // Take field
    pub fn take_logit_change(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.logit_change, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TreeMetadata_PostPruneNodeUpdate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.new_node_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.logit_change)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.new_node_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.new_node_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += 5 * self.logit_change.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.new_node_id != 0 {
            os.write_int32(1, self.new_node_id)?;
        }
        for v in &self.logit_change {
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TreeMetadata_PostPruneNodeUpdate {
        TreeMetadata_PostPruneNodeUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "new_node_id",
                |m: &TreeMetadata_PostPruneNodeUpdate| { &m.new_node_id },
                |m: &mut TreeMetadata_PostPruneNodeUpdate| { &mut m.new_node_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "logit_change",
                |m: &TreeMetadata_PostPruneNodeUpdate| { &m.logit_change },
                |m: &mut TreeMetadata_PostPruneNodeUpdate| { &mut m.logit_change },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TreeMetadata_PostPruneNodeUpdate>(
                "TreeMetadata.PostPruneNodeUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TreeMetadata_PostPruneNodeUpdate {
        static instance: ::protobuf::rt::LazyV2<TreeMetadata_PostPruneNodeUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TreeMetadata_PostPruneNodeUpdate::new)
    }
}

impl ::protobuf::Clear for TreeMetadata_PostPruneNodeUpdate {
    fn clear(&mut self) {
        self.new_node_id = 0;
        self.logit_change.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TreeMetadata_PostPruneNodeUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeMetadata_PostPruneNodeUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GrowingMetadata {
    // message fields
    pub num_trees_attempted: i64,
    pub num_layers_attempted: i64,
    pub last_layer_node_start: i32,
    pub last_layer_node_end: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GrowingMetadata {
    fn default() -> &'a GrowingMetadata {
        <GrowingMetadata as ::protobuf::Message>::default_instance()
    }
}

impl GrowingMetadata {
    pub fn new() -> GrowingMetadata {
        ::std::default::Default::default()
    }

    // int64 num_trees_attempted = 1;


    pub fn get_num_trees_attempted(&self) -> i64 {
        self.num_trees_attempted
    }
    pub fn clear_num_trees_attempted(&mut self) {
        self.num_trees_attempted = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_trees_attempted(&mut self, v: i64) {
        self.num_trees_attempted = v;
    }

    // int64 num_layers_attempted = 2;


    pub fn get_num_layers_attempted(&self) -> i64 {
        self.num_layers_attempted
    }
    pub fn clear_num_layers_attempted(&mut self) {
        self.num_layers_attempted = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_layers_attempted(&mut self, v: i64) {
        self.num_layers_attempted = v;
    }

    // int32 last_layer_node_start = 3;


    pub fn get_last_layer_node_start(&self) -> i32 {
        self.last_layer_node_start
    }
    pub fn clear_last_layer_node_start(&mut self) {
        self.last_layer_node_start = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_layer_node_start(&mut self, v: i32) {
        self.last_layer_node_start = v;
    }

    // int32 last_layer_node_end = 4;


    pub fn get_last_layer_node_end(&self) -> i32 {
        self.last_layer_node_end
    }
    pub fn clear_last_layer_node_end(&mut self) {
        self.last_layer_node_end = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_layer_node_end(&mut self, v: i32) {
        self.last_layer_node_end = v;
    }
}

impl ::protobuf::Message for GrowingMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_trees_attempted = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_layers_attempted = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.last_layer_node_start = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.last_layer_node_end = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.num_trees_attempted != 0 {
            my_size += ::protobuf::rt::value_size(1, self.num_trees_attempted, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.num_layers_attempted != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_layers_attempted, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_layer_node_start != 0 {
            my_size += ::protobuf::rt::value_size(3, self.last_layer_node_start, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.last_layer_node_end != 0 {
            my_size += ::protobuf::rt::value_size(4, self.last_layer_node_end, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.num_trees_attempted != 0 {
            os.write_int64(1, self.num_trees_attempted)?;
        }
        if self.num_layers_attempted != 0 {
            os.write_int64(2, self.num_layers_attempted)?;
        }
        if self.last_layer_node_start != 0 {
            os.write_int32(3, self.last_layer_node_start)?;
        }
        if self.last_layer_node_end != 0 {
            os.write_int32(4, self.last_layer_node_end)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GrowingMetadata {
        GrowingMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_trees_attempted",
                |m: &GrowingMetadata| { &m.num_trees_attempted },
                |m: &mut GrowingMetadata| { &mut m.num_trees_attempted },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_layers_attempted",
                |m: &GrowingMetadata| { &m.num_layers_attempted },
                |m: &mut GrowingMetadata| { &mut m.num_layers_attempted },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "last_layer_node_start",
                |m: &GrowingMetadata| { &m.last_layer_node_start },
                |m: &mut GrowingMetadata| { &mut m.last_layer_node_start },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "last_layer_node_end",
                |m: &GrowingMetadata| { &m.last_layer_node_end },
                |m: &mut GrowingMetadata| { &mut m.last_layer_node_end },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GrowingMetadata>(
                "GrowingMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GrowingMetadata {
        static instance: ::protobuf::rt::LazyV2<GrowingMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GrowingMetadata::new)
    }
}

impl ::protobuf::Clear for GrowingMetadata {
    fn clear(&mut self) {
        self.num_trees_attempted = 0;
        self.num_layers_attempted = 0;
        self.last_layer_node_start = 0;
        self.last_layer_node_end = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GrowingMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GrowingMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TreeEnsemble {
    // message fields
    pub trees: ::protobuf::RepeatedField<Tree>,
    pub tree_weights: ::std::vec::Vec<f32>,
    pub tree_metadata: ::protobuf::RepeatedField<TreeMetadata>,
    pub growing_metadata: ::protobuf::SingularPtrField<GrowingMetadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TreeEnsemble {
    fn default() -> &'a TreeEnsemble {
        <TreeEnsemble as ::protobuf::Message>::default_instance()
    }
}

impl TreeEnsemble {
    pub fn new() -> TreeEnsemble {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.boosted_trees.Tree trees = 1;


    pub fn get_trees(&self) -> &[Tree] {
        &self.trees
    }
    pub fn clear_trees(&mut self) {
        self.trees.clear();
    }

    // Param is passed by value, moved
    pub fn set_trees(&mut self, v: ::protobuf::RepeatedField<Tree>) {
        self.trees = v;
    }

    // Mutable pointer to the field.
    pub fn mut_trees(&mut self) -> &mut ::protobuf::RepeatedField<Tree> {
        &mut self.trees
    }

    // Take field
    pub fn take_trees(&mut self) -> ::protobuf::RepeatedField<Tree> {
        ::std::mem::replace(&mut self.trees, ::protobuf::RepeatedField::new())
    }

    // repeated float tree_weights = 2;


    pub fn get_tree_weights(&self) -> &[f32] {
        &self.tree_weights
    }
    pub fn clear_tree_weights(&mut self) {
        self.tree_weights.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_weights(&mut self, v: ::std::vec::Vec<f32>) {
        self.tree_weights = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_weights(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.tree_weights
    }

    // Take field
    pub fn take_tree_weights(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.tree_weights, ::std::vec::Vec::new())
    }

    // repeated .tensorflow.boosted_trees.TreeMetadata tree_metadata = 3;


    pub fn get_tree_metadata(&self) -> &[TreeMetadata] {
        &self.tree_metadata
    }
    pub fn clear_tree_metadata(&mut self) {
        self.tree_metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_tree_metadata(&mut self, v: ::protobuf::RepeatedField<TreeMetadata>) {
        self.tree_metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tree_metadata(&mut self) -> &mut ::protobuf::RepeatedField<TreeMetadata> {
        &mut self.tree_metadata
    }

    // Take field
    pub fn take_tree_metadata(&mut self) -> ::protobuf::RepeatedField<TreeMetadata> {
        ::std::mem::replace(&mut self.tree_metadata, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.boosted_trees.GrowingMetadata growing_metadata = 4;


    pub fn get_growing_metadata(&self) -> &GrowingMetadata {
        self.growing_metadata.as_ref().unwrap_or_else(|| <GrowingMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_growing_metadata(&mut self) {
        self.growing_metadata.clear();
    }

    pub fn has_growing_metadata(&self) -> bool {
        self.growing_metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_growing_metadata(&mut self, v: GrowingMetadata) {
        self.growing_metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_growing_metadata(&mut self) -> &mut GrowingMetadata {
        if self.growing_metadata.is_none() {
            self.growing_metadata.set_default();
        }
        self.growing_metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_growing_metadata(&mut self) -> GrowingMetadata {
        self.growing_metadata.take().unwrap_or_else(|| GrowingMetadata::new())
    }
}

impl ::protobuf::Message for TreeEnsemble {
    fn is_initialized(&self) -> bool {
        for v in &self.trees {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tree_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.growing_metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.trees)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.tree_weights)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tree_metadata)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.growing_metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.trees {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += 5 * self.tree_weights.len() as u32;
        for value in &self.tree_metadata {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.growing_metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.trees {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tree_weights {
            os.write_float(2, *v)?;
        };
        for v in &self.tree_metadata {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.growing_metadata.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TreeEnsemble {
        TreeEnsemble::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tree>>(
                "trees",
                |m: &TreeEnsemble| { &m.trees },
                |m: &mut TreeEnsemble| { &mut m.trees },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "tree_weights",
                |m: &TreeEnsemble| { &m.tree_weights },
                |m: &mut TreeEnsemble| { &mut m.tree_weights },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TreeMetadata>>(
                "tree_metadata",
                |m: &TreeEnsemble| { &m.tree_metadata },
                |m: &mut TreeEnsemble| { &mut m.tree_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GrowingMetadata>>(
                "growing_metadata",
                |m: &TreeEnsemble| { &m.growing_metadata },
                |m: &mut TreeEnsemble| { &mut m.growing_metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TreeEnsemble>(
                "TreeEnsemble",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TreeEnsemble {
        static instance: ::protobuf::rt::LazyV2<TreeEnsemble> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TreeEnsemble::new)
    }
}

impl ::protobuf::Clear for TreeEnsemble {
    fn clear(&mut self) {
        self.trees.clear();
        self.tree_weights.clear();
        self.tree_metadata.clear();
        self.growing_metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TreeEnsemble {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TreeEnsemble {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugOutput {
    // message fields
    pub feature_ids: ::std::vec::Vec<i32>,
    pub logits_path: ::std::vec::Vec<f32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugOutput {
    fn default() -> &'a DebugOutput {
        <DebugOutput as ::protobuf::Message>::default_instance()
    }
}

impl DebugOutput {
    pub fn new() -> DebugOutput {
        ::std::default::Default::default()
    }

    // repeated int32 feature_ids = 1;


    pub fn get_feature_ids(&self) -> &[i32] {
        &self.feature_ids
    }
    pub fn clear_feature_ids(&mut self) {
        self.feature_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_feature_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.feature_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_feature_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.feature_ids
    }

    // Take field
    pub fn take_feature_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.feature_ids, ::std::vec::Vec::new())
    }

    // repeated float logits_path = 2;


    pub fn get_logits_path(&self) -> &[f32] {
        &self.logits_path
    }
    pub fn clear_logits_path(&mut self) {
        self.logits_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_logits_path(&mut self, v: ::std::vec::Vec<f32>) {
        self.logits_path = v;
    }

    // Mutable pointer to the field.
    pub fn mut_logits_path(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.logits_path
    }

    // Take field
    pub fn take_logits_path(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.logits_path, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DebugOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.feature_ids)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.logits_path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.feature_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 5 * self.logits_path.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.feature_ids {
            os.write_int32(1, *v)?;
        };
        for v in &self.logits_path {
            os.write_float(2, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugOutput {
        DebugOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "feature_ids",
                |m: &DebugOutput| { &m.feature_ids },
                |m: &mut DebugOutput| { &mut m.feature_ids },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "logits_path",
                |m: &DebugOutput| { &m.logits_path },
                |m: &mut DebugOutput| { &mut m.logits_path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugOutput>(
                "DebugOutput",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugOutput {
        static instance: ::protobuf::rt::LazyV2<DebugOutput> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugOutput::new)
    }
}

impl ::protobuf::Clear for DebugOutput {
    fn clear(&mut self) {
        self.feature_ids.clear();
        self.logits_path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SplitTypeWithDefault {
    INEQUALITY_DEFAULT_LEFT = 0,
    INEQUALITY_DEFAULT_RIGHT = 1,
    EQUALITY_DEFAULT_RIGHT = 3,
}

impl ::protobuf::ProtobufEnum for SplitTypeWithDefault {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SplitTypeWithDefault> {
        match value {
            0 => ::std::option::Option::Some(SplitTypeWithDefault::INEQUALITY_DEFAULT_LEFT),
            1 => ::std::option::Option::Some(SplitTypeWithDefault::INEQUALITY_DEFAULT_RIGHT),
            3 => ::std::option::Option::Some(SplitTypeWithDefault::EQUALITY_DEFAULT_RIGHT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SplitTypeWithDefault] = &[
            SplitTypeWithDefault::INEQUALITY_DEFAULT_LEFT,
            SplitTypeWithDefault::INEQUALITY_DEFAULT_RIGHT,
            SplitTypeWithDefault::EQUALITY_DEFAULT_RIGHT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SplitTypeWithDefault>("SplitTypeWithDefault", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SplitTypeWithDefault {
}

impl ::std::default::Default for SplitTypeWithDefault {
    fn default() -> Self {
        SplitTypeWithDefault::INEQUALITY_DEFAULT_LEFT
    }
}

impl ::protobuf::reflect::ProtobufValue for SplitTypeWithDefault {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DefaultDirection {
    DEFAULT_LEFT = 0,
    DEFAULT_RIGHT = 1,
}

impl ::protobuf::ProtobufEnum for DefaultDirection {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DefaultDirection> {
        match value {
            0 => ::std::option::Option::Some(DefaultDirection::DEFAULT_LEFT),
            1 => ::std::option::Option::Some(DefaultDirection::DEFAULT_RIGHT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DefaultDirection] = &[
            DefaultDirection::DEFAULT_LEFT,
            DefaultDirection::DEFAULT_RIGHT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DefaultDirection>("DefaultDirection", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DefaultDirection {
}

impl ::std::default::Default for DefaultDirection {
    fn default() -> Self {
        DefaultDirection::DEFAULT_LEFT
    }
}

impl ::protobuf::reflect::ProtobufValue for DefaultDirection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n9tensorflow/core/kernels/boosted_trees/boosted_trees.proto\x12\x18tens\
    orflow.boosted_trees\"\x85\x03\n\x04Node\x124\n\x04leaf\x18\x01\x20\x01(\
    \x0b2\x1e.tensorflow.boosted_trees.LeafH\0R\x04leaf\x12V\n\x10bucketized\
    _split\x18\x02\x20\x01(\x0b2).tensorflow.boosted_trees.BucketizedSplitH\
    \0R\x0fbucketizedSplit\x12Y\n\x11categorical_split\x18\x03\x20\x01(\x0b2\
    *.tensorflow.boosted_trees.CategoricalSplitH\0R\x10categoricalSplit\x12G\
    \n\x0bdense_split\x18\x04\x20\x01(\x0b2$.tensorflow.boosted_trees.DenseS\
    plitH\0R\ndenseSplit\x12C\n\x08metadata\x18\x89\x06\x20\x01(\x0b2&.tenso\
    rflow.boosted_trees.NodeMetadataR\x08metadataB\x06\n\x04node\"g\n\x0cNod\
    eMetadata\x12\x12\n\x04gain\x18\x01\x20\x01(\x02R\x04gain\x12C\n\rorigin\
    al_leaf\x18\x02\x20\x01(\x0b2\x1e.tensorflow.boosted_trees.LeafR\x0corig\
    inalLeaf\"\xb1\x01\n\x04Leaf\x12:\n\x06vector\x18\x01\x20\x01(\x0b2\x20.\
    tensorflow.boosted_trees.VectorH\0R\x06vector\x12M\n\rsparse_vector\x18\
    \x02\x20\x01(\x0b2&.tensorflow.boosted_trees.SparseVectorH\0R\x0csparseV\
    ector\x12\x16\n\x06scalar\x18\x03\x20\x01(\x02R\x06scalarB\x06\n\x04leaf\
    \"\x1e\n\x06Vector\x12\x14\n\x05value\x18\x01\x20\x03(\x02R\x05value\":\
    \n\x0cSparseVector\x12\x14\n\x05index\x18\x01\x20\x03(\x05R\x05index\x12\
    \x14\n\x05value\x18\x02\x20\x03(\x02R\x05value\"\xfe\x01\n\x0fBucketized\
    Split\x12\x1d\n\nfeature_id\x18\x01\x20\x01(\x05R\tfeatureId\x12\x1c\n\t\
    threshold\x18\x02\x20\x01(\x05R\tthreshold\x12!\n\x0cdimension_id\x18\
    \x05\x20\x01(\x05R\x0bdimensionId\x12W\n\x11default_direction\x18\x06\
    \x20\x01(\x0e2*.tensorflow.boosted_trees.DefaultDirectionR\x10defaultDir\
    ection\x12\x17\n\x07left_id\x18\x03\x20\x01(\x05R\x06leftId\x12\x19\n\
    \x08right_id\x18\x04\x20\x01(\x05R\x07rightId\"\x9e\x01\n\x10Categorical\
    Split\x12\x1d\n\nfeature_id\x18\x01\x20\x01(\x05R\tfeatureId\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x05R\x05value\x12!\n\x0cdimension_id\x18\x05\
    \x20\x01(\x05R\x0bdimensionId\x12\x17\n\x07left_id\x18\x03\x20\x01(\x05R\
    \x06leftId\x12\x19\n\x08right_id\x18\x04\x20\x01(\x05R\x07rightId\"}\n\n\
    DenseSplit\x12\x1d\n\nfeature_id\x18\x01\x20\x01(\x05R\tfeatureId\x12\
    \x1c\n\tthreshold\x18\x02\x20\x01(\x02R\tthreshold\x12\x17\n\x07left_id\
    \x18\x03\x20\x01(\x05R\x06leftId\x12\x19\n\x08right_id\x18\x04\x20\x01(\
    \x05R\x07rightId\"<\n\x04Tree\x124\n\x05nodes\x18\x01\x20\x03(\x0b2\x1e.\
    tensorflow.boosted_trees.NodeR\x05nodes\"\xa6\x02\n\x0cTreeMetadata\x12(\
    \n\x10num_layers_grown\x18\x02\x20\x01(\x05R\x0enumLayersGrown\x12!\n\
    \x0cis_finalized\x18\x03\x20\x01(\x08R\x0bisFinalized\x12o\n\x16post_pru\
    ned_nodes_meta\x18\x04\x20\x03(\x0b2:.tensorflow.boosted_trees.TreeMetad\
    ata.PostPruneNodeUpdateR\x13postPrunedNodesMeta\x1aX\n\x13PostPruneNodeU\
    pdate\x12\x1e\n\x0bnew_node_id\x18\x01\x20\x01(\x05R\tnewNodeId\x12!\n\
    \x0clogit_change\x18\x02\x20\x03(\x02R\x0blogitChange\"\xd5\x01\n\x0fGro\
    wingMetadata\x12.\n\x13num_trees_attempted\x18\x01\x20\x01(\x03R\x11numT\
    reesAttempted\x120\n\x14num_layers_attempted\x18\x02\x20\x01(\x03R\x12nu\
    mLayersAttempted\x121\n\x15last_layer_node_start\x18\x03\x20\x01(\x05R\
    \x12lastLayerNodeStart\x12-\n\x13last_layer_node_end\x18\x04\x20\x01(\
    \x05R\x10lastLayerNodeEnd\"\x8a\x02\n\x0cTreeEnsemble\x124\n\x05trees\
    \x18\x01\x20\x03(\x0b2\x1e.tensorflow.boosted_trees.TreeR\x05trees\x12!\
    \n\x0ctree_weights\x18\x02\x20\x03(\x02R\x0btreeWeights\x12K\n\rtree_met\
    adata\x18\x03\x20\x03(\x0b2&.tensorflow.boosted_trees.TreeMetadataR\x0ct\
    reeMetadata\x12T\n\x10growing_metadata\x18\x04\x20\x01(\x0b2).tensorflow\
    .boosted_trees.GrowingMetadataR\x0fgrowingMetadata\"O\n\x0bDebugOutput\
    \x12\x1f\n\x0bfeature_ids\x18\x01\x20\x03(\x05R\nfeatureIds\x12\x1f\n\
    \x0blogits_path\x18\x02\x20\x03(\x02R\nlogitsPath*m\n\x14SplitTypeWithDe\
    fault\x12\x1b\n\x17INEQUALITY_DEFAULT_LEFT\x10\0\x12\x1c\n\x18INEQUALITY\
    _DEFAULT_RIGHT\x10\x01\x12\x1a\n\x16EQUALITY_DEFAULT_RIGHT\x10\x03*7\n\
    \x10DefaultDirection\x12\x10\n\x0cDEFAULT_LEFT\x10\0\x12\x11\n\rDEFAULT_\
    RIGHT\x10\x01B3\n\x18org.tensorflow.frameworkB\x12BoostedTreesProtosP\
    \x01\xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
