// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/grappler/costs/op_performance_data.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct SessionInfo {
    // message fields
    pub intra_op_parallelism: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionInfo {
    fn default() -> &'a SessionInfo {
        <SessionInfo as ::protobuf::Message>::default_instance()
    }
}

impl SessionInfo {
    pub fn new() -> SessionInfo {
        ::std::default::Default::default()
    }

    // int64 intra_op_parallelism = 1;


    pub fn get_intra_op_parallelism(&self) -> i64 {
        self.intra_op_parallelism
    }
    pub fn clear_intra_op_parallelism(&mut self) {
        self.intra_op_parallelism = 0;
    }

    // Param is passed by value, moved
    pub fn set_intra_op_parallelism(&mut self, v: i64) {
        self.intra_op_parallelism = v;
    }
}

impl ::protobuf::Message for SessionInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.intra_op_parallelism = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.intra_op_parallelism != 0 {
            my_size += ::protobuf::rt::value_size(1, self.intra_op_parallelism, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.intra_op_parallelism != 0 {
            os.write_int64(1, self.intra_op_parallelism)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionInfo {
        SessionInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "intra_op_parallelism",
                |m: &SessionInfo| { &m.intra_op_parallelism },
                |m: &mut SessionInfo| { &mut m.intra_op_parallelism },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionInfo>(
                "SessionInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SessionInfo {
        static instance: ::protobuf::rt::LazyV2<SessionInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SessionInfo::new)
    }
}

impl ::protobuf::Clear for SessionInfo {
    fn clear(&mut self) {
        self.intra_op_parallelism = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpInfo {
    // message fields
    pub op: ::std::string::String,
    pub attr: ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue>,
    pub inputs: ::protobuf::RepeatedField<OpInfo_TensorProperties>,
    pub outputs: ::protobuf::RepeatedField<OpInfo_TensorProperties>,
    pub device: ::protobuf::SingularPtrField<super::device_properties::DeviceProperties>,
    pub session_info: ::protobuf::SingularPtrField<SessionInfo>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpInfo {
    fn default() -> &'a OpInfo {
        <OpInfo as ::protobuf::Message>::default_instance()
    }
}

impl OpInfo {
    pub fn new() -> OpInfo {
        ::std::default::Default::default()
    }

    // string op = 1;


    pub fn get_op(&self) -> &str {
        &self.op
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // repeated .tensorflow.OpInfo.AttrEntry attr = 2;


    pub fn get_attr(&self) -> &::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        &self.attr
    }
    pub fn clear_attr(&mut self) {
        self.attr.clear();
    }

    // Param is passed by value, moved
    pub fn set_attr(&mut self, v: ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue>) {
        self.attr = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attr(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        &mut self.attr
    }

    // Take field
    pub fn take_attr(&mut self) -> ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        ::std::mem::replace(&mut self.attr, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.OpInfo.TensorProperties inputs = 3;


    pub fn get_inputs(&self) -> &[OpInfo_TensorProperties] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<OpInfo_TensorProperties>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<OpInfo_TensorProperties> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<OpInfo_TensorProperties> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.OpInfo.TensorProperties outputs = 5;


    pub fn get_outputs(&self) -> &[OpInfo_TensorProperties] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<OpInfo_TensorProperties>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<OpInfo_TensorProperties> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<OpInfo_TensorProperties> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.DeviceProperties device = 4;


    pub fn get_device(&self) -> &super::device_properties::DeviceProperties {
        self.device.as_ref().unwrap_or_else(|| <super::device_properties::DeviceProperties as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    pub fn has_device(&self) -> bool {
        self.device.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: super::device_properties::DeviceProperties) {
        self.device = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut super::device_properties::DeviceProperties {
        if self.device.is_none() {
            self.device.set_default();
        }
        self.device.as_mut().unwrap()
    }

    // Take field
    pub fn take_device(&mut self) -> super::device_properties::DeviceProperties {
        self.device.take().unwrap_or_else(|| super::device_properties::DeviceProperties::new())
    }

    // .tensorflow.SessionInfo session_info = 6;


    pub fn get_session_info(&self) -> &SessionInfo {
        self.session_info.as_ref().unwrap_or_else(|| <SessionInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_session_info(&mut self) {
        self.session_info.clear();
    }

    pub fn has_session_info(&self) -> bool {
        self.session_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_info(&mut self, v: SessionInfo) {
        self.session_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_info(&mut self) -> &mut SessionInfo {
        if self.session_info.is_none() {
            self.session_info.set_default();
        }
        self.session_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_info(&mut self) -> SessionInfo {
        self.session_info.take().unwrap_or_else(|| SessionInfo::new())
    }
}

impl ::protobuf::Message for OpInfo {
    fn is_initialized(&self) -> bool {
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.session_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(wire_type, is, &mut self.attr)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.session_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.op);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(2, &self.attr);
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.device.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.session_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.op.is_empty() {
            os.write_string(1, &self.op)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(2, &self.attr, os)?;
        for v in &self.inputs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outputs {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.device.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.session_info.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpInfo {
        OpInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op",
                |m: &OpInfo| { &m.op },
                |m: &mut OpInfo| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(
                "attr",
                |m: &OpInfo| { &m.attr },
                |m: &mut OpInfo| { &mut m.attr },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpInfo_TensorProperties>>(
                "inputs",
                |m: &OpInfo| { &m.inputs },
                |m: &mut OpInfo| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpInfo_TensorProperties>>(
                "outputs",
                |m: &OpInfo| { &m.outputs },
                |m: &mut OpInfo| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_properties::DeviceProperties>>(
                "device",
                |m: &OpInfo| { &m.device },
                |m: &mut OpInfo| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SessionInfo>>(
                "session_info",
                |m: &OpInfo| { &m.session_info },
                |m: &mut OpInfo| { &mut m.session_info },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpInfo>(
                "OpInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpInfo {
        static instance: ::protobuf::rt::LazyV2<OpInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpInfo::new)
    }
}

impl ::protobuf::Clear for OpInfo {
    fn clear(&mut self) {
        self.op.clear();
        self.attr.clear();
        self.inputs.clear();
        self.outputs.clear();
        self.device.clear();
        self.session_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpInfo_TensorProperties {
    // message fields
    pub dtype: super::types::DataType,
    pub shape: ::protobuf::SingularPtrField<super::tensor_shape::TensorShapeProto>,
    pub value: ::protobuf::SingularPtrField<super::tensor::TensorProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpInfo_TensorProperties {
    fn default() -> &'a OpInfo_TensorProperties {
        <OpInfo_TensorProperties as ::protobuf::Message>::default_instance()
    }
}

impl OpInfo_TensorProperties {
    pub fn new() -> OpInfo_TensorProperties {
        ::std::default::Default::default()
    }

    // .tensorflow.DataType dtype = 1;


    pub fn get_dtype(&self) -> super::types::DataType {
        self.dtype
    }
    pub fn clear_dtype(&mut self) {
        self.dtype = super::types::DataType::DT_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_dtype(&mut self, v: super::types::DataType) {
        self.dtype = v;
    }

    // .tensorflow.TensorShapeProto shape = 2;


    pub fn get_shape(&self) -> &super::tensor_shape::TensorShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <super::tensor_shape::TensorShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: super::tensor_shape::TensorShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut super::tensor_shape::TensorShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> super::tensor_shape::TensorShapeProto {
        self.shape.take().unwrap_or_else(|| super::tensor_shape::TensorShapeProto::new())
    }

    // .tensorflow.TensorProto value = 3;


    pub fn get_value(&self) -> &super::tensor::TensorProto {
        self.value.as_ref().unwrap_or_else(|| <super::tensor::TensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: super::tensor::TensorProto) {
        self.value = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut super::tensor::TensorProto {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> super::tensor::TensorProto {
        self.value.take().unwrap_or_else(|| super::tensor::TensorProto::new())
    }
}

impl ::protobuf::Message for OpInfo_TensorProperties {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.dtype, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.dtype != super::types::DataType::DT_INVALID {
            my_size += ::protobuf::rt::enum_size(1, self.dtype);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.value.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.dtype != super::types::DataType::DT_INVALID {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.dtype))?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpInfo_TensorProperties {
        OpInfo_TensorProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::types::DataType>>(
                "dtype",
                |m: &OpInfo_TensorProperties| { &m.dtype },
                |m: &mut OpInfo_TensorProperties| { &mut m.dtype },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor_shape::TensorShapeProto>>(
                "shape",
                |m: &OpInfo_TensorProperties| { &m.shape },
                |m: &mut OpInfo_TensorProperties| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor::TensorProto>>(
                "value",
                |m: &OpInfo_TensorProperties| { &m.value },
                |m: &mut OpInfo_TensorProperties| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpInfo_TensorProperties>(
                "OpInfo.TensorProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpInfo_TensorProperties {
        static instance: ::protobuf::rt::LazyV2<OpInfo_TensorProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpInfo_TensorProperties::new)
    }
}

impl ::protobuf::Clear for OpInfo_TensorProperties {
    fn clear(&mut self) {
        self.dtype = super::types::DataType::DT_INVALID;
        self.shape.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpInfo_TensorProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpInfo_TensorProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NormalDistribution {
    // message fields
    pub mu: f64,
    pub sigma: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NormalDistribution {
    fn default() -> &'a NormalDistribution {
        <NormalDistribution as ::protobuf::Message>::default_instance()
    }
}

impl NormalDistribution {
    pub fn new() -> NormalDistribution {
        ::std::default::Default::default()
    }

    // double mu = 1;


    pub fn get_mu(&self) -> f64 {
        self.mu
    }
    pub fn clear_mu(&mut self) {
        self.mu = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mu(&mut self, v: f64) {
        self.mu = v;
    }

    // double sigma = 2;


    pub fn get_sigma(&self) -> f64 {
        self.sigma
    }
    pub fn clear_sigma(&mut self) {
        self.sigma = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sigma(&mut self, v: f64) {
        self.sigma = v;
    }
}

impl ::protobuf::Message for NormalDistribution {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.mu = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.sigma = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mu != 0. {
            my_size += 9;
        }
        if self.sigma != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mu != 0. {
            os.write_double(1, self.mu)?;
        }
        if self.sigma != 0. {
            os.write_double(2, self.sigma)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NormalDistribution {
        NormalDistribution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "mu",
                |m: &NormalDistribution| { &m.mu },
                |m: &mut NormalDistribution| { &mut m.mu },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "sigma",
                |m: &NormalDistribution| { &m.sigma },
                |m: &mut NormalDistribution| { &mut m.sigma },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NormalDistribution>(
                "NormalDistribution",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NormalDistribution {
        static instance: ::protobuf::rt::LazyV2<NormalDistribution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NormalDistribution::new)
    }
}

impl ::protobuf::Clear for NormalDistribution {
    fn clear(&mut self) {
        self.mu = 0.;
        self.sigma = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NormalDistribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NormalDistribution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LogNormalDistribution {
    // message fields
    pub mu: f64,
    pub sigma: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LogNormalDistribution {
    fn default() -> &'a LogNormalDistribution {
        <LogNormalDistribution as ::protobuf::Message>::default_instance()
    }
}

impl LogNormalDistribution {
    pub fn new() -> LogNormalDistribution {
        ::std::default::Default::default()
    }

    // double mu = 1;


    pub fn get_mu(&self) -> f64 {
        self.mu
    }
    pub fn clear_mu(&mut self) {
        self.mu = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mu(&mut self, v: f64) {
        self.mu = v;
    }

    // double sigma = 2;


    pub fn get_sigma(&self) -> f64 {
        self.sigma
    }
    pub fn clear_sigma(&mut self) {
        self.sigma = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sigma(&mut self, v: f64) {
        self.sigma = v;
    }
}

impl ::protobuf::Message for LogNormalDistribution {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.mu = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.sigma = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.mu != 0. {
            my_size += 9;
        }
        if self.sigma != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.mu != 0. {
            os.write_double(1, self.mu)?;
        }
        if self.sigma != 0. {
            os.write_double(2, self.sigma)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LogNormalDistribution {
        LogNormalDistribution::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "mu",
                |m: &LogNormalDistribution| { &m.mu },
                |m: &mut LogNormalDistribution| { &mut m.mu },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "sigma",
                |m: &LogNormalDistribution| { &m.sigma },
                |m: &mut LogNormalDistribution| { &mut m.sigma },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LogNormalDistribution>(
                "LogNormalDistribution",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LogNormalDistribution {
        static instance: ::protobuf::rt::LazyV2<LogNormalDistribution> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LogNormalDistribution::new)
    }
}

impl ::protobuf::Clear for LogNormalDistribution {
    fn clear(&mut self) {
        self.mu = 0.;
        self.sigma = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LogNormalDistribution {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LogNormalDistribution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpPerformance {
    // message fields
    pub op: ::protobuf::SingularPtrField<OpInfo>,
    pub session_info: ::protobuf::SingularPtrField<SessionInfo>,
    pub node: ::std::string::String,
    pub temporary_memory_size: i64,
    pub compute_cost: i64,
    pub compute_time: i64,
    pub memory_time: i64,
    pub compute_efficiency: f64,
    pub memory_efficiency: f64,
    pub op_memory: ::protobuf::SingularPtrField<OpPerformance_OpMemory>,
    // message oneof groups
    pub execution_time: ::std::option::Option<OpPerformance_oneof_execution_time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpPerformance {
    fn default() -> &'a OpPerformance {
        <OpPerformance as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum OpPerformance_oneof_execution_time {
    execution_time_normal(NormalDistribution),
    execution_time_log_normal(LogNormalDistribution),
}

impl OpPerformance {
    pub fn new() -> OpPerformance {
        ::std::default::Default::default()
    }

    // .tensorflow.OpInfo op = 1;


    pub fn get_op(&self) -> &OpInfo {
        self.op.as_ref().unwrap_or_else(|| <OpInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    pub fn has_op(&self) -> bool {
        self.op.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: OpInfo) {
        self.op = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut OpInfo {
        if self.op.is_none() {
            self.op.set_default();
        }
        self.op.as_mut().unwrap()
    }

    // Take field
    pub fn take_op(&mut self) -> OpInfo {
        self.op.take().unwrap_or_else(|| OpInfo::new())
    }

    // .tensorflow.SessionInfo session_info = 12;


    pub fn get_session_info(&self) -> &SessionInfo {
        self.session_info.as_ref().unwrap_or_else(|| <SessionInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_session_info(&mut self) {
        self.session_info.clear();
    }

    pub fn has_session_info(&self) -> bool {
        self.session_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_session_info(&mut self, v: SessionInfo) {
        self.session_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_info(&mut self) -> &mut SessionInfo {
        if self.session_info.is_none() {
            self.session_info.set_default();
        }
        self.session_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_session_info(&mut self) -> SessionInfo {
        self.session_info.take().unwrap_or_else(|| SessionInfo::new())
    }

    // string node = 5;


    pub fn get_node(&self) -> &str {
        &self.node
    }
    pub fn clear_node(&mut self) {
        self.node.clear();
    }

    // Param is passed by value, moved
    pub fn set_node(&mut self, v: ::std::string::String) {
        self.node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node(&mut self) -> &mut ::std::string::String {
        &mut self.node
    }

    // Take field
    pub fn take_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node, ::std::string::String::new())
    }

    // int64 temporary_memory_size = 2;


    pub fn get_temporary_memory_size(&self) -> i64 {
        self.temporary_memory_size
    }
    pub fn clear_temporary_memory_size(&mut self) {
        self.temporary_memory_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_temporary_memory_size(&mut self, v: i64) {
        self.temporary_memory_size = v;
    }

    // int64 compute_cost = 3;


    pub fn get_compute_cost(&self) -> i64 {
        self.compute_cost
    }
    pub fn clear_compute_cost(&mut self) {
        self.compute_cost = 0;
    }

    // Param is passed by value, moved
    pub fn set_compute_cost(&mut self, v: i64) {
        self.compute_cost = v;
    }

    // int64 compute_time = 6;


    pub fn get_compute_time(&self) -> i64 {
        self.compute_time
    }
    pub fn clear_compute_time(&mut self) {
        self.compute_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_compute_time(&mut self, v: i64) {
        self.compute_time = v;
    }

    // int64 memory_time = 7;


    pub fn get_memory_time(&self) -> i64 {
        self.memory_time
    }
    pub fn clear_memory_time(&mut self) {
        self.memory_time = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory_time(&mut self, v: i64) {
        self.memory_time = v;
    }

    // double compute_efficiency = 4;


    pub fn get_compute_efficiency(&self) -> f64 {
        self.compute_efficiency
    }
    pub fn clear_compute_efficiency(&mut self) {
        self.compute_efficiency = 0.;
    }

    // Param is passed by value, moved
    pub fn set_compute_efficiency(&mut self, v: f64) {
        self.compute_efficiency = v;
    }

    // double memory_efficiency = 8;


    pub fn get_memory_efficiency(&self) -> f64 {
        self.memory_efficiency
    }
    pub fn clear_memory_efficiency(&mut self) {
        self.memory_efficiency = 0.;
    }

    // Param is passed by value, moved
    pub fn set_memory_efficiency(&mut self, v: f64) {
        self.memory_efficiency = v;
    }

    // .tensorflow.NormalDistribution execution_time_normal = 10;


    pub fn get_execution_time_normal(&self) -> &NormalDistribution {
        match self.execution_time {
            ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(ref v)) => v,
            _ => <NormalDistribution as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_execution_time_normal(&mut self) {
        self.execution_time = ::std::option::Option::None;
    }

    pub fn has_execution_time_normal(&self) -> bool {
        match self.execution_time {
            ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_execution_time_normal(&mut self, v: NormalDistribution) {
        self.execution_time = ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_execution_time_normal(&mut self) -> &mut NormalDistribution {
        if let ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(_)) = self.execution_time {
        } else {
            self.execution_time = ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(NormalDistribution::new()));
        }
        match self.execution_time {
            ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_execution_time_normal(&mut self) -> NormalDistribution {
        if self.has_execution_time_normal() {
            match self.execution_time.take() {
                ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(v)) => v,
                _ => panic!(),
            }
        } else {
            NormalDistribution::new()
        }
    }

    // .tensorflow.LogNormalDistribution execution_time_log_normal = 11;


    pub fn get_execution_time_log_normal(&self) -> &LogNormalDistribution {
        match self.execution_time {
            ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(ref v)) => v,
            _ => <LogNormalDistribution as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_execution_time_log_normal(&mut self) {
        self.execution_time = ::std::option::Option::None;
    }

    pub fn has_execution_time_log_normal(&self) -> bool {
        match self.execution_time {
            ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_execution_time_log_normal(&mut self, v: LogNormalDistribution) {
        self.execution_time = ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(v))
    }

    // Mutable pointer to the field.
    pub fn mut_execution_time_log_normal(&mut self) -> &mut LogNormalDistribution {
        if let ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(_)) = self.execution_time {
        } else {
            self.execution_time = ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(LogNormalDistribution::new()));
        }
        match self.execution_time {
            ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_execution_time_log_normal(&mut self) -> LogNormalDistribution {
        if self.has_execution_time_log_normal() {
            match self.execution_time.take() {
                ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(v)) => v,
                _ => panic!(),
            }
        } else {
            LogNormalDistribution::new()
        }
    }

    // .tensorflow.OpPerformance.OpMemory op_memory = 9;


    pub fn get_op_memory(&self) -> &OpPerformance_OpMemory {
        self.op_memory.as_ref().unwrap_or_else(|| <OpPerformance_OpMemory as ::protobuf::Message>::default_instance())
    }
    pub fn clear_op_memory(&mut self) {
        self.op_memory.clear();
    }

    pub fn has_op_memory(&self) -> bool {
        self.op_memory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_op_memory(&mut self, v: OpPerformance_OpMemory) {
        self.op_memory = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_memory(&mut self) -> &mut OpPerformance_OpMemory {
        if self.op_memory.is_none() {
            self.op_memory.set_default();
        }
        self.op_memory.as_mut().unwrap()
    }

    // Take field
    pub fn take_op_memory(&mut self) -> OpPerformance_OpMemory {
        self.op_memory.take().unwrap_or_else(|| OpPerformance_OpMemory::new())
    }
}

impl ::protobuf::Message for OpPerformance {
    fn is_initialized(&self) -> bool {
        for v in &self.op {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.session_info {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(OpPerformance_oneof_execution_time::execution_time_normal(ref v)) = self.execution_time {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(OpPerformance_oneof_execution_time::execution_time_log_normal(ref v)) = self.execution_time {
            if !v.is_initialized() {
                return false;
            }
        }
        for v in &self.op_memory {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.op)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.session_info)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.temporary_memory_size = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compute_cost = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compute_time = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory_time = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.compute_efficiency = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.memory_efficiency = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.execution_time = ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_normal(is.read_message()?));
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.execution_time = ::std::option::Option::Some(OpPerformance_oneof_execution_time::execution_time_log_normal(is.read_message()?));
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.op_memory)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.op.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.session_info.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.node.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.node);
        }
        if self.temporary_memory_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.temporary_memory_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compute_cost != 0 {
            my_size += ::protobuf::rt::value_size(3, self.compute_cost, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compute_time != 0 {
            my_size += ::protobuf::rt::value_size(6, self.compute_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.memory_time != 0 {
            my_size += ::protobuf::rt::value_size(7, self.memory_time, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compute_efficiency != 0. {
            my_size += 9;
        }
        if self.memory_efficiency != 0. {
            my_size += 9;
        }
        if let Some(ref v) = self.op_memory.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.execution_time {
            match v {
                &OpPerformance_oneof_execution_time::execution_time_normal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &OpPerformance_oneof_execution_time::execution_time_log_normal(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.op.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.session_info.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.node.is_empty() {
            os.write_string(5, &self.node)?;
        }
        if self.temporary_memory_size != 0 {
            os.write_int64(2, self.temporary_memory_size)?;
        }
        if self.compute_cost != 0 {
            os.write_int64(3, self.compute_cost)?;
        }
        if self.compute_time != 0 {
            os.write_int64(6, self.compute_time)?;
        }
        if self.memory_time != 0 {
            os.write_int64(7, self.memory_time)?;
        }
        if self.compute_efficiency != 0. {
            os.write_double(4, self.compute_efficiency)?;
        }
        if self.memory_efficiency != 0. {
            os.write_double(8, self.memory_efficiency)?;
        }
        if let Some(ref v) = self.op_memory.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.execution_time {
            match v {
                &OpPerformance_oneof_execution_time::execution_time_normal(ref v) => {
                    os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &OpPerformance_oneof_execution_time::execution_time_log_normal(ref v) => {
                    os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpPerformance {
        OpPerformance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpInfo>>(
                "op",
                |m: &OpPerformance| { &m.op },
                |m: &mut OpPerformance| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SessionInfo>>(
                "session_info",
                |m: &OpPerformance| { &m.session_info },
                |m: &mut OpPerformance| { &mut m.session_info },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node",
                |m: &OpPerformance| { &m.node },
                |m: &mut OpPerformance| { &mut m.node },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "temporary_memory_size",
                |m: &OpPerformance| { &m.temporary_memory_size },
                |m: &mut OpPerformance| { &mut m.temporary_memory_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compute_cost",
                |m: &OpPerformance| { &m.compute_cost },
                |m: &mut OpPerformance| { &mut m.compute_cost },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compute_time",
                |m: &OpPerformance| { &m.compute_time },
                |m: &mut OpPerformance| { &mut m.compute_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "memory_time",
                |m: &OpPerformance| { &m.memory_time },
                |m: &mut OpPerformance| { &mut m.memory_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "compute_efficiency",
                |m: &OpPerformance| { &m.compute_efficiency },
                |m: &mut OpPerformance| { &mut m.compute_efficiency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "memory_efficiency",
                |m: &OpPerformance| { &m.memory_efficiency },
                |m: &mut OpPerformance| { &mut m.memory_efficiency },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, NormalDistribution>(
                "execution_time_normal",
                OpPerformance::has_execution_time_normal,
                OpPerformance::get_execution_time_normal,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, LogNormalDistribution>(
                "execution_time_log_normal",
                OpPerformance::has_execution_time_log_normal,
                OpPerformance::get_execution_time_log_normal,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpPerformance_OpMemory>>(
                "op_memory",
                |m: &OpPerformance| { &m.op_memory },
                |m: &mut OpPerformance| { &mut m.op_memory },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpPerformance>(
                "OpPerformance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpPerformance {
        static instance: ::protobuf::rt::LazyV2<OpPerformance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpPerformance::new)
    }
}

impl ::protobuf::Clear for OpPerformance {
    fn clear(&mut self) {
        self.op.clear();
        self.session_info.clear();
        self.node.clear();
        self.temporary_memory_size = 0;
        self.compute_cost = 0;
        self.compute_time = 0;
        self.memory_time = 0;
        self.compute_efficiency = 0.;
        self.memory_efficiency = 0.;
        self.execution_time = ::std::option::Option::None;
        self.execution_time = ::std::option::Option::None;
        self.op_memory.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpPerformance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpPerformance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpPerformance_OpMemory {
    // message fields
    pub output_memory: ::std::vec::Vec<i64>,
    pub temp_memory: i64,
    pub persistent_memory: i64,
    pub device_temp_memory: i64,
    pub device_persistent_memory: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpPerformance_OpMemory {
    fn default() -> &'a OpPerformance_OpMemory {
        <OpPerformance_OpMemory as ::protobuf::Message>::default_instance()
    }
}

impl OpPerformance_OpMemory {
    pub fn new() -> OpPerformance_OpMemory {
        ::std::default::Default::default()
    }

    // repeated int64 output_memory = 1;


    pub fn get_output_memory(&self) -> &[i64] {
        &self.output_memory
    }
    pub fn clear_output_memory(&mut self) {
        self.output_memory.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_memory(&mut self, v: ::std::vec::Vec<i64>) {
        self.output_memory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_memory(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.output_memory
    }

    // Take field
    pub fn take_output_memory(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.output_memory, ::std::vec::Vec::new())
    }

    // int64 temp_memory = 2;


    pub fn get_temp_memory(&self) -> i64 {
        self.temp_memory
    }
    pub fn clear_temp_memory(&mut self) {
        self.temp_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_temp_memory(&mut self, v: i64) {
        self.temp_memory = v;
    }

    // int64 persistent_memory = 4;


    pub fn get_persistent_memory(&self) -> i64 {
        self.persistent_memory
    }
    pub fn clear_persistent_memory(&mut self) {
        self.persistent_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_persistent_memory(&mut self, v: i64) {
        self.persistent_memory = v;
    }

    // int64 device_temp_memory = 3;


    pub fn get_device_temp_memory(&self) -> i64 {
        self.device_temp_memory
    }
    pub fn clear_device_temp_memory(&mut self) {
        self.device_temp_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_temp_memory(&mut self, v: i64) {
        self.device_temp_memory = v;
    }

    // int64 device_persistent_memory = 5;


    pub fn get_device_persistent_memory(&self) -> i64 {
        self.device_persistent_memory
    }
    pub fn clear_device_persistent_memory(&mut self) {
        self.device_persistent_memory = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_persistent_memory(&mut self, v: i64) {
        self.device_persistent_memory = v;
    }
}

impl ::protobuf::Message for OpPerformance_OpMemory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.output_memory)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.temp_memory = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.persistent_memory = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.device_temp_memory = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.device_persistent_memory = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.output_memory {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.temp_memory != 0 {
            my_size += ::protobuf::rt::value_size(2, self.temp_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.persistent_memory != 0 {
            my_size += ::protobuf::rt::value_size(4, self.persistent_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_temp_memory != 0 {
            my_size += ::protobuf::rt::value_size(3, self.device_temp_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_persistent_memory != 0 {
            my_size += ::protobuf::rt::value_size(5, self.device_persistent_memory, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.output_memory {
            os.write_int64(1, *v)?;
        };
        if self.temp_memory != 0 {
            os.write_int64(2, self.temp_memory)?;
        }
        if self.persistent_memory != 0 {
            os.write_int64(4, self.persistent_memory)?;
        }
        if self.device_temp_memory != 0 {
            os.write_int64(3, self.device_temp_memory)?;
        }
        if self.device_persistent_memory != 0 {
            os.write_int64(5, self.device_persistent_memory)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpPerformance_OpMemory {
        OpPerformance_OpMemory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "output_memory",
                |m: &OpPerformance_OpMemory| { &m.output_memory },
                |m: &mut OpPerformance_OpMemory| { &mut m.output_memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "temp_memory",
                |m: &OpPerformance_OpMemory| { &m.temp_memory },
                |m: &mut OpPerformance_OpMemory| { &mut m.temp_memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "persistent_memory",
                |m: &OpPerformance_OpMemory| { &m.persistent_memory },
                |m: &mut OpPerformance_OpMemory| { &mut m.persistent_memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "device_temp_memory",
                |m: &OpPerformance_OpMemory| { &m.device_temp_memory },
                |m: &mut OpPerformance_OpMemory| { &mut m.device_temp_memory },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "device_persistent_memory",
                |m: &OpPerformance_OpMemory| { &m.device_persistent_memory },
                |m: &mut OpPerformance_OpMemory| { &mut m.device_persistent_memory },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpPerformance_OpMemory>(
                "OpPerformance.OpMemory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpPerformance_OpMemory {
        static instance: ::protobuf::rt::LazyV2<OpPerformance_OpMemory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpPerformance_OpMemory::new)
    }
}

impl ::protobuf::Clear for OpPerformance_OpMemory {
    fn clear(&mut self) {
        self.output_memory.clear();
        self.temp_memory = 0;
        self.persistent_memory = 0;
        self.device_temp_memory = 0;
        self.device_persistent_memory = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpPerformance_OpMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpPerformance_OpMemory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpPerformanceList {
    // message fields
    pub op_performance: ::protobuf::RepeatedField<OpPerformance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpPerformanceList {
    fn default() -> &'a OpPerformanceList {
        <OpPerformanceList as ::protobuf::Message>::default_instance()
    }
}

impl OpPerformanceList {
    pub fn new() -> OpPerformanceList {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.OpPerformance op_performance = 1;


    pub fn get_op_performance(&self) -> &[OpPerformance] {
        &self.op_performance
    }
    pub fn clear_op_performance(&mut self) {
        self.op_performance.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_performance(&mut self, v: ::protobuf::RepeatedField<OpPerformance>) {
        self.op_performance = v;
    }

    // Mutable pointer to the field.
    pub fn mut_op_performance(&mut self) -> &mut ::protobuf::RepeatedField<OpPerformance> {
        &mut self.op_performance
    }

    // Take field
    pub fn take_op_performance(&mut self) -> ::protobuf::RepeatedField<OpPerformance> {
        ::std::mem::replace(&mut self.op_performance, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OpPerformanceList {
    fn is_initialized(&self) -> bool {
        for v in &self.op_performance {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.op_performance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.op_performance {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.op_performance {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpPerformanceList {
        OpPerformanceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpPerformance>>(
                "op_performance",
                |m: &OpPerformanceList| { &m.op_performance },
                |m: &mut OpPerformanceList| { &mut m.op_performance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpPerformanceList>(
                "OpPerformanceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpPerformanceList {
        static instance: ::protobuf::rt::LazyV2<OpPerformanceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpPerformanceList::new)
    }
}

impl ::protobuf::Clear for OpPerformanceList {
    fn clear(&mut self) {
        self.op_performance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpPerformanceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpPerformanceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n8tensorflow/core/grappler/costs/op_performance_data.proto\x12\ntensorf\
    low\x1a&tensorflow/core/framework/tensor.proto\x1a,tensorflow/core/frame\
    work/tensor_shape.proto\x1a%tensorflow/core/framework/types.proto\x1a*te\
    nsorflow/core/framework/attr_value.proto\x1a0tensorflow/core/protobuf/de\
    vice_properties.proto\"?\n\x0bSessionInfo\x120\n\x14intra_op_parallelism\
    \x18\x01\x20\x01(\x03R\x12intraOpParallelism\"\xac\x04\n\x06OpInfo\x12\
    \x0e\n\x02op\x18\x01\x20\x01(\tR\x02op\x120\n\x04attr\x18\x02\x20\x03(\
    \x0b2\x1c.tensorflow.OpInfo.AttrEntryR\x04attr\x12;\n\x06inputs\x18\x03\
    \x20\x03(\x0b2#.tensorflow.OpInfo.TensorPropertiesR\x06inputs\x12=\n\x07\
    outputs\x18\x05\x20\x03(\x0b2#.tensorflow.OpInfo.TensorPropertiesR\x07ou\
    tputs\x124\n\x06device\x18\x04\x20\x01(\x0b2\x1c.tensorflow.DeviceProper\
    tiesR\x06device\x12:\n\x0csession_info\x18\x06\x20\x01(\x0b2\x17.tensorf\
    low.SessionInfoR\x0bsessionInfo\x1aN\n\tAttrEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12+\n\x05value\x18\x02\x20\x01(\x0b2\x15.tensor\
    flow.AttrValueR\x05value:\x028\x01\x1a\xa1\x01\n\x10TensorProperties\x12\
    *\n\x05dtype\x18\x01\x20\x01(\x0e2\x14.tensorflow.DataTypeR\x05dtype\x12\
    2\n\x05shape\x18\x02\x20\x01(\x0b2\x1c.tensorflow.TensorShapeProtoR\x05s\
    hape\x12-\n\x05value\x18\x03\x20\x01(\x0b2\x17.tensorflow.TensorProtoR\
    \x05value\":\n\x12NormalDistribution\x12\x0e\n\x02mu\x18\x01\x20\x01(\
    \x01R\x02mu\x12\x14\n\x05sigma\x18\x02\x20\x01(\x01R\x05sigma\"=\n\x15Lo\
    gNormalDistribution\x12\x0e\n\x02mu\x18\x01\x20\x01(\x01R\x02mu\x12\x14\
    \n\x05sigma\x18\x02\x20\x01(\x01R\x05sigma\"\xf7\x06\n\rOpPerformance\
    \x12\"\n\x02op\x18\x01\x20\x01(\x0b2\x12.tensorflow.OpInfoR\x02op\x12>\n\
    \x0csession_info\x18\x0c\x20\x01(\x0b2\x17.tensorflow.SessionInfoR\x0bse\
    ssionInfoB\x02\x18\x01\x12\x12\n\x04node\x18\x05\x20\x01(\tR\x04node\x12\
    2\n\x15temporary_memory_size\x18\x02\x20\x01(\x03R\x13temporaryMemorySiz\
    e\x12!\n\x0ccompute_cost\x18\x03\x20\x01(\x03R\x0bcomputeCost\x12!\n\x0c\
    compute_time\x18\x06\x20\x01(\x03R\x0bcomputeTime\x12\x1f\n\x0bmemory_ti\
    me\x18\x07\x20\x01(\x03R\nmemoryTime\x12-\n\x12compute_efficiency\x18\
    \x04\x20\x01(\x01R\x11computeEfficiency\x12+\n\x11memory_efficiency\x18\
    \x08\x20\x01(\x01R\x10memoryEfficiency\x12T\n\x15execution_time_normal\
    \x18\n\x20\x01(\x0b2\x1e.tensorflow.NormalDistributionH\0R\x13executionT\
    imeNormal\x12^\n\x19execution_time_log_normal\x18\x0b\x20\x01(\x0b2!.ten\
    sorflow.LogNormalDistributionH\0R\x16executionTimeLogNormal\x12?\n\top_m\
    emory\x18\t\x20\x01(\x0b2\".tensorflow.OpPerformance.OpMemoryR\x08opMemo\
    ry\x1a\xed\x01\n\x08OpMemory\x12#\n\routput_memory\x18\x01\x20\x03(\x03R\
    \x0coutputMemory\x12\x1f\n\x0btemp_memory\x18\x02\x20\x01(\x03R\ntempMem\
    ory\x12+\n\x11persistent_memory\x18\x04\x20\x01(\x03R\x10persistentMemor\
    y\x120\n\x12device_temp_memory\x18\x03\x20\x01(\x03R\x10deviceTempMemory\
    B\x02\x18\x01\x12<\n\x18device_persistent_memory\x18\x05\x20\x01(\x03R\
    \x16devicePersistentMemoryB\x02\x18\x01B\x10\n\x0eexecution_time\"U\n\
    \x11OpPerformanceList\x12@\n\x0eop_performance\x18\x01\x20\x03(\x0b2\x19\
    .tensorflow.OpPerformanceR\ropPerformanceB\x03\xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
