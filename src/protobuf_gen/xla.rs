// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/compiler/xla/xla.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct HloReducePrecisionOptions {
    // message fields
    pub location: HloReducePrecisionOptions_Location,
    pub exponent_bits: u32,
    pub mantissa_bits: u32,
    pub opcodes_to_suffix: ::std::vec::Vec<u32>,
    pub opname_substrings_to_suffix: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HloReducePrecisionOptions {
    fn default() -> &'a HloReducePrecisionOptions {
        <HloReducePrecisionOptions as ::protobuf::Message>::default_instance()
    }
}

impl HloReducePrecisionOptions {
    pub fn new() -> HloReducePrecisionOptions {
        ::std::default::Default::default()
    }

    // .xla.HloReducePrecisionOptions.Location location = 1;


    pub fn get_location(&self) -> HloReducePrecisionOptions_Location {
        self.location
    }
    pub fn clear_location(&mut self) {
        self.location = HloReducePrecisionOptions_Location::OP_INPUTS;
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: HloReducePrecisionOptions_Location) {
        self.location = v;
    }

    // uint32 exponent_bits = 2;


    pub fn get_exponent_bits(&self) -> u32 {
        self.exponent_bits
    }
    pub fn clear_exponent_bits(&mut self) {
        self.exponent_bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_exponent_bits(&mut self, v: u32) {
        self.exponent_bits = v;
    }

    // uint32 mantissa_bits = 3;


    pub fn get_mantissa_bits(&self) -> u32 {
        self.mantissa_bits
    }
    pub fn clear_mantissa_bits(&mut self) {
        self.mantissa_bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_mantissa_bits(&mut self, v: u32) {
        self.mantissa_bits = v;
    }

    // repeated uint32 opcodes_to_suffix = 4;


    pub fn get_opcodes_to_suffix(&self) -> &[u32] {
        &self.opcodes_to_suffix
    }
    pub fn clear_opcodes_to_suffix(&mut self) {
        self.opcodes_to_suffix.clear();
    }

    // Param is passed by value, moved
    pub fn set_opcodes_to_suffix(&mut self, v: ::std::vec::Vec<u32>) {
        self.opcodes_to_suffix = v;
    }

    // Mutable pointer to the field.
    pub fn mut_opcodes_to_suffix(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.opcodes_to_suffix
    }

    // Take field
    pub fn take_opcodes_to_suffix(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.opcodes_to_suffix, ::std::vec::Vec::new())
    }

    // repeated string opname_substrings_to_suffix = 5;


    pub fn get_opname_substrings_to_suffix(&self) -> &[::std::string::String] {
        &self.opname_substrings_to_suffix
    }
    pub fn clear_opname_substrings_to_suffix(&mut self) {
        self.opname_substrings_to_suffix.clear();
    }

    // Param is passed by value, moved
    pub fn set_opname_substrings_to_suffix(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.opname_substrings_to_suffix = v;
    }

    // Mutable pointer to the field.
    pub fn mut_opname_substrings_to_suffix(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.opname_substrings_to_suffix
    }

    // Take field
    pub fn take_opname_substrings_to_suffix(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.opname_substrings_to_suffix, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HloReducePrecisionOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.location, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.exponent_bits = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.mantissa_bits = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.opcodes_to_suffix)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.opname_substrings_to_suffix)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.location != HloReducePrecisionOptions_Location::OP_INPUTS {
            my_size += ::protobuf::rt::enum_size(1, self.location);
        }
        if self.exponent_bits != 0 {
            my_size += ::protobuf::rt::value_size(2, self.exponent_bits, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mantissa_bits != 0 {
            my_size += ::protobuf::rt::value_size(3, self.mantissa_bits, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.opcodes_to_suffix {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.opname_substrings_to_suffix {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.location != HloReducePrecisionOptions_Location::OP_INPUTS {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.location))?;
        }
        if self.exponent_bits != 0 {
            os.write_uint32(2, self.exponent_bits)?;
        }
        if self.mantissa_bits != 0 {
            os.write_uint32(3, self.mantissa_bits)?;
        }
        for v in &self.opcodes_to_suffix {
            os.write_uint32(4, *v)?;
        };
        for v in &self.opname_substrings_to_suffix {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HloReducePrecisionOptions {
        HloReducePrecisionOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<HloReducePrecisionOptions_Location>>(
                "location",
                |m: &HloReducePrecisionOptions| { &m.location },
                |m: &mut HloReducePrecisionOptions| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "exponent_bits",
                |m: &HloReducePrecisionOptions| { &m.exponent_bits },
                |m: &mut HloReducePrecisionOptions| { &mut m.exponent_bits },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "mantissa_bits",
                |m: &HloReducePrecisionOptions| { &m.mantissa_bits },
                |m: &mut HloReducePrecisionOptions| { &mut m.mantissa_bits },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "opcodes_to_suffix",
                |m: &HloReducePrecisionOptions| { &m.opcodes_to_suffix },
                |m: &mut HloReducePrecisionOptions| { &mut m.opcodes_to_suffix },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "opname_substrings_to_suffix",
                |m: &HloReducePrecisionOptions| { &m.opname_substrings_to_suffix },
                |m: &mut HloReducePrecisionOptions| { &mut m.opname_substrings_to_suffix },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HloReducePrecisionOptions>(
                "HloReducePrecisionOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HloReducePrecisionOptions {
        static instance: ::protobuf::rt::LazyV2<HloReducePrecisionOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HloReducePrecisionOptions::new)
    }
}

impl ::protobuf::Clear for HloReducePrecisionOptions {
    fn clear(&mut self) {
        self.location = HloReducePrecisionOptions_Location::OP_INPUTS;
        self.exponent_bits = 0;
        self.mantissa_bits = 0;
        self.opcodes_to_suffix.clear();
        self.opname_substrings_to_suffix.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HloReducePrecisionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HloReducePrecisionOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum HloReducePrecisionOptions_Location {
    OP_INPUTS = 0,
    OP_OUTPUTS = 1,
    UNFUSED_OP_OUTPUTS = 2,
    FUSION_INPUTS_BY_CONTENT = 3,
    FUSION_OUTPUTS_BY_CONTENT = 4,
}

impl ::protobuf::ProtobufEnum for HloReducePrecisionOptions_Location {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<HloReducePrecisionOptions_Location> {
        match value {
            0 => ::std::option::Option::Some(HloReducePrecisionOptions_Location::OP_INPUTS),
            1 => ::std::option::Option::Some(HloReducePrecisionOptions_Location::OP_OUTPUTS),
            2 => ::std::option::Option::Some(HloReducePrecisionOptions_Location::UNFUSED_OP_OUTPUTS),
            3 => ::std::option::Option::Some(HloReducePrecisionOptions_Location::FUSION_INPUTS_BY_CONTENT),
            4 => ::std::option::Option::Some(HloReducePrecisionOptions_Location::FUSION_OUTPUTS_BY_CONTENT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [HloReducePrecisionOptions_Location] = &[
            HloReducePrecisionOptions_Location::OP_INPUTS,
            HloReducePrecisionOptions_Location::OP_OUTPUTS,
            HloReducePrecisionOptions_Location::UNFUSED_OP_OUTPUTS,
            HloReducePrecisionOptions_Location::FUSION_INPUTS_BY_CONTENT,
            HloReducePrecisionOptions_Location::FUSION_OUTPUTS_BY_CONTENT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<HloReducePrecisionOptions_Location>("HloReducePrecisionOptions.Location", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for HloReducePrecisionOptions_Location {
}

impl ::std::default::Default for HloReducePrecisionOptions_Location {
    fn default() -> Self {
        HloReducePrecisionOptions_Location::OP_INPUTS
    }
}

impl ::protobuf::reflect::ProtobufValue for HloReducePrecisionOptions_Location {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DebugOptions {
    // message fields
    pub xla_hlo_graph_addresses: bool,
    pub xla_hlo_profile: bool,
    pub xla_disable_hlo_passes: ::protobuf::RepeatedField<::std::string::String>,
    pub xla_enable_hlo_passes_only: ::protobuf::RepeatedField<::std::string::String>,
    pub xla_disable_all_hlo_passes: bool,
    pub xla_backend_optimization_level: i32,
    pub xla_embed_ir_in_executable: bool,
    pub xla_eliminate_hlo_implicit_broadcast: bool,
    pub xla_cpu_multi_thread_eigen: bool,
    pub xla_gpu_cuda_data_dir: ::std::string::String,
    pub xla_gpu_ftz: bool,
    pub xla_gpu_disable_multi_streaming: bool,
    pub xla_llvm_enable_alias_scope_metadata: bool,
    pub xla_llvm_enable_noalias_metadata: bool,
    pub xla_llvm_enable_invariant_load_metadata: bool,
    pub xla_llvm_disable_expensive_passes: bool,
    pub hlo_reduce_precision_options: ::protobuf::RepeatedField<HloReducePrecisionOptions>,
    pub xla_test_all_output_layouts: bool,
    pub xla_test_all_input_layouts: bool,
    pub xla_hlo_graph_sharding_color: bool,
    pub xla_gpu_use_cudnn_batchnorm: bool,
    pub xla_cpu_use_mkl_dnn: bool,
    pub xla_gpu_max_kernel_unroll_factor: i32,
    pub xla_cpu_enable_fast_math: bool,
    pub xla_cpu_fast_math_honor_nans: bool,
    pub xla_cpu_fast_math_honor_infs: bool,
    pub xla_cpu_fast_math_honor_division: bool,
    pub xla_cpu_fast_math_honor_functions: bool,
    pub xla_gpu_enable_fast_min_max: bool,
    pub xla_allow_excess_precision: bool,
    pub xla_gpu_crash_on_verification_failures: bool,
    pub xla_gpu_disable_autotune: bool,
    pub xla_force_host_platform_device_count: i32,
    pub xla_gpu_disable_ptxas_optimizations: bool,
    pub xla_hlo_evaluator_use_fast_path: bool,
    pub xla_allow_scalar_index_dynamic_ops: bool,
    pub xla_step_marker_location: DebugOptions_StepMarkerLocation,
    pub xla_dump_to: ::std::string::String,
    pub xla_dump_hlo_module_re: ::std::string::String,
    pub xla_dump_hlo_pass_re: ::std::string::String,
    pub xla_dump_hlo_as_text: bool,
    pub xla_dump_hlo_as_proto: bool,
    pub xla_dump_hlo_as_dot: bool,
    pub xla_dump_hlo_as_url: bool,
    pub xla_dump_hlo_as_html: bool,
    pub xla_dump_hlo_snapshots: bool,
    pub xla_gpu_force_conv_nchw: bool,
    pub xla_gpu_ptx_file: ::protobuf::RepeatedField<::std::string::String>,
    pub xla_gpu_algorithm_blacklist_path: ::std::string::String,
    pub xla_backend_extra_options: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DebugOptions {
    fn default() -> &'a DebugOptions {
        <DebugOptions as ::protobuf::Message>::default_instance()
    }
}

impl DebugOptions {
    pub fn new() -> DebugOptions {
        ::std::default::Default::default()
    }

    // bool xla_hlo_graph_addresses = 2;


    pub fn get_xla_hlo_graph_addresses(&self) -> bool {
        self.xla_hlo_graph_addresses
    }
    pub fn clear_xla_hlo_graph_addresses(&mut self) {
        self.xla_hlo_graph_addresses = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_hlo_graph_addresses(&mut self, v: bool) {
        self.xla_hlo_graph_addresses = v;
    }

    // bool xla_hlo_profile = 9;


    pub fn get_xla_hlo_profile(&self) -> bool {
        self.xla_hlo_profile
    }
    pub fn clear_xla_hlo_profile(&mut self) {
        self.xla_hlo_profile = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_hlo_profile(&mut self, v: bool) {
        self.xla_hlo_profile = v;
    }

    // repeated string xla_disable_hlo_passes = 30;


    pub fn get_xla_disable_hlo_passes(&self) -> &[::std::string::String] {
        &self.xla_disable_hlo_passes
    }
    pub fn clear_xla_disable_hlo_passes(&mut self) {
        self.xla_disable_hlo_passes.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_disable_hlo_passes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.xla_disable_hlo_passes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xla_disable_hlo_passes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.xla_disable_hlo_passes
    }

    // Take field
    pub fn take_xla_disable_hlo_passes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.xla_disable_hlo_passes, ::protobuf::RepeatedField::new())
    }

    // repeated string xla_enable_hlo_passes_only = 124;


    pub fn get_xla_enable_hlo_passes_only(&self) -> &[::std::string::String] {
        &self.xla_enable_hlo_passes_only
    }
    pub fn clear_xla_enable_hlo_passes_only(&mut self) {
        self.xla_enable_hlo_passes_only.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_enable_hlo_passes_only(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.xla_enable_hlo_passes_only = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xla_enable_hlo_passes_only(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.xla_enable_hlo_passes_only
    }

    // Take field
    pub fn take_xla_enable_hlo_passes_only(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.xla_enable_hlo_passes_only, ::protobuf::RepeatedField::new())
    }

    // bool xla_disable_all_hlo_passes = 104;


    pub fn get_xla_disable_all_hlo_passes(&self) -> bool {
        self.xla_disable_all_hlo_passes
    }
    pub fn clear_xla_disable_all_hlo_passes(&mut self) {
        self.xla_disable_all_hlo_passes = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_disable_all_hlo_passes(&mut self, v: bool) {
        self.xla_disable_all_hlo_passes = v;
    }

    // int32 xla_backend_optimization_level = 31;


    pub fn get_xla_backend_optimization_level(&self) -> i32 {
        self.xla_backend_optimization_level
    }
    pub fn clear_xla_backend_optimization_level(&mut self) {
        self.xla_backend_optimization_level = 0;
    }

    // Param is passed by value, moved
    pub fn set_xla_backend_optimization_level(&mut self, v: i32) {
        self.xla_backend_optimization_level = v;
    }

    // bool xla_embed_ir_in_executable = 33;


    pub fn get_xla_embed_ir_in_executable(&self) -> bool {
        self.xla_embed_ir_in_executable
    }
    pub fn clear_xla_embed_ir_in_executable(&mut self) {
        self.xla_embed_ir_in_executable = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_embed_ir_in_executable(&mut self, v: bool) {
        self.xla_embed_ir_in_executable = v;
    }

    // bool xla_eliminate_hlo_implicit_broadcast = 35;


    pub fn get_xla_eliminate_hlo_implicit_broadcast(&self) -> bool {
        self.xla_eliminate_hlo_implicit_broadcast
    }
    pub fn clear_xla_eliminate_hlo_implicit_broadcast(&mut self) {
        self.xla_eliminate_hlo_implicit_broadcast = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_eliminate_hlo_implicit_broadcast(&mut self, v: bool) {
        self.xla_eliminate_hlo_implicit_broadcast = v;
    }

    // bool xla_cpu_multi_thread_eigen = 60;


    pub fn get_xla_cpu_multi_thread_eigen(&self) -> bool {
        self.xla_cpu_multi_thread_eigen
    }
    pub fn clear_xla_cpu_multi_thread_eigen(&mut self) {
        self.xla_cpu_multi_thread_eigen = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_cpu_multi_thread_eigen(&mut self, v: bool) {
        self.xla_cpu_multi_thread_eigen = v;
    }

    // string xla_gpu_cuda_data_dir = 61;


    pub fn get_xla_gpu_cuda_data_dir(&self) -> &str {
        &self.xla_gpu_cuda_data_dir
    }
    pub fn clear_xla_gpu_cuda_data_dir(&mut self) {
        self.xla_gpu_cuda_data_dir.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_cuda_data_dir(&mut self, v: ::std::string::String) {
        self.xla_gpu_cuda_data_dir = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xla_gpu_cuda_data_dir(&mut self) -> &mut ::std::string::String {
        &mut self.xla_gpu_cuda_data_dir
    }

    // Take field
    pub fn take_xla_gpu_cuda_data_dir(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.xla_gpu_cuda_data_dir, ::std::string::String::new())
    }

    // bool xla_gpu_ftz = 62;


    pub fn get_xla_gpu_ftz(&self) -> bool {
        self.xla_gpu_ftz
    }
    pub fn clear_xla_gpu_ftz(&mut self) {
        self.xla_gpu_ftz = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_ftz(&mut self, v: bool) {
        self.xla_gpu_ftz = v;
    }

    // bool xla_gpu_disable_multi_streaming = 63;


    pub fn get_xla_gpu_disable_multi_streaming(&self) -> bool {
        self.xla_gpu_disable_multi_streaming
    }
    pub fn clear_xla_gpu_disable_multi_streaming(&mut self) {
        self.xla_gpu_disable_multi_streaming = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_disable_multi_streaming(&mut self, v: bool) {
        self.xla_gpu_disable_multi_streaming = v;
    }

    // bool xla_llvm_enable_alias_scope_metadata = 70;


    pub fn get_xla_llvm_enable_alias_scope_metadata(&self) -> bool {
        self.xla_llvm_enable_alias_scope_metadata
    }
    pub fn clear_xla_llvm_enable_alias_scope_metadata(&mut self) {
        self.xla_llvm_enable_alias_scope_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_llvm_enable_alias_scope_metadata(&mut self, v: bool) {
        self.xla_llvm_enable_alias_scope_metadata = v;
    }

    // bool xla_llvm_enable_noalias_metadata = 71;


    pub fn get_xla_llvm_enable_noalias_metadata(&self) -> bool {
        self.xla_llvm_enable_noalias_metadata
    }
    pub fn clear_xla_llvm_enable_noalias_metadata(&mut self) {
        self.xla_llvm_enable_noalias_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_llvm_enable_noalias_metadata(&mut self, v: bool) {
        self.xla_llvm_enable_noalias_metadata = v;
    }

    // bool xla_llvm_enable_invariant_load_metadata = 72;


    pub fn get_xla_llvm_enable_invariant_load_metadata(&self) -> bool {
        self.xla_llvm_enable_invariant_load_metadata
    }
    pub fn clear_xla_llvm_enable_invariant_load_metadata(&mut self) {
        self.xla_llvm_enable_invariant_load_metadata = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_llvm_enable_invariant_load_metadata(&mut self, v: bool) {
        self.xla_llvm_enable_invariant_load_metadata = v;
    }

    // bool xla_llvm_disable_expensive_passes = 73;


    pub fn get_xla_llvm_disable_expensive_passes(&self) -> bool {
        self.xla_llvm_disable_expensive_passes
    }
    pub fn clear_xla_llvm_disable_expensive_passes(&mut self) {
        self.xla_llvm_disable_expensive_passes = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_llvm_disable_expensive_passes(&mut self, v: bool) {
        self.xla_llvm_disable_expensive_passes = v;
    }

    // repeated .xla.HloReducePrecisionOptions hlo_reduce_precision_options = 80;


    pub fn get_hlo_reduce_precision_options(&self) -> &[HloReducePrecisionOptions] {
        &self.hlo_reduce_precision_options
    }
    pub fn clear_hlo_reduce_precision_options(&mut self) {
        self.hlo_reduce_precision_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_hlo_reduce_precision_options(&mut self, v: ::protobuf::RepeatedField<HloReducePrecisionOptions>) {
        self.hlo_reduce_precision_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hlo_reduce_precision_options(&mut self) -> &mut ::protobuf::RepeatedField<HloReducePrecisionOptions> {
        &mut self.hlo_reduce_precision_options
    }

    // Take field
    pub fn take_hlo_reduce_precision_options(&mut self) -> ::protobuf::RepeatedField<HloReducePrecisionOptions> {
        ::std::mem::replace(&mut self.hlo_reduce_precision_options, ::protobuf::RepeatedField::new())
    }

    // bool xla_test_all_output_layouts = 90;


    pub fn get_xla_test_all_output_layouts(&self) -> bool {
        self.xla_test_all_output_layouts
    }
    pub fn clear_xla_test_all_output_layouts(&mut self) {
        self.xla_test_all_output_layouts = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_test_all_output_layouts(&mut self, v: bool) {
        self.xla_test_all_output_layouts = v;
    }

    // bool xla_test_all_input_layouts = 91;


    pub fn get_xla_test_all_input_layouts(&self) -> bool {
        self.xla_test_all_input_layouts
    }
    pub fn clear_xla_test_all_input_layouts(&mut self) {
        self.xla_test_all_input_layouts = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_test_all_input_layouts(&mut self, v: bool) {
        self.xla_test_all_input_layouts = v;
    }

    // bool xla_hlo_graph_sharding_color = 92;


    pub fn get_xla_hlo_graph_sharding_color(&self) -> bool {
        self.xla_hlo_graph_sharding_color
    }
    pub fn clear_xla_hlo_graph_sharding_color(&mut self) {
        self.xla_hlo_graph_sharding_color = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_hlo_graph_sharding_color(&mut self, v: bool) {
        self.xla_hlo_graph_sharding_color = v;
    }

    // bool xla_gpu_use_cudnn_batchnorm = 94;


    pub fn get_xla_gpu_use_cudnn_batchnorm(&self) -> bool {
        self.xla_gpu_use_cudnn_batchnorm
    }
    pub fn clear_xla_gpu_use_cudnn_batchnorm(&mut self) {
        self.xla_gpu_use_cudnn_batchnorm = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_use_cudnn_batchnorm(&mut self, v: bool) {
        self.xla_gpu_use_cudnn_batchnorm = v;
    }

    // bool xla_cpu_use_mkl_dnn = 97;


    pub fn get_xla_cpu_use_mkl_dnn(&self) -> bool {
        self.xla_cpu_use_mkl_dnn
    }
    pub fn clear_xla_cpu_use_mkl_dnn(&mut self) {
        self.xla_cpu_use_mkl_dnn = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_cpu_use_mkl_dnn(&mut self, v: bool) {
        self.xla_cpu_use_mkl_dnn = v;
    }

    // int32 xla_gpu_max_kernel_unroll_factor = 98;


    pub fn get_xla_gpu_max_kernel_unroll_factor(&self) -> i32 {
        self.xla_gpu_max_kernel_unroll_factor
    }
    pub fn clear_xla_gpu_max_kernel_unroll_factor(&mut self) {
        self.xla_gpu_max_kernel_unroll_factor = 0;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_max_kernel_unroll_factor(&mut self, v: i32) {
        self.xla_gpu_max_kernel_unroll_factor = v;
    }

    // bool xla_cpu_enable_fast_math = 99;


    pub fn get_xla_cpu_enable_fast_math(&self) -> bool {
        self.xla_cpu_enable_fast_math
    }
    pub fn clear_xla_cpu_enable_fast_math(&mut self) {
        self.xla_cpu_enable_fast_math = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_cpu_enable_fast_math(&mut self, v: bool) {
        self.xla_cpu_enable_fast_math = v;
    }

    // bool xla_cpu_fast_math_honor_nans = 120;


    pub fn get_xla_cpu_fast_math_honor_nans(&self) -> bool {
        self.xla_cpu_fast_math_honor_nans
    }
    pub fn clear_xla_cpu_fast_math_honor_nans(&mut self) {
        self.xla_cpu_fast_math_honor_nans = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_cpu_fast_math_honor_nans(&mut self, v: bool) {
        self.xla_cpu_fast_math_honor_nans = v;
    }

    // bool xla_cpu_fast_math_honor_infs = 121;


    pub fn get_xla_cpu_fast_math_honor_infs(&self) -> bool {
        self.xla_cpu_fast_math_honor_infs
    }
    pub fn clear_xla_cpu_fast_math_honor_infs(&mut self) {
        self.xla_cpu_fast_math_honor_infs = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_cpu_fast_math_honor_infs(&mut self, v: bool) {
        self.xla_cpu_fast_math_honor_infs = v;
    }

    // bool xla_cpu_fast_math_honor_division = 126;


    pub fn get_xla_cpu_fast_math_honor_division(&self) -> bool {
        self.xla_cpu_fast_math_honor_division
    }
    pub fn clear_xla_cpu_fast_math_honor_division(&mut self) {
        self.xla_cpu_fast_math_honor_division = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_cpu_fast_math_honor_division(&mut self, v: bool) {
        self.xla_cpu_fast_math_honor_division = v;
    }

    // bool xla_cpu_fast_math_honor_functions = 129;


    pub fn get_xla_cpu_fast_math_honor_functions(&self) -> bool {
        self.xla_cpu_fast_math_honor_functions
    }
    pub fn clear_xla_cpu_fast_math_honor_functions(&mut self) {
        self.xla_cpu_fast_math_honor_functions = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_cpu_fast_math_honor_functions(&mut self, v: bool) {
        self.xla_cpu_fast_math_honor_functions = v;
    }

    // bool xla_gpu_enable_fast_min_max = 100;


    pub fn get_xla_gpu_enable_fast_min_max(&self) -> bool {
        self.xla_gpu_enable_fast_min_max
    }
    pub fn clear_xla_gpu_enable_fast_min_max(&mut self) {
        self.xla_gpu_enable_fast_min_max = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_enable_fast_min_max(&mut self, v: bool) {
        self.xla_gpu_enable_fast_min_max = v;
    }

    // bool xla_allow_excess_precision = 122;


    pub fn get_xla_allow_excess_precision(&self) -> bool {
        self.xla_allow_excess_precision
    }
    pub fn clear_xla_allow_excess_precision(&mut self) {
        self.xla_allow_excess_precision = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_allow_excess_precision(&mut self, v: bool) {
        self.xla_allow_excess_precision = v;
    }

    // bool xla_gpu_crash_on_verification_failures = 101;


    pub fn get_xla_gpu_crash_on_verification_failures(&self) -> bool {
        self.xla_gpu_crash_on_verification_failures
    }
    pub fn clear_xla_gpu_crash_on_verification_failures(&mut self) {
        self.xla_gpu_crash_on_verification_failures = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_crash_on_verification_failures(&mut self, v: bool) {
        self.xla_gpu_crash_on_verification_failures = v;
    }

    // bool xla_gpu_disable_autotune = 123;


    pub fn get_xla_gpu_disable_autotune(&self) -> bool {
        self.xla_gpu_disable_autotune
    }
    pub fn clear_xla_gpu_disable_autotune(&mut self) {
        self.xla_gpu_disable_autotune = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_disable_autotune(&mut self, v: bool) {
        self.xla_gpu_disable_autotune = v;
    }

    // int32 xla_force_host_platform_device_count = 102;


    pub fn get_xla_force_host_platform_device_count(&self) -> i32 {
        self.xla_force_host_platform_device_count
    }
    pub fn clear_xla_force_host_platform_device_count(&mut self) {
        self.xla_force_host_platform_device_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_xla_force_host_platform_device_count(&mut self, v: i32) {
        self.xla_force_host_platform_device_count = v;
    }

    // bool xla_gpu_disable_ptxas_optimizations = 103;


    pub fn get_xla_gpu_disable_ptxas_optimizations(&self) -> bool {
        self.xla_gpu_disable_ptxas_optimizations
    }
    pub fn clear_xla_gpu_disable_ptxas_optimizations(&mut self) {
        self.xla_gpu_disable_ptxas_optimizations = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_disable_ptxas_optimizations(&mut self, v: bool) {
        self.xla_gpu_disable_ptxas_optimizations = v;
    }

    // bool xla_hlo_evaluator_use_fast_path = 106;


    pub fn get_xla_hlo_evaluator_use_fast_path(&self) -> bool {
        self.xla_hlo_evaluator_use_fast_path
    }
    pub fn clear_xla_hlo_evaluator_use_fast_path(&mut self) {
        self.xla_hlo_evaluator_use_fast_path = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_hlo_evaluator_use_fast_path(&mut self, v: bool) {
        self.xla_hlo_evaluator_use_fast_path = v;
    }

    // bool xla_allow_scalar_index_dynamic_ops = 107;


    pub fn get_xla_allow_scalar_index_dynamic_ops(&self) -> bool {
        self.xla_allow_scalar_index_dynamic_ops
    }
    pub fn clear_xla_allow_scalar_index_dynamic_ops(&mut self) {
        self.xla_allow_scalar_index_dynamic_ops = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_allow_scalar_index_dynamic_ops(&mut self, v: bool) {
        self.xla_allow_scalar_index_dynamic_ops = v;
    }

    // .xla.DebugOptions.StepMarkerLocation xla_step_marker_location = 108;


    pub fn get_xla_step_marker_location(&self) -> DebugOptions_StepMarkerLocation {
        self.xla_step_marker_location
    }
    pub fn clear_xla_step_marker_location(&mut self) {
        self.xla_step_marker_location = DebugOptions_StepMarkerLocation::STEP_MARK_AT_ENTRY;
    }

    // Param is passed by value, moved
    pub fn set_xla_step_marker_location(&mut self, v: DebugOptions_StepMarkerLocation) {
        self.xla_step_marker_location = v;
    }

    // string xla_dump_to = 109;


    pub fn get_xla_dump_to(&self) -> &str {
        &self.xla_dump_to
    }
    pub fn clear_xla_dump_to(&mut self) {
        self.xla_dump_to.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_to(&mut self, v: ::std::string::String) {
        self.xla_dump_to = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xla_dump_to(&mut self) -> &mut ::std::string::String {
        &mut self.xla_dump_to
    }

    // Take field
    pub fn take_xla_dump_to(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.xla_dump_to, ::std::string::String::new())
    }

    // string xla_dump_hlo_module_re = 110;


    pub fn get_xla_dump_hlo_module_re(&self) -> &str {
        &self.xla_dump_hlo_module_re
    }
    pub fn clear_xla_dump_hlo_module_re(&mut self) {
        self.xla_dump_hlo_module_re.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_module_re(&mut self, v: ::std::string::String) {
        self.xla_dump_hlo_module_re = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xla_dump_hlo_module_re(&mut self) -> &mut ::std::string::String {
        &mut self.xla_dump_hlo_module_re
    }

    // Take field
    pub fn take_xla_dump_hlo_module_re(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.xla_dump_hlo_module_re, ::std::string::String::new())
    }

    // string xla_dump_hlo_pass_re = 111;


    pub fn get_xla_dump_hlo_pass_re(&self) -> &str {
        &self.xla_dump_hlo_pass_re
    }
    pub fn clear_xla_dump_hlo_pass_re(&mut self) {
        self.xla_dump_hlo_pass_re.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_pass_re(&mut self, v: ::std::string::String) {
        self.xla_dump_hlo_pass_re = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xla_dump_hlo_pass_re(&mut self) -> &mut ::std::string::String {
        &mut self.xla_dump_hlo_pass_re
    }

    // Take field
    pub fn take_xla_dump_hlo_pass_re(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.xla_dump_hlo_pass_re, ::std::string::String::new())
    }

    // bool xla_dump_hlo_as_text = 112;


    pub fn get_xla_dump_hlo_as_text(&self) -> bool {
        self.xla_dump_hlo_as_text
    }
    pub fn clear_xla_dump_hlo_as_text(&mut self) {
        self.xla_dump_hlo_as_text = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_as_text(&mut self, v: bool) {
        self.xla_dump_hlo_as_text = v;
    }

    // bool xla_dump_hlo_as_proto = 113;


    pub fn get_xla_dump_hlo_as_proto(&self) -> bool {
        self.xla_dump_hlo_as_proto
    }
    pub fn clear_xla_dump_hlo_as_proto(&mut self) {
        self.xla_dump_hlo_as_proto = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_as_proto(&mut self, v: bool) {
        self.xla_dump_hlo_as_proto = v;
    }

    // bool xla_dump_hlo_as_dot = 114;


    pub fn get_xla_dump_hlo_as_dot(&self) -> bool {
        self.xla_dump_hlo_as_dot
    }
    pub fn clear_xla_dump_hlo_as_dot(&mut self) {
        self.xla_dump_hlo_as_dot = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_as_dot(&mut self, v: bool) {
        self.xla_dump_hlo_as_dot = v;
    }

    // bool xla_dump_hlo_as_url = 115;


    pub fn get_xla_dump_hlo_as_url(&self) -> bool {
        self.xla_dump_hlo_as_url
    }
    pub fn clear_xla_dump_hlo_as_url(&mut self) {
        self.xla_dump_hlo_as_url = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_as_url(&mut self, v: bool) {
        self.xla_dump_hlo_as_url = v;
    }

    // bool xla_dump_hlo_as_html = 116;


    pub fn get_xla_dump_hlo_as_html(&self) -> bool {
        self.xla_dump_hlo_as_html
    }
    pub fn clear_xla_dump_hlo_as_html(&mut self) {
        self.xla_dump_hlo_as_html = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_as_html(&mut self, v: bool) {
        self.xla_dump_hlo_as_html = v;
    }

    // bool xla_dump_hlo_snapshots = 118;


    pub fn get_xla_dump_hlo_snapshots(&self) -> bool {
        self.xla_dump_hlo_snapshots
    }
    pub fn clear_xla_dump_hlo_snapshots(&mut self) {
        self.xla_dump_hlo_snapshots = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_dump_hlo_snapshots(&mut self, v: bool) {
        self.xla_dump_hlo_snapshots = v;
    }

    // bool xla_gpu_force_conv_nchw = 125;


    pub fn get_xla_gpu_force_conv_nchw(&self) -> bool {
        self.xla_gpu_force_conv_nchw
    }
    pub fn clear_xla_gpu_force_conv_nchw(&mut self) {
        self.xla_gpu_force_conv_nchw = false;
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_force_conv_nchw(&mut self, v: bool) {
        self.xla_gpu_force_conv_nchw = v;
    }

    // repeated string xla_gpu_ptx_file = 127;


    pub fn get_xla_gpu_ptx_file(&self) -> &[::std::string::String] {
        &self.xla_gpu_ptx_file
    }
    pub fn clear_xla_gpu_ptx_file(&mut self) {
        self.xla_gpu_ptx_file.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_ptx_file(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.xla_gpu_ptx_file = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xla_gpu_ptx_file(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.xla_gpu_ptx_file
    }

    // Take field
    pub fn take_xla_gpu_ptx_file(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.xla_gpu_ptx_file, ::protobuf::RepeatedField::new())
    }

    // string xla_gpu_algorithm_blacklist_path = 128;


    pub fn get_xla_gpu_algorithm_blacklist_path(&self) -> &str {
        &self.xla_gpu_algorithm_blacklist_path
    }
    pub fn clear_xla_gpu_algorithm_blacklist_path(&mut self) {
        self.xla_gpu_algorithm_blacklist_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_gpu_algorithm_blacklist_path(&mut self, v: ::std::string::String) {
        self.xla_gpu_algorithm_blacklist_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xla_gpu_algorithm_blacklist_path(&mut self) -> &mut ::std::string::String {
        &mut self.xla_gpu_algorithm_blacklist_path
    }

    // Take field
    pub fn take_xla_gpu_algorithm_blacklist_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.xla_gpu_algorithm_blacklist_path, ::std::string::String::new())
    }

    // repeated .xla.DebugOptions.XlaBackendExtraOptionsEntry xla_backend_extra_options = 500;


    pub fn get_xla_backend_extra_options(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.xla_backend_extra_options
    }
    pub fn clear_xla_backend_extra_options(&mut self) {
        self.xla_backend_extra_options.clear();
    }

    // Param is passed by value, moved
    pub fn set_xla_backend_extra_options(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.xla_backend_extra_options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_xla_backend_extra_options(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.xla_backend_extra_options
    }

    // Take field
    pub fn take_xla_backend_extra_options(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.xla_backend_extra_options, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for DebugOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.hlo_reduce_precision_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_hlo_graph_addresses = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_hlo_profile = tmp;
                },
                30 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.xla_disable_hlo_passes)?;
                },
                124 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.xla_enable_hlo_passes_only)?;
                },
                104 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_disable_all_hlo_passes = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.xla_backend_optimization_level = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_embed_ir_in_executable = tmp;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_eliminate_hlo_implicit_broadcast = tmp;
                },
                60 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_cpu_multi_thread_eigen = tmp;
                },
                61 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.xla_gpu_cuda_data_dir)?;
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_ftz = tmp;
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_disable_multi_streaming = tmp;
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_llvm_enable_alias_scope_metadata = tmp;
                },
                71 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_llvm_enable_noalias_metadata = tmp;
                },
                72 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_llvm_enable_invariant_load_metadata = tmp;
                },
                73 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_llvm_disable_expensive_passes = tmp;
                },
                80 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hlo_reduce_precision_options)?;
                },
                90 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_test_all_output_layouts = tmp;
                },
                91 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_test_all_input_layouts = tmp;
                },
                92 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_hlo_graph_sharding_color = tmp;
                },
                94 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_use_cudnn_batchnorm = tmp;
                },
                97 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_cpu_use_mkl_dnn = tmp;
                },
                98 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.xla_gpu_max_kernel_unroll_factor = tmp;
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_cpu_enable_fast_math = tmp;
                },
                120 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_cpu_fast_math_honor_nans = tmp;
                },
                121 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_cpu_fast_math_honor_infs = tmp;
                },
                126 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_cpu_fast_math_honor_division = tmp;
                },
                129 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_cpu_fast_math_honor_functions = tmp;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_enable_fast_min_max = tmp;
                },
                122 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_allow_excess_precision = tmp;
                },
                101 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_crash_on_verification_failures = tmp;
                },
                123 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_disable_autotune = tmp;
                },
                102 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.xla_force_host_platform_device_count = tmp;
                },
                103 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_disable_ptxas_optimizations = tmp;
                },
                106 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_hlo_evaluator_use_fast_path = tmp;
                },
                107 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_allow_scalar_index_dynamic_ops = tmp;
                },
                108 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.xla_step_marker_location, 108, &mut self.unknown_fields)?
                },
                109 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.xla_dump_to)?;
                },
                110 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.xla_dump_hlo_module_re)?;
                },
                111 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.xla_dump_hlo_pass_re)?;
                },
                112 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_dump_hlo_as_text = tmp;
                },
                113 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_dump_hlo_as_proto = tmp;
                },
                114 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_dump_hlo_as_dot = tmp;
                },
                115 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_dump_hlo_as_url = tmp;
                },
                116 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_dump_hlo_as_html = tmp;
                },
                118 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_dump_hlo_snapshots = tmp;
                },
                125 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.xla_gpu_force_conv_nchw = tmp;
                },
                127 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.xla_gpu_ptx_file)?;
                },
                128 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.xla_gpu_algorithm_blacklist_path)?;
                },
                500 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.xla_backend_extra_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.xla_hlo_graph_addresses != false {
            my_size += 2;
        }
        if self.xla_hlo_profile != false {
            my_size += 2;
        }
        for value in &self.xla_disable_hlo_passes {
            my_size += ::protobuf::rt::string_size(30, &value);
        };
        for value in &self.xla_enable_hlo_passes_only {
            my_size += ::protobuf::rt::string_size(124, &value);
        };
        if self.xla_disable_all_hlo_passes != false {
            my_size += 3;
        }
        if self.xla_backend_optimization_level != 0 {
            my_size += ::protobuf::rt::value_size(31, self.xla_backend_optimization_level, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.xla_embed_ir_in_executable != false {
            my_size += 3;
        }
        if self.xla_eliminate_hlo_implicit_broadcast != false {
            my_size += 3;
        }
        if self.xla_cpu_multi_thread_eigen != false {
            my_size += 3;
        }
        if !self.xla_gpu_cuda_data_dir.is_empty() {
            my_size += ::protobuf::rt::string_size(61, &self.xla_gpu_cuda_data_dir);
        }
        if self.xla_gpu_ftz != false {
            my_size += 3;
        }
        if self.xla_gpu_disable_multi_streaming != false {
            my_size += 3;
        }
        if self.xla_llvm_enable_alias_scope_metadata != false {
            my_size += 3;
        }
        if self.xla_llvm_enable_noalias_metadata != false {
            my_size += 3;
        }
        if self.xla_llvm_enable_invariant_load_metadata != false {
            my_size += 3;
        }
        if self.xla_llvm_disable_expensive_passes != false {
            my_size += 3;
        }
        for value in &self.hlo_reduce_precision_options {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.xla_test_all_output_layouts != false {
            my_size += 3;
        }
        if self.xla_test_all_input_layouts != false {
            my_size += 3;
        }
        if self.xla_hlo_graph_sharding_color != false {
            my_size += 3;
        }
        if self.xla_gpu_use_cudnn_batchnorm != false {
            my_size += 3;
        }
        if self.xla_cpu_use_mkl_dnn != false {
            my_size += 3;
        }
        if self.xla_gpu_max_kernel_unroll_factor != 0 {
            my_size += ::protobuf::rt::value_size(98, self.xla_gpu_max_kernel_unroll_factor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.xla_cpu_enable_fast_math != false {
            my_size += 3;
        }
        if self.xla_cpu_fast_math_honor_nans != false {
            my_size += 3;
        }
        if self.xla_cpu_fast_math_honor_infs != false {
            my_size += 3;
        }
        if self.xla_cpu_fast_math_honor_division != false {
            my_size += 3;
        }
        if self.xla_cpu_fast_math_honor_functions != false {
            my_size += 3;
        }
        if self.xla_gpu_enable_fast_min_max != false {
            my_size += 3;
        }
        if self.xla_allow_excess_precision != false {
            my_size += 3;
        }
        if self.xla_gpu_crash_on_verification_failures != false {
            my_size += 3;
        }
        if self.xla_gpu_disable_autotune != false {
            my_size += 3;
        }
        if self.xla_force_host_platform_device_count != 0 {
            my_size += ::protobuf::rt::value_size(102, self.xla_force_host_platform_device_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.xla_gpu_disable_ptxas_optimizations != false {
            my_size += 3;
        }
        if self.xla_hlo_evaluator_use_fast_path != false {
            my_size += 3;
        }
        if self.xla_allow_scalar_index_dynamic_ops != false {
            my_size += 3;
        }
        if self.xla_step_marker_location != DebugOptions_StepMarkerLocation::STEP_MARK_AT_ENTRY {
            my_size += ::protobuf::rt::enum_size(108, self.xla_step_marker_location);
        }
        if !self.xla_dump_to.is_empty() {
            my_size += ::protobuf::rt::string_size(109, &self.xla_dump_to);
        }
        if !self.xla_dump_hlo_module_re.is_empty() {
            my_size += ::protobuf::rt::string_size(110, &self.xla_dump_hlo_module_re);
        }
        if !self.xla_dump_hlo_pass_re.is_empty() {
            my_size += ::protobuf::rt::string_size(111, &self.xla_dump_hlo_pass_re);
        }
        if self.xla_dump_hlo_as_text != false {
            my_size += 3;
        }
        if self.xla_dump_hlo_as_proto != false {
            my_size += 3;
        }
        if self.xla_dump_hlo_as_dot != false {
            my_size += 3;
        }
        if self.xla_dump_hlo_as_url != false {
            my_size += 3;
        }
        if self.xla_dump_hlo_as_html != false {
            my_size += 3;
        }
        if self.xla_dump_hlo_snapshots != false {
            my_size += 3;
        }
        if self.xla_gpu_force_conv_nchw != false {
            my_size += 3;
        }
        for value in &self.xla_gpu_ptx_file {
            my_size += ::protobuf::rt::string_size(127, &value);
        };
        if !self.xla_gpu_algorithm_blacklist_path.is_empty() {
            my_size += ::protobuf::rt::string_size(128, &self.xla_gpu_algorithm_blacklist_path);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(500, &self.xla_backend_extra_options);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.xla_hlo_graph_addresses != false {
            os.write_bool(2, self.xla_hlo_graph_addresses)?;
        }
        if self.xla_hlo_profile != false {
            os.write_bool(9, self.xla_hlo_profile)?;
        }
        for v in &self.xla_disable_hlo_passes {
            os.write_string(30, &v)?;
        };
        for v in &self.xla_enable_hlo_passes_only {
            os.write_string(124, &v)?;
        };
        if self.xla_disable_all_hlo_passes != false {
            os.write_bool(104, self.xla_disable_all_hlo_passes)?;
        }
        if self.xla_backend_optimization_level != 0 {
            os.write_int32(31, self.xla_backend_optimization_level)?;
        }
        if self.xla_embed_ir_in_executable != false {
            os.write_bool(33, self.xla_embed_ir_in_executable)?;
        }
        if self.xla_eliminate_hlo_implicit_broadcast != false {
            os.write_bool(35, self.xla_eliminate_hlo_implicit_broadcast)?;
        }
        if self.xla_cpu_multi_thread_eigen != false {
            os.write_bool(60, self.xla_cpu_multi_thread_eigen)?;
        }
        if !self.xla_gpu_cuda_data_dir.is_empty() {
            os.write_string(61, &self.xla_gpu_cuda_data_dir)?;
        }
        if self.xla_gpu_ftz != false {
            os.write_bool(62, self.xla_gpu_ftz)?;
        }
        if self.xla_gpu_disable_multi_streaming != false {
            os.write_bool(63, self.xla_gpu_disable_multi_streaming)?;
        }
        if self.xla_llvm_enable_alias_scope_metadata != false {
            os.write_bool(70, self.xla_llvm_enable_alias_scope_metadata)?;
        }
        if self.xla_llvm_enable_noalias_metadata != false {
            os.write_bool(71, self.xla_llvm_enable_noalias_metadata)?;
        }
        if self.xla_llvm_enable_invariant_load_metadata != false {
            os.write_bool(72, self.xla_llvm_enable_invariant_load_metadata)?;
        }
        if self.xla_llvm_disable_expensive_passes != false {
            os.write_bool(73, self.xla_llvm_disable_expensive_passes)?;
        }
        for v in &self.hlo_reduce_precision_options {
            os.write_tag(80, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.xla_test_all_output_layouts != false {
            os.write_bool(90, self.xla_test_all_output_layouts)?;
        }
        if self.xla_test_all_input_layouts != false {
            os.write_bool(91, self.xla_test_all_input_layouts)?;
        }
        if self.xla_hlo_graph_sharding_color != false {
            os.write_bool(92, self.xla_hlo_graph_sharding_color)?;
        }
        if self.xla_gpu_use_cudnn_batchnorm != false {
            os.write_bool(94, self.xla_gpu_use_cudnn_batchnorm)?;
        }
        if self.xla_cpu_use_mkl_dnn != false {
            os.write_bool(97, self.xla_cpu_use_mkl_dnn)?;
        }
        if self.xla_gpu_max_kernel_unroll_factor != 0 {
            os.write_int32(98, self.xla_gpu_max_kernel_unroll_factor)?;
        }
        if self.xla_cpu_enable_fast_math != false {
            os.write_bool(99, self.xla_cpu_enable_fast_math)?;
        }
        if self.xla_cpu_fast_math_honor_nans != false {
            os.write_bool(120, self.xla_cpu_fast_math_honor_nans)?;
        }
        if self.xla_cpu_fast_math_honor_infs != false {
            os.write_bool(121, self.xla_cpu_fast_math_honor_infs)?;
        }
        if self.xla_cpu_fast_math_honor_division != false {
            os.write_bool(126, self.xla_cpu_fast_math_honor_division)?;
        }
        if self.xla_cpu_fast_math_honor_functions != false {
            os.write_bool(129, self.xla_cpu_fast_math_honor_functions)?;
        }
        if self.xla_gpu_enable_fast_min_max != false {
            os.write_bool(100, self.xla_gpu_enable_fast_min_max)?;
        }
        if self.xla_allow_excess_precision != false {
            os.write_bool(122, self.xla_allow_excess_precision)?;
        }
        if self.xla_gpu_crash_on_verification_failures != false {
            os.write_bool(101, self.xla_gpu_crash_on_verification_failures)?;
        }
        if self.xla_gpu_disable_autotune != false {
            os.write_bool(123, self.xla_gpu_disable_autotune)?;
        }
        if self.xla_force_host_platform_device_count != 0 {
            os.write_int32(102, self.xla_force_host_platform_device_count)?;
        }
        if self.xla_gpu_disable_ptxas_optimizations != false {
            os.write_bool(103, self.xla_gpu_disable_ptxas_optimizations)?;
        }
        if self.xla_hlo_evaluator_use_fast_path != false {
            os.write_bool(106, self.xla_hlo_evaluator_use_fast_path)?;
        }
        if self.xla_allow_scalar_index_dynamic_ops != false {
            os.write_bool(107, self.xla_allow_scalar_index_dynamic_ops)?;
        }
        if self.xla_step_marker_location != DebugOptions_StepMarkerLocation::STEP_MARK_AT_ENTRY {
            os.write_enum(108, ::protobuf::ProtobufEnum::value(&self.xla_step_marker_location))?;
        }
        if !self.xla_dump_to.is_empty() {
            os.write_string(109, &self.xla_dump_to)?;
        }
        if !self.xla_dump_hlo_module_re.is_empty() {
            os.write_string(110, &self.xla_dump_hlo_module_re)?;
        }
        if !self.xla_dump_hlo_pass_re.is_empty() {
            os.write_string(111, &self.xla_dump_hlo_pass_re)?;
        }
        if self.xla_dump_hlo_as_text != false {
            os.write_bool(112, self.xla_dump_hlo_as_text)?;
        }
        if self.xla_dump_hlo_as_proto != false {
            os.write_bool(113, self.xla_dump_hlo_as_proto)?;
        }
        if self.xla_dump_hlo_as_dot != false {
            os.write_bool(114, self.xla_dump_hlo_as_dot)?;
        }
        if self.xla_dump_hlo_as_url != false {
            os.write_bool(115, self.xla_dump_hlo_as_url)?;
        }
        if self.xla_dump_hlo_as_html != false {
            os.write_bool(116, self.xla_dump_hlo_as_html)?;
        }
        if self.xla_dump_hlo_snapshots != false {
            os.write_bool(118, self.xla_dump_hlo_snapshots)?;
        }
        if self.xla_gpu_force_conv_nchw != false {
            os.write_bool(125, self.xla_gpu_force_conv_nchw)?;
        }
        for v in &self.xla_gpu_ptx_file {
            os.write_string(127, &v)?;
        };
        if !self.xla_gpu_algorithm_blacklist_path.is_empty() {
            os.write_string(128, &self.xla_gpu_algorithm_blacklist_path)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(500, &self.xla_backend_extra_options, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DebugOptions {
        DebugOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_hlo_graph_addresses",
                |m: &DebugOptions| { &m.xla_hlo_graph_addresses },
                |m: &mut DebugOptions| { &mut m.xla_hlo_graph_addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_hlo_profile",
                |m: &DebugOptions| { &m.xla_hlo_profile },
                |m: &mut DebugOptions| { &mut m.xla_hlo_profile },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_disable_hlo_passes",
                |m: &DebugOptions| { &m.xla_disable_hlo_passes },
                |m: &mut DebugOptions| { &mut m.xla_disable_hlo_passes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_enable_hlo_passes_only",
                |m: &DebugOptions| { &m.xla_enable_hlo_passes_only },
                |m: &mut DebugOptions| { &mut m.xla_enable_hlo_passes_only },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_disable_all_hlo_passes",
                |m: &DebugOptions| { &m.xla_disable_all_hlo_passes },
                |m: &mut DebugOptions| { &mut m.xla_disable_all_hlo_passes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "xla_backend_optimization_level",
                |m: &DebugOptions| { &m.xla_backend_optimization_level },
                |m: &mut DebugOptions| { &mut m.xla_backend_optimization_level },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_embed_ir_in_executable",
                |m: &DebugOptions| { &m.xla_embed_ir_in_executable },
                |m: &mut DebugOptions| { &mut m.xla_embed_ir_in_executable },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_eliminate_hlo_implicit_broadcast",
                |m: &DebugOptions| { &m.xla_eliminate_hlo_implicit_broadcast },
                |m: &mut DebugOptions| { &mut m.xla_eliminate_hlo_implicit_broadcast },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_cpu_multi_thread_eigen",
                |m: &DebugOptions| { &m.xla_cpu_multi_thread_eigen },
                |m: &mut DebugOptions| { &mut m.xla_cpu_multi_thread_eigen },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_gpu_cuda_data_dir",
                |m: &DebugOptions| { &m.xla_gpu_cuda_data_dir },
                |m: &mut DebugOptions| { &mut m.xla_gpu_cuda_data_dir },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_ftz",
                |m: &DebugOptions| { &m.xla_gpu_ftz },
                |m: &mut DebugOptions| { &mut m.xla_gpu_ftz },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_disable_multi_streaming",
                |m: &DebugOptions| { &m.xla_gpu_disable_multi_streaming },
                |m: &mut DebugOptions| { &mut m.xla_gpu_disable_multi_streaming },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_llvm_enable_alias_scope_metadata",
                |m: &DebugOptions| { &m.xla_llvm_enable_alias_scope_metadata },
                |m: &mut DebugOptions| { &mut m.xla_llvm_enable_alias_scope_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_llvm_enable_noalias_metadata",
                |m: &DebugOptions| { &m.xla_llvm_enable_noalias_metadata },
                |m: &mut DebugOptions| { &mut m.xla_llvm_enable_noalias_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_llvm_enable_invariant_load_metadata",
                |m: &DebugOptions| { &m.xla_llvm_enable_invariant_load_metadata },
                |m: &mut DebugOptions| { &mut m.xla_llvm_enable_invariant_load_metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_llvm_disable_expensive_passes",
                |m: &DebugOptions| { &m.xla_llvm_disable_expensive_passes },
                |m: &mut DebugOptions| { &mut m.xla_llvm_disable_expensive_passes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HloReducePrecisionOptions>>(
                "hlo_reduce_precision_options",
                |m: &DebugOptions| { &m.hlo_reduce_precision_options },
                |m: &mut DebugOptions| { &mut m.hlo_reduce_precision_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_test_all_output_layouts",
                |m: &DebugOptions| { &m.xla_test_all_output_layouts },
                |m: &mut DebugOptions| { &mut m.xla_test_all_output_layouts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_test_all_input_layouts",
                |m: &DebugOptions| { &m.xla_test_all_input_layouts },
                |m: &mut DebugOptions| { &mut m.xla_test_all_input_layouts },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_hlo_graph_sharding_color",
                |m: &DebugOptions| { &m.xla_hlo_graph_sharding_color },
                |m: &mut DebugOptions| { &mut m.xla_hlo_graph_sharding_color },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_use_cudnn_batchnorm",
                |m: &DebugOptions| { &m.xla_gpu_use_cudnn_batchnorm },
                |m: &mut DebugOptions| { &mut m.xla_gpu_use_cudnn_batchnorm },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_cpu_use_mkl_dnn",
                |m: &DebugOptions| { &m.xla_cpu_use_mkl_dnn },
                |m: &mut DebugOptions| { &mut m.xla_cpu_use_mkl_dnn },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "xla_gpu_max_kernel_unroll_factor",
                |m: &DebugOptions| { &m.xla_gpu_max_kernel_unroll_factor },
                |m: &mut DebugOptions| { &mut m.xla_gpu_max_kernel_unroll_factor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_cpu_enable_fast_math",
                |m: &DebugOptions| { &m.xla_cpu_enable_fast_math },
                |m: &mut DebugOptions| { &mut m.xla_cpu_enable_fast_math },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_cpu_fast_math_honor_nans",
                |m: &DebugOptions| { &m.xla_cpu_fast_math_honor_nans },
                |m: &mut DebugOptions| { &mut m.xla_cpu_fast_math_honor_nans },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_cpu_fast_math_honor_infs",
                |m: &DebugOptions| { &m.xla_cpu_fast_math_honor_infs },
                |m: &mut DebugOptions| { &mut m.xla_cpu_fast_math_honor_infs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_cpu_fast_math_honor_division",
                |m: &DebugOptions| { &m.xla_cpu_fast_math_honor_division },
                |m: &mut DebugOptions| { &mut m.xla_cpu_fast_math_honor_division },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_cpu_fast_math_honor_functions",
                |m: &DebugOptions| { &m.xla_cpu_fast_math_honor_functions },
                |m: &mut DebugOptions| { &mut m.xla_cpu_fast_math_honor_functions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_enable_fast_min_max",
                |m: &DebugOptions| { &m.xla_gpu_enable_fast_min_max },
                |m: &mut DebugOptions| { &mut m.xla_gpu_enable_fast_min_max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_allow_excess_precision",
                |m: &DebugOptions| { &m.xla_allow_excess_precision },
                |m: &mut DebugOptions| { &mut m.xla_allow_excess_precision },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_crash_on_verification_failures",
                |m: &DebugOptions| { &m.xla_gpu_crash_on_verification_failures },
                |m: &mut DebugOptions| { &mut m.xla_gpu_crash_on_verification_failures },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_disable_autotune",
                |m: &DebugOptions| { &m.xla_gpu_disable_autotune },
                |m: &mut DebugOptions| { &mut m.xla_gpu_disable_autotune },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "xla_force_host_platform_device_count",
                |m: &DebugOptions| { &m.xla_force_host_platform_device_count },
                |m: &mut DebugOptions| { &mut m.xla_force_host_platform_device_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_disable_ptxas_optimizations",
                |m: &DebugOptions| { &m.xla_gpu_disable_ptxas_optimizations },
                |m: &mut DebugOptions| { &mut m.xla_gpu_disable_ptxas_optimizations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_hlo_evaluator_use_fast_path",
                |m: &DebugOptions| { &m.xla_hlo_evaluator_use_fast_path },
                |m: &mut DebugOptions| { &mut m.xla_hlo_evaluator_use_fast_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_allow_scalar_index_dynamic_ops",
                |m: &DebugOptions| { &m.xla_allow_scalar_index_dynamic_ops },
                |m: &mut DebugOptions| { &mut m.xla_allow_scalar_index_dynamic_ops },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DebugOptions_StepMarkerLocation>>(
                "xla_step_marker_location",
                |m: &DebugOptions| { &m.xla_step_marker_location },
                |m: &mut DebugOptions| { &mut m.xla_step_marker_location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_dump_to",
                |m: &DebugOptions| { &m.xla_dump_to },
                |m: &mut DebugOptions| { &mut m.xla_dump_to },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_dump_hlo_module_re",
                |m: &DebugOptions| { &m.xla_dump_hlo_module_re },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_module_re },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_dump_hlo_pass_re",
                |m: &DebugOptions| { &m.xla_dump_hlo_pass_re },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_pass_re },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_dump_hlo_as_text",
                |m: &DebugOptions| { &m.xla_dump_hlo_as_text },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_as_text },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_dump_hlo_as_proto",
                |m: &DebugOptions| { &m.xla_dump_hlo_as_proto },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_as_proto },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_dump_hlo_as_dot",
                |m: &DebugOptions| { &m.xla_dump_hlo_as_dot },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_as_dot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_dump_hlo_as_url",
                |m: &DebugOptions| { &m.xla_dump_hlo_as_url },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_as_url },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_dump_hlo_as_html",
                |m: &DebugOptions| { &m.xla_dump_hlo_as_html },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_as_html },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_dump_hlo_snapshots",
                |m: &DebugOptions| { &m.xla_dump_hlo_snapshots },
                |m: &mut DebugOptions| { &mut m.xla_dump_hlo_snapshots },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "xla_gpu_force_conv_nchw",
                |m: &DebugOptions| { &m.xla_gpu_force_conv_nchw },
                |m: &mut DebugOptions| { &mut m.xla_gpu_force_conv_nchw },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_gpu_ptx_file",
                |m: &DebugOptions| { &m.xla_gpu_ptx_file },
                |m: &mut DebugOptions| { &mut m.xla_gpu_ptx_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "xla_gpu_algorithm_blacklist_path",
                |m: &DebugOptions| { &m.xla_gpu_algorithm_blacklist_path },
                |m: &mut DebugOptions| { &mut m.xla_gpu_algorithm_blacklist_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "xla_backend_extra_options",
                |m: &DebugOptions| { &m.xla_backend_extra_options },
                |m: &mut DebugOptions| { &mut m.xla_backend_extra_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DebugOptions>(
                "DebugOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DebugOptions {
        static instance: ::protobuf::rt::LazyV2<DebugOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DebugOptions::new)
    }
}

impl ::protobuf::Clear for DebugOptions {
    fn clear(&mut self) {
        self.xla_hlo_graph_addresses = false;
        self.xla_hlo_profile = false;
        self.xla_disable_hlo_passes.clear();
        self.xla_enable_hlo_passes_only.clear();
        self.xla_disable_all_hlo_passes = false;
        self.xla_backend_optimization_level = 0;
        self.xla_embed_ir_in_executable = false;
        self.xla_eliminate_hlo_implicit_broadcast = false;
        self.xla_cpu_multi_thread_eigen = false;
        self.xla_gpu_cuda_data_dir.clear();
        self.xla_gpu_ftz = false;
        self.xla_gpu_disable_multi_streaming = false;
        self.xla_llvm_enable_alias_scope_metadata = false;
        self.xla_llvm_enable_noalias_metadata = false;
        self.xla_llvm_enable_invariant_load_metadata = false;
        self.xla_llvm_disable_expensive_passes = false;
        self.hlo_reduce_precision_options.clear();
        self.xla_test_all_output_layouts = false;
        self.xla_test_all_input_layouts = false;
        self.xla_hlo_graph_sharding_color = false;
        self.xla_gpu_use_cudnn_batchnorm = false;
        self.xla_cpu_use_mkl_dnn = false;
        self.xla_gpu_max_kernel_unroll_factor = 0;
        self.xla_cpu_enable_fast_math = false;
        self.xla_cpu_fast_math_honor_nans = false;
        self.xla_cpu_fast_math_honor_infs = false;
        self.xla_cpu_fast_math_honor_division = false;
        self.xla_cpu_fast_math_honor_functions = false;
        self.xla_gpu_enable_fast_min_max = false;
        self.xla_allow_excess_precision = false;
        self.xla_gpu_crash_on_verification_failures = false;
        self.xla_gpu_disable_autotune = false;
        self.xla_force_host_platform_device_count = 0;
        self.xla_gpu_disable_ptxas_optimizations = false;
        self.xla_hlo_evaluator_use_fast_path = false;
        self.xla_allow_scalar_index_dynamic_ops = false;
        self.xla_step_marker_location = DebugOptions_StepMarkerLocation::STEP_MARK_AT_ENTRY;
        self.xla_dump_to.clear();
        self.xla_dump_hlo_module_re.clear();
        self.xla_dump_hlo_pass_re.clear();
        self.xla_dump_hlo_as_text = false;
        self.xla_dump_hlo_as_proto = false;
        self.xla_dump_hlo_as_dot = false;
        self.xla_dump_hlo_as_url = false;
        self.xla_dump_hlo_as_html = false;
        self.xla_dump_hlo_snapshots = false;
        self.xla_gpu_force_conv_nchw = false;
        self.xla_gpu_ptx_file.clear();
        self.xla_gpu_algorithm_blacklist_path.clear();
        self.xla_backend_extra_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DebugOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DebugOptions_StepMarkerLocation {
    STEP_MARK_AT_ENTRY = 0,
    STEP_MARK_AT_TOP_LEVEL_WHILE_LOOP = 1,
    STEP_MARK_AT_SECOND_LEVEL_WHILE_LOOP = 3,
    STEP_MARK_NONE = 2,
}

impl ::protobuf::ProtobufEnum for DebugOptions_StepMarkerLocation {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DebugOptions_StepMarkerLocation> {
        match value {
            0 => ::std::option::Option::Some(DebugOptions_StepMarkerLocation::STEP_MARK_AT_ENTRY),
            1 => ::std::option::Option::Some(DebugOptions_StepMarkerLocation::STEP_MARK_AT_TOP_LEVEL_WHILE_LOOP),
            3 => ::std::option::Option::Some(DebugOptions_StepMarkerLocation::STEP_MARK_AT_SECOND_LEVEL_WHILE_LOOP),
            2 => ::std::option::Option::Some(DebugOptions_StepMarkerLocation::STEP_MARK_NONE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DebugOptions_StepMarkerLocation] = &[
            DebugOptions_StepMarkerLocation::STEP_MARK_AT_ENTRY,
            DebugOptions_StepMarkerLocation::STEP_MARK_AT_TOP_LEVEL_WHILE_LOOP,
            DebugOptions_StepMarkerLocation::STEP_MARK_AT_SECOND_LEVEL_WHILE_LOOP,
            DebugOptions_StepMarkerLocation::STEP_MARK_NONE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DebugOptions_StepMarkerLocation>("DebugOptions.StepMarkerLocation", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DebugOptions_StepMarkerLocation {
}

impl ::std::default::Default for DebugOptions_StepMarkerLocation {
    fn default() -> Self {
        DebugOptions_StepMarkerLocation::STEP_MARK_AT_ENTRY
    }
}

impl ::protobuf::reflect::ProtobufValue for DebugOptions_StepMarkerLocation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutionOptions {
    // message fields
    pub shape_with_output_layout: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    pub seed: u64,
    pub debug_options: ::protobuf::SingularPtrField<DebugOptions>,
    pub device_handles: ::protobuf::RepeatedField<super::xla_data::DeviceHandle>,
    pub num_replicas: i32,
    pub device_assignment: ::protobuf::SingularPtrField<super::xla_data::DeviceAssignmentProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionOptions {
    fn default() -> &'a ExecutionOptions {
        <ExecutionOptions as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionOptions {
    pub fn new() -> ExecutionOptions {
        ::std::default::Default::default()
    }

    // .xla.ShapeProto shape_with_output_layout = 2;


    pub fn get_shape_with_output_layout(&self) -> &super::xla_data::ShapeProto {
        self.shape_with_output_layout.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape_with_output_layout(&mut self) {
        self.shape_with_output_layout.clear();
    }

    pub fn has_shape_with_output_layout(&self) -> bool {
        self.shape_with_output_layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape_with_output_layout(&mut self, v: super::xla_data::ShapeProto) {
        self.shape_with_output_layout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape_with_output_layout(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.shape_with_output_layout.is_none() {
            self.shape_with_output_layout.set_default();
        }
        self.shape_with_output_layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape_with_output_layout(&mut self) -> super::xla_data::ShapeProto {
        self.shape_with_output_layout.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }

    // uint64 seed = 3;


    pub fn get_seed(&self) -> u64 {
        self.seed
    }
    pub fn clear_seed(&mut self) {
        self.seed = 0;
    }

    // Param is passed by value, moved
    pub fn set_seed(&mut self, v: u64) {
        self.seed = v;
    }

    // .xla.DebugOptions debug_options = 4;


    pub fn get_debug_options(&self) -> &DebugOptions {
        self.debug_options.as_ref().unwrap_or_else(|| <DebugOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_debug_options(&mut self) {
        self.debug_options.clear();
    }

    pub fn has_debug_options(&self) -> bool {
        self.debug_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_options(&mut self, v: DebugOptions) {
        self.debug_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_options(&mut self) -> &mut DebugOptions {
        if self.debug_options.is_none() {
            self.debug_options.set_default();
        }
        self.debug_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_options(&mut self) -> DebugOptions {
        self.debug_options.take().unwrap_or_else(|| DebugOptions::new())
    }

    // repeated .xla.DeviceHandle device_handles = 5;


    pub fn get_device_handles(&self) -> &[super::xla_data::DeviceHandle] {
        &self.device_handles
    }
    pub fn clear_device_handles(&mut self) {
        self.device_handles.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_handles(&mut self, v: ::protobuf::RepeatedField<super::xla_data::DeviceHandle>) {
        self.device_handles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_handles(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::DeviceHandle> {
        &mut self.device_handles
    }

    // Take field
    pub fn take_device_handles(&mut self) -> ::protobuf::RepeatedField<super::xla_data::DeviceHandle> {
        ::std::mem::replace(&mut self.device_handles, ::protobuf::RepeatedField::new())
    }

    // int32 num_replicas = 6;


    pub fn get_num_replicas(&self) -> i32 {
        self.num_replicas
    }
    pub fn clear_num_replicas(&mut self) {
        self.num_replicas = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_replicas(&mut self, v: i32) {
        self.num_replicas = v;
    }

    // .xla.DeviceAssignmentProto device_assignment = 7;


    pub fn get_device_assignment(&self) -> &super::xla_data::DeviceAssignmentProto {
        self.device_assignment.as_ref().unwrap_or_else(|| <super::xla_data::DeviceAssignmentProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_assignment(&mut self) {
        self.device_assignment.clear();
    }

    pub fn has_device_assignment(&self) -> bool {
        self.device_assignment.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_assignment(&mut self, v: super::xla_data::DeviceAssignmentProto) {
        self.device_assignment = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_assignment(&mut self) -> &mut super::xla_data::DeviceAssignmentProto {
        if self.device_assignment.is_none() {
            self.device_assignment.set_default();
        }
        self.device_assignment.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_assignment(&mut self) -> super::xla_data::DeviceAssignmentProto {
        self.device_assignment.take().unwrap_or_else(|| super::xla_data::DeviceAssignmentProto::new())
    }
}

impl ::protobuf::Message for ExecutionOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.shape_with_output_layout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.debug_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_handles {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_assignment {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape_with_output_layout)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.seed = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debug_options)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.device_handles)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_replicas = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_assignment)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shape_with_output_layout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.seed != 0 {
            my_size += ::protobuf::rt::value_size(3, self.seed, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.device_handles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.num_replicas != 0 {
            my_size += ::protobuf::rt::value_size(6, self.num_replicas, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_assignment.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shape_with_output_layout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.seed != 0 {
            os.write_uint64(3, self.seed)?;
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.device_handles {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.num_replicas != 0 {
            os.write_int32(6, self.num_replicas)?;
        }
        if let Some(ref v) = self.device_assignment.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutionOptions {
        ExecutionOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "shape_with_output_layout",
                |m: &ExecutionOptions| { &m.shape_with_output_layout },
                |m: &mut ExecutionOptions| { &mut m.shape_with_output_layout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "seed",
                |m: &ExecutionOptions| { &m.seed },
                |m: &mut ExecutionOptions| { &mut m.seed },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugOptions>>(
                "debug_options",
                |m: &ExecutionOptions| { &m.debug_options },
                |m: &mut ExecutionOptions| { &mut m.debug_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DeviceHandle>>(
                "device_handles",
                |m: &ExecutionOptions| { &m.device_handles },
                |m: &mut ExecutionOptions| { &mut m.device_handles },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_replicas",
                |m: &ExecutionOptions| { &m.num_replicas },
                |m: &mut ExecutionOptions| { &mut m.num_replicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DeviceAssignmentProto>>(
                "device_assignment",
                |m: &ExecutionOptions| { &m.device_assignment },
                |m: &mut ExecutionOptions| { &mut m.device_assignment },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecutionOptions>(
                "ExecutionOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecutionOptions {
        static instance: ::protobuf::rt::LazyV2<ExecutionOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecutionOptions::new)
    }
}

impl ::protobuf::Clear for ExecutionOptions {
    fn clear(&mut self) {
        self.shape_with_output_layout.clear();
        self.seed = 0;
        self.debug_options.clear();
        self.device_handles.clear();
        self.num_replicas = 0;
        self.device_assignment.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceHandlesRequest {
    // message fields
    pub device_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceHandlesRequest {
    fn default() -> &'a GetDeviceHandlesRequest {
        <GetDeviceHandlesRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceHandlesRequest {
    pub fn new() -> GetDeviceHandlesRequest {
        ::std::default::Default::default()
    }

    // int64 device_count = 1;


    pub fn get_device_count(&self) -> i64 {
        self.device_count
    }
    pub fn clear_device_count(&mut self) {
        self.device_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_count(&mut self, v: i64) {
        self.device_count = v;
    }
}

impl ::protobuf::Message for GetDeviceHandlesRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.device_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.device_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.device_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.device_count != 0 {
            os.write_int64(1, self.device_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceHandlesRequest {
        GetDeviceHandlesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "device_count",
                |m: &GetDeviceHandlesRequest| { &m.device_count },
                |m: &mut GetDeviceHandlesRequest| { &mut m.device_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDeviceHandlesRequest>(
                "GetDeviceHandlesRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDeviceHandlesRequest {
        static instance: ::protobuf::rt::LazyV2<GetDeviceHandlesRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDeviceHandlesRequest::new)
    }
}

impl ::protobuf::Clear for GetDeviceHandlesRequest {
    fn clear(&mut self) {
        self.device_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceHandlesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceHandlesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetDeviceHandlesResponse {
    // message fields
    pub device_handles: ::protobuf::RepeatedField<super::xla_data::DeviceHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetDeviceHandlesResponse {
    fn default() -> &'a GetDeviceHandlesResponse {
        <GetDeviceHandlesResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetDeviceHandlesResponse {
    pub fn new() -> GetDeviceHandlesResponse {
        ::std::default::Default::default()
    }

    // repeated .xla.DeviceHandle device_handles = 1;


    pub fn get_device_handles(&self) -> &[super::xla_data::DeviceHandle] {
        &self.device_handles
    }
    pub fn clear_device_handles(&mut self) {
        self.device_handles.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_handles(&mut self, v: ::protobuf::RepeatedField<super::xla_data::DeviceHandle>) {
        self.device_handles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_handles(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::DeviceHandle> {
        &mut self.device_handles
    }

    // Take field
    pub fn take_device_handles(&mut self) -> ::protobuf::RepeatedField<super::xla_data::DeviceHandle> {
        ::std::mem::replace(&mut self.device_handles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetDeviceHandlesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.device_handles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.device_handles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.device_handles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.device_handles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetDeviceHandlesResponse {
        GetDeviceHandlesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DeviceHandle>>(
                "device_handles",
                |m: &GetDeviceHandlesResponse| { &m.device_handles },
                |m: &mut GetDeviceHandlesResponse| { &mut m.device_handles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetDeviceHandlesResponse>(
                "GetDeviceHandlesResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetDeviceHandlesResponse {
        static instance: ::protobuf::rt::LazyV2<GetDeviceHandlesResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetDeviceHandlesResponse::new)
    }
}

impl ::protobuf::Clear for GetDeviceHandlesResponse {
    fn clear(&mut self) {
        self.device_handles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetDeviceHandlesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetDeviceHandlesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferToClientRequest {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    pub shape_with_layout: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferToClientRequest {
    fn default() -> &'a TransferToClientRequest {
        <TransferToClientRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransferToClientRequest {
    pub fn new() -> TransferToClientRequest {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle data = 1;


    pub fn get_data(&self) -> &super::xla_data::GlobalDataHandle {
        self.data.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::xla_data::GlobalDataHandle {
        self.data.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }

    // .xla.ShapeProto shape_with_layout = 2;


    pub fn get_shape_with_layout(&self) -> &super::xla_data::ShapeProto {
        self.shape_with_layout.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape_with_layout(&mut self) {
        self.shape_with_layout.clear();
    }

    pub fn has_shape_with_layout(&self) -> bool {
        self.shape_with_layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape_with_layout(&mut self, v: super::xla_data::ShapeProto) {
        self.shape_with_layout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape_with_layout(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.shape_with_layout.is_none() {
            self.shape_with_layout.set_default();
        }
        self.shape_with_layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape_with_layout(&mut self) -> super::xla_data::ShapeProto {
        self.shape_with_layout.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }
}

impl ::protobuf::Message for TransferToClientRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shape_with_layout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape_with_layout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.shape_with_layout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.shape_with_layout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferToClientRequest {
        TransferToClientRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "data",
                |m: &TransferToClientRequest| { &m.data },
                |m: &mut TransferToClientRequest| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "shape_with_layout",
                |m: &TransferToClientRequest| { &m.shape_with_layout },
                |m: &mut TransferToClientRequest| { &mut m.shape_with_layout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferToClientRequest>(
                "TransferToClientRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferToClientRequest {
        static instance: ::protobuf::rt::LazyV2<TransferToClientRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferToClientRequest::new)
    }
}

impl ::protobuf::Clear for TransferToClientRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.shape_with_layout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferToClientRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferToClientRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferToClientResponse {
    // message fields
    pub literal: ::protobuf::SingularPtrField<super::xla_data::LiteralProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferToClientResponse {
    fn default() -> &'a TransferToClientResponse {
        <TransferToClientResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransferToClientResponse {
    pub fn new() -> TransferToClientResponse {
        ::std::default::Default::default()
    }

    // .xla.LiteralProto literal = 1;


    pub fn get_literal(&self) -> &super::xla_data::LiteralProto {
        self.literal.as_ref().unwrap_or_else(|| <super::xla_data::LiteralProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_literal(&mut self) {
        self.literal.clear();
    }

    pub fn has_literal(&self) -> bool {
        self.literal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_literal(&mut self, v: super::xla_data::LiteralProto) {
        self.literal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_literal(&mut self) -> &mut super::xla_data::LiteralProto {
        if self.literal.is_none() {
            self.literal.set_default();
        }
        self.literal.as_mut().unwrap()
    }

    // Take field
    pub fn take_literal(&mut self) -> super::xla_data::LiteralProto {
        self.literal.take().unwrap_or_else(|| super::xla_data::LiteralProto::new())
    }
}

impl ::protobuf::Message for TransferToClientResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.literal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.literal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.literal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.literal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferToClientResponse {
        TransferToClientResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "literal",
                |m: &TransferToClientResponse| { &m.literal },
                |m: &mut TransferToClientResponse| { &mut m.literal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferToClientResponse>(
                "TransferToClientResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferToClientResponse {
        static instance: ::protobuf::rt::LazyV2<TransferToClientResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferToClientResponse::new)
    }
}

impl ::protobuf::Clear for TransferToClientResponse {
    fn clear(&mut self) {
        self.literal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferToClientResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferToClientResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferToServerRequest {
    // message fields
    pub literal: ::protobuf::SingularPtrField<super::xla_data::LiteralProto>,
    pub device_handle: ::protobuf::SingularPtrField<super::xla_data::DeviceHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferToServerRequest {
    fn default() -> &'a TransferToServerRequest {
        <TransferToServerRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransferToServerRequest {
    pub fn new() -> TransferToServerRequest {
        ::std::default::Default::default()
    }

    // .xla.LiteralProto literal = 1;


    pub fn get_literal(&self) -> &super::xla_data::LiteralProto {
        self.literal.as_ref().unwrap_or_else(|| <super::xla_data::LiteralProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_literal(&mut self) {
        self.literal.clear();
    }

    pub fn has_literal(&self) -> bool {
        self.literal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_literal(&mut self, v: super::xla_data::LiteralProto) {
        self.literal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_literal(&mut self) -> &mut super::xla_data::LiteralProto {
        if self.literal.is_none() {
            self.literal.set_default();
        }
        self.literal.as_mut().unwrap()
    }

    // Take field
    pub fn take_literal(&mut self) -> super::xla_data::LiteralProto {
        self.literal.take().unwrap_or_else(|| super::xla_data::LiteralProto::new())
    }

    // .xla.DeviceHandle device_handle = 2;


    pub fn get_device_handle(&self) -> &super::xla_data::DeviceHandle {
        self.device_handle.as_ref().unwrap_or_else(|| <super::xla_data::DeviceHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_handle(&mut self) {
        self.device_handle.clear();
    }

    pub fn has_device_handle(&self) -> bool {
        self.device_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_handle(&mut self, v: super::xla_data::DeviceHandle) {
        self.device_handle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_handle(&mut self) -> &mut super::xla_data::DeviceHandle {
        if self.device_handle.is_none() {
            self.device_handle.set_default();
        }
        self.device_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_handle(&mut self) -> super::xla_data::DeviceHandle {
        self.device_handle.take().unwrap_or_else(|| super::xla_data::DeviceHandle::new())
    }
}

impl ::protobuf::Message for TransferToServerRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.literal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_handle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.literal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.literal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.device_handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.literal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.device_handle.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferToServerRequest {
        TransferToServerRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "literal",
                |m: &TransferToServerRequest| { &m.literal },
                |m: &mut TransferToServerRequest| { &mut m.literal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DeviceHandle>>(
                "device_handle",
                |m: &TransferToServerRequest| { &m.device_handle },
                |m: &mut TransferToServerRequest| { &mut m.device_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferToServerRequest>(
                "TransferToServerRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferToServerRequest {
        static instance: ::protobuf::rt::LazyV2<TransferToServerRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferToServerRequest::new)
    }
}

impl ::protobuf::Clear for TransferToServerRequest {
    fn clear(&mut self) {
        self.literal.clear();
        self.device_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferToServerRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferToServerRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferToServerResponse {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferToServerResponse {
    fn default() -> &'a TransferToServerResponse {
        <TransferToServerResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransferToServerResponse {
    pub fn new() -> TransferToServerResponse {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle data = 1;


    pub fn get_data(&self) -> &super::xla_data::GlobalDataHandle {
        self.data.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::xla_data::GlobalDataHandle {
        self.data.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }
}

impl ::protobuf::Message for TransferToServerResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferToServerResponse {
        TransferToServerResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "data",
                |m: &TransferToServerResponse| { &m.data },
                |m: &mut TransferToServerResponse| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferToServerResponse>(
                "TransferToServerResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferToServerResponse {
        static instance: ::protobuf::rt::LazyV2<TransferToServerResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferToServerResponse::new)
    }
}

impl ::protobuf::Clear for TransferToServerResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferToServerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferToServerResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferToInfeedRequest {
    // message fields
    pub literal: ::protobuf::SingularPtrField<super::xla_data::LiteralProto>,
    pub replica_id: i64,
    pub device_handle: ::protobuf::SingularPtrField<super::xla_data::DeviceHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferToInfeedRequest {
    fn default() -> &'a TransferToInfeedRequest {
        <TransferToInfeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransferToInfeedRequest {
    pub fn new() -> TransferToInfeedRequest {
        ::std::default::Default::default()
    }

    // .xla.LiteralProto literal = 1;


    pub fn get_literal(&self) -> &super::xla_data::LiteralProto {
        self.literal.as_ref().unwrap_or_else(|| <super::xla_data::LiteralProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_literal(&mut self) {
        self.literal.clear();
    }

    pub fn has_literal(&self) -> bool {
        self.literal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_literal(&mut self, v: super::xla_data::LiteralProto) {
        self.literal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_literal(&mut self) -> &mut super::xla_data::LiteralProto {
        if self.literal.is_none() {
            self.literal.set_default();
        }
        self.literal.as_mut().unwrap()
    }

    // Take field
    pub fn take_literal(&mut self) -> super::xla_data::LiteralProto {
        self.literal.take().unwrap_or_else(|| super::xla_data::LiteralProto::new())
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .xla.DeviceHandle device_handle = 3;


    pub fn get_device_handle(&self) -> &super::xla_data::DeviceHandle {
        self.device_handle.as_ref().unwrap_or_else(|| <super::xla_data::DeviceHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_handle(&mut self) {
        self.device_handle.clear();
    }

    pub fn has_device_handle(&self) -> bool {
        self.device_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_handle(&mut self, v: super::xla_data::DeviceHandle) {
        self.device_handle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_handle(&mut self) -> &mut super::xla_data::DeviceHandle {
        if self.device_handle.is_none() {
            self.device_handle.set_default();
        }
        self.device_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_handle(&mut self) -> super::xla_data::DeviceHandle {
        self.device_handle.take().unwrap_or_else(|| super::xla_data::DeviceHandle::new())
    }
}

impl ::protobuf::Message for TransferToInfeedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.literal {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_handle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.literal)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.literal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.literal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.device_handle.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferToInfeedRequest {
        TransferToInfeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "literal",
                |m: &TransferToInfeedRequest| { &m.literal },
                |m: &mut TransferToInfeedRequest| { &mut m.literal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "replica_id",
                |m: &TransferToInfeedRequest| { &m.replica_id },
                |m: &mut TransferToInfeedRequest| { &mut m.replica_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DeviceHandle>>(
                "device_handle",
                |m: &TransferToInfeedRequest| { &m.device_handle },
                |m: &mut TransferToInfeedRequest| { &mut m.device_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferToInfeedRequest>(
                "TransferToInfeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferToInfeedRequest {
        static instance: ::protobuf::rt::LazyV2<TransferToInfeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferToInfeedRequest::new)
    }
}

impl ::protobuf::Clear for TransferToInfeedRequest {
    fn clear(&mut self) {
        self.literal.clear();
        self.replica_id = 0;
        self.device_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferToInfeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferToInfeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferToInfeedResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferToInfeedResponse {
    fn default() -> &'a TransferToInfeedResponse {
        <TransferToInfeedResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransferToInfeedResponse {
    pub fn new() -> TransferToInfeedResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TransferToInfeedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferToInfeedResponse {
        TransferToInfeedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferToInfeedResponse>(
                "TransferToInfeedResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferToInfeedResponse {
        static instance: ::protobuf::rt::LazyV2<TransferToInfeedResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferToInfeedResponse::new)
    }
}

impl ::protobuf::Clear for TransferToInfeedResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferToInfeedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferToInfeedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferFromOutfeedRequest {
    // message fields
    pub shape_with_layout: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    pub replica_id: i64,
    pub device_handle: ::protobuf::SingularPtrField<super::xla_data::DeviceHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferFromOutfeedRequest {
    fn default() -> &'a TransferFromOutfeedRequest {
        <TransferFromOutfeedRequest as ::protobuf::Message>::default_instance()
    }
}

impl TransferFromOutfeedRequest {
    pub fn new() -> TransferFromOutfeedRequest {
        ::std::default::Default::default()
    }

    // .xla.ShapeProto shape_with_layout = 1;


    pub fn get_shape_with_layout(&self) -> &super::xla_data::ShapeProto {
        self.shape_with_layout.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape_with_layout(&mut self) {
        self.shape_with_layout.clear();
    }

    pub fn has_shape_with_layout(&self) -> bool {
        self.shape_with_layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape_with_layout(&mut self, v: super::xla_data::ShapeProto) {
        self.shape_with_layout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape_with_layout(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.shape_with_layout.is_none() {
            self.shape_with_layout.set_default();
        }
        self.shape_with_layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape_with_layout(&mut self) -> super::xla_data::ShapeProto {
        self.shape_with_layout.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }

    // int64 replica_id = 2;


    pub fn get_replica_id(&self) -> i64 {
        self.replica_id
    }
    pub fn clear_replica_id(&mut self) {
        self.replica_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_id(&mut self, v: i64) {
        self.replica_id = v;
    }

    // .xla.DeviceHandle device_handle = 3;


    pub fn get_device_handle(&self) -> &super::xla_data::DeviceHandle {
        self.device_handle.as_ref().unwrap_or_else(|| <super::xla_data::DeviceHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_handle(&mut self) {
        self.device_handle.clear();
    }

    pub fn has_device_handle(&self) -> bool {
        self.device_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_handle(&mut self, v: super::xla_data::DeviceHandle) {
        self.device_handle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_handle(&mut self) -> &mut super::xla_data::DeviceHandle {
        if self.device_handle.is_none() {
            self.device_handle.set_default();
        }
        self.device_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_handle(&mut self) -> super::xla_data::DeviceHandle {
        self.device_handle.take().unwrap_or_else(|| super::xla_data::DeviceHandle::new())
    }
}

impl ::protobuf::Message for TransferFromOutfeedRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.shape_with_layout {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.device_handle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape_with_layout)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.replica_id = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shape_with_layout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.replica_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.replica_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.device_handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shape_with_layout.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.replica_id != 0 {
            os.write_int64(2, self.replica_id)?;
        }
        if let Some(ref v) = self.device_handle.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferFromOutfeedRequest {
        TransferFromOutfeedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "shape_with_layout",
                |m: &TransferFromOutfeedRequest| { &m.shape_with_layout },
                |m: &mut TransferFromOutfeedRequest| { &mut m.shape_with_layout },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "replica_id",
                |m: &TransferFromOutfeedRequest| { &m.replica_id },
                |m: &mut TransferFromOutfeedRequest| { &mut m.replica_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DeviceHandle>>(
                "device_handle",
                |m: &TransferFromOutfeedRequest| { &m.device_handle },
                |m: &mut TransferFromOutfeedRequest| { &mut m.device_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferFromOutfeedRequest>(
                "TransferFromOutfeedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferFromOutfeedRequest {
        static instance: ::protobuf::rt::LazyV2<TransferFromOutfeedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferFromOutfeedRequest::new)
    }
}

impl ::protobuf::Clear for TransferFromOutfeedRequest {
    fn clear(&mut self) {
        self.shape_with_layout.clear();
        self.replica_id = 0;
        self.device_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferFromOutfeedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferFromOutfeedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TransferFromOutfeedResponse {
    // message fields
    pub literal: ::protobuf::SingularPtrField<super::xla_data::LiteralProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TransferFromOutfeedResponse {
    fn default() -> &'a TransferFromOutfeedResponse {
        <TransferFromOutfeedResponse as ::protobuf::Message>::default_instance()
    }
}

impl TransferFromOutfeedResponse {
    pub fn new() -> TransferFromOutfeedResponse {
        ::std::default::Default::default()
    }

    // .xla.LiteralProto literal = 1;


    pub fn get_literal(&self) -> &super::xla_data::LiteralProto {
        self.literal.as_ref().unwrap_or_else(|| <super::xla_data::LiteralProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_literal(&mut self) {
        self.literal.clear();
    }

    pub fn has_literal(&self) -> bool {
        self.literal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_literal(&mut self, v: super::xla_data::LiteralProto) {
        self.literal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_literal(&mut self) -> &mut super::xla_data::LiteralProto {
        if self.literal.is_none() {
            self.literal.set_default();
        }
        self.literal.as_mut().unwrap()
    }

    // Take field
    pub fn take_literal(&mut self) -> super::xla_data::LiteralProto {
        self.literal.take().unwrap_or_else(|| super::xla_data::LiteralProto::new())
    }
}

impl ::protobuf::Message for TransferFromOutfeedResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.literal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.literal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.literal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.literal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TransferFromOutfeedResponse {
        TransferFromOutfeedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "literal",
                |m: &TransferFromOutfeedResponse| { &m.literal },
                |m: &mut TransferFromOutfeedResponse| { &mut m.literal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TransferFromOutfeedResponse>(
                "TransferFromOutfeedResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TransferFromOutfeedResponse {
        static instance: ::protobuf::rt::LazyV2<TransferFromOutfeedResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TransferFromOutfeedResponse::new)
    }
}

impl ::protobuf::Clear for TransferFromOutfeedResponse {
    fn clear(&mut self) {
        self.literal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TransferFromOutfeedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TransferFromOutfeedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResetDeviceRequest {
    // message fields
    pub device_handle: ::protobuf::SingularPtrField<super::xla_data::DeviceHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetDeviceRequest {
    fn default() -> &'a ResetDeviceRequest {
        <ResetDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ResetDeviceRequest {
    pub fn new() -> ResetDeviceRequest {
        ::std::default::Default::default()
    }

    // .xla.DeviceHandle device_handle = 1;


    pub fn get_device_handle(&self) -> &super::xla_data::DeviceHandle {
        self.device_handle.as_ref().unwrap_or_else(|| <super::xla_data::DeviceHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_device_handle(&mut self) {
        self.device_handle.clear();
    }

    pub fn has_device_handle(&self) -> bool {
        self.device_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_device_handle(&mut self, v: super::xla_data::DeviceHandle) {
        self.device_handle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_handle(&mut self) -> &mut super::xla_data::DeviceHandle {
        if self.device_handle.is_none() {
            self.device_handle.set_default();
        }
        self.device_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_device_handle(&mut self) -> super::xla_data::DeviceHandle {
        self.device_handle.take().unwrap_or_else(|| super::xla_data::DeviceHandle::new())
    }
}

impl ::protobuf::Message for ResetDeviceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.device_handle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.device_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.device_handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.device_handle.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetDeviceRequest {
        ResetDeviceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::DeviceHandle>>(
                "device_handle",
                |m: &ResetDeviceRequest| { &m.device_handle },
                |m: &mut ResetDeviceRequest| { &mut m.device_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResetDeviceRequest>(
                "ResetDeviceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResetDeviceRequest {
        static instance: ::protobuf::rt::LazyV2<ResetDeviceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResetDeviceRequest::new)
    }
}

impl ::protobuf::Clear for ResetDeviceRequest {
    fn clear(&mut self) {
        self.device_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetDeviceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResetDeviceResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResetDeviceResponse {
    fn default() -> &'a ResetDeviceResponse {
        <ResetDeviceResponse as ::protobuf::Message>::default_instance()
    }
}

impl ResetDeviceResponse {
    pub fn new() -> ResetDeviceResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for ResetDeviceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResetDeviceResponse {
        ResetDeviceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResetDeviceResponse>(
                "ResetDeviceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResetDeviceResponse {
        static instance: ::protobuf::rt::LazyV2<ResetDeviceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResetDeviceResponse::new)
    }
}

impl ::protobuf::Clear for ResetDeviceResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResetDeviceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResetDeviceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputationGraphStatsRequest {
    // message fields
    pub computation: ::protobuf::SingularPtrField<super::hlo::HloModuleProto>,
    pub debug_options: ::protobuf::SingularPtrField<DebugOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputationGraphStatsRequest {
    fn default() -> &'a ComputationGraphStatsRequest {
        <ComputationGraphStatsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ComputationGraphStatsRequest {
    pub fn new() -> ComputationGraphStatsRequest {
        ::std::default::Default::default()
    }

    // .xla.HloModuleProto computation = 1;


    pub fn get_computation(&self) -> &super::hlo::HloModuleProto {
        self.computation.as_ref().unwrap_or_else(|| <super::hlo::HloModuleProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_computation(&mut self) {
        self.computation.clear();
    }

    pub fn has_computation(&self) -> bool {
        self.computation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_computation(&mut self, v: super::hlo::HloModuleProto) {
        self.computation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_computation(&mut self) -> &mut super::hlo::HloModuleProto {
        if self.computation.is_none() {
            self.computation.set_default();
        }
        self.computation.as_mut().unwrap()
    }

    // Take field
    pub fn take_computation(&mut self) -> super::hlo::HloModuleProto {
        self.computation.take().unwrap_or_else(|| super::hlo::HloModuleProto::new())
    }

    // .xla.DebugOptions debug_options = 2;


    pub fn get_debug_options(&self) -> &DebugOptions {
        self.debug_options.as_ref().unwrap_or_else(|| <DebugOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_debug_options(&mut self) {
        self.debug_options.clear();
    }

    pub fn has_debug_options(&self) -> bool {
        self.debug_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_options(&mut self, v: DebugOptions) {
        self.debug_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_options(&mut self) -> &mut DebugOptions {
        if self.debug_options.is_none() {
            self.debug_options.set_default();
        }
        self.debug_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_options(&mut self) -> DebugOptions {
        self.debug_options.take().unwrap_or_else(|| DebugOptions::new())
    }
}

impl ::protobuf::Message for ComputationGraphStatsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.computation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.debug_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.computation)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debug_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.computation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.computation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputationGraphStatsRequest {
        ComputationGraphStatsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hlo::HloModuleProto>>(
                "computation",
                |m: &ComputationGraphStatsRequest| { &m.computation },
                |m: &mut ComputationGraphStatsRequest| { &mut m.computation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DebugOptions>>(
                "debug_options",
                |m: &ComputationGraphStatsRequest| { &m.debug_options },
                |m: &mut ComputationGraphStatsRequest| { &mut m.debug_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputationGraphStatsRequest>(
                "ComputationGraphStatsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputationGraphStatsRequest {
        static instance: ::protobuf::rt::LazyV2<ComputationGraphStatsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputationGraphStatsRequest::new)
    }
}

impl ::protobuf::Clear for ComputationGraphStatsRequest {
    fn clear(&mut self) {
        self.computation.clear();
        self.debug_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputationGraphStatsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputationGraphStatsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputationStatsResponse {
    // message fields
    pub stats: ::protobuf::SingularPtrField<super::xla_data::ComputationStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputationStatsResponse {
    fn default() -> &'a ComputationStatsResponse {
        <ComputationStatsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComputationStatsResponse {
    pub fn new() -> ComputationStatsResponse {
        ::std::default::Default::default()
    }

    // .xla.ComputationStats stats = 1;


    pub fn get_stats(&self) -> &super::xla_data::ComputationStats {
        self.stats.as_ref().unwrap_or_else(|| <super::xla_data::ComputationStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_stats(&mut self) {
        self.stats.clear();
    }

    pub fn has_stats(&self) -> bool {
        self.stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stats(&mut self, v: super::xla_data::ComputationStats) {
        self.stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_stats(&mut self) -> &mut super::xla_data::ComputationStats {
        if self.stats.is_none() {
            self.stats.set_default();
        }
        self.stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_stats(&mut self) -> super::xla_data::ComputationStats {
        self.stats.take().unwrap_or_else(|| super::xla_data::ComputationStats::new())
    }
}

impl ::protobuf::Message for ComputationStatsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.stats.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputationStatsResponse {
        ComputationStatsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ComputationStats>>(
                "stats",
                |m: &ComputationStatsResponse| { &m.stats },
                |m: &mut ComputationStatsResponse| { &mut m.stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputationStatsResponse>(
                "ComputationStatsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputationStatsResponse {
        static instance: ::protobuf::rt::LazyV2<ComputationStatsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputationStatsResponse::new)
    }
}

impl ::protobuf::Clear for ComputationStatsResponse {
    fn clear(&mut self) {
        self.stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputationStatsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputationStatsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateChannelHandleRequest {
    // message fields
    pub channel_type: super::xla_data::ChannelHandle_ChannelType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateChannelHandleRequest {
    fn default() -> &'a CreateChannelHandleRequest {
        <CreateChannelHandleRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateChannelHandleRequest {
    pub fn new() -> CreateChannelHandleRequest {
        ::std::default::Default::default()
    }

    // .xla.ChannelHandle.ChannelType channel_type = 1;


    pub fn get_channel_type(&self) -> super::xla_data::ChannelHandle_ChannelType {
        self.channel_type
    }
    pub fn clear_channel_type(&mut self) {
        self.channel_type = super::xla_data::ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_channel_type(&mut self, v: super::xla_data::ChannelHandle_ChannelType) {
        self.channel_type = v;
    }
}

impl ::protobuf::Message for CreateChannelHandleRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.channel_type, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.channel_type != super::xla_data::ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID {
            my_size += ::protobuf::rt::enum_size(1, self.channel_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.channel_type != super::xla_data::ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.channel_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateChannelHandleRequest {
        CreateChannelHandleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::xla_data::ChannelHandle_ChannelType>>(
                "channel_type",
                |m: &CreateChannelHandleRequest| { &m.channel_type },
                |m: &mut CreateChannelHandleRequest| { &mut m.channel_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateChannelHandleRequest>(
                "CreateChannelHandleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateChannelHandleRequest {
        static instance: ::protobuf::rt::LazyV2<CreateChannelHandleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateChannelHandleRequest::new)
    }
}

impl ::protobuf::Clear for CreateChannelHandleRequest {
    fn clear(&mut self) {
        self.channel_type = super::xla_data::ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateChannelHandleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateChannelHandleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateChannelHandleResponse {
    // message fields
    pub channel: ::protobuf::SingularPtrField<super::xla_data::ChannelHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateChannelHandleResponse {
    fn default() -> &'a CreateChannelHandleResponse {
        <CreateChannelHandleResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateChannelHandleResponse {
    pub fn new() -> CreateChannelHandleResponse {
        ::std::default::Default::default()
    }

    // .xla.ChannelHandle channel = 1;


    pub fn get_channel(&self) -> &super::xla_data::ChannelHandle {
        self.channel.as_ref().unwrap_or_else(|| <super::xla_data::ChannelHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_channel(&mut self) {
        self.channel.clear();
    }

    pub fn has_channel(&self) -> bool {
        self.channel.is_some()
    }

    // Param is passed by value, moved
    pub fn set_channel(&mut self, v: super::xla_data::ChannelHandle) {
        self.channel = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_channel(&mut self) -> &mut super::xla_data::ChannelHandle {
        if self.channel.is_none() {
            self.channel.set_default();
        }
        self.channel.as_mut().unwrap()
    }

    // Take field
    pub fn take_channel(&mut self) -> super::xla_data::ChannelHandle {
        self.channel.take().unwrap_or_else(|| super::xla_data::ChannelHandle::new())
    }
}

impl ::protobuf::Message for CreateChannelHandleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.channel {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.channel)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.channel.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.channel.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateChannelHandleResponse {
        CreateChannelHandleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ChannelHandle>>(
                "channel",
                |m: &CreateChannelHandleResponse| { &m.channel },
                |m: &mut CreateChannelHandleResponse| { &mut m.channel },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateChannelHandleResponse>(
                "CreateChannelHandleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateChannelHandleResponse {
        static instance: ::protobuf::rt::LazyV2<CreateChannelHandleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateChannelHandleResponse::new)
    }
}

impl ::protobuf::Clear for CreateChannelHandleResponse {
    fn clear(&mut self) {
        self.channel.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateChannelHandleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateChannelHandleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnregisterRequest {
    // message fields
    pub data: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnregisterRequest {
    fn default() -> &'a UnregisterRequest {
        <UnregisterRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnregisterRequest {
    pub fn new() -> UnregisterRequest {
        ::std::default::Default::default()
    }

    // repeated .xla.GlobalDataHandle data = 1;


    pub fn get_data(&self) -> &[super::xla_data::GlobalDataHandle] {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        ::std::mem::replace(&mut self.data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UnregisterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnregisterRequest {
        UnregisterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "data",
                |m: &UnregisterRequest| { &m.data },
                |m: &mut UnregisterRequest| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnregisterRequest>(
                "UnregisterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnregisterRequest {
        static instance: ::protobuf::rt::LazyV2<UnregisterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnregisterRequest::new)
    }
}

impl ::protobuf::Clear for UnregisterRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnregisterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnregisterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnregisterResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnregisterResponse {
    fn default() -> &'a UnregisterResponse {
        <UnregisterResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnregisterResponse {
    pub fn new() -> UnregisterResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for UnregisterResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnregisterResponse {
        UnregisterResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnregisterResponse>(
                "UnregisterResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnregisterResponse {
        static instance: ::protobuf::rt::LazyV2<UnregisterResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnregisterResponse::new)
    }
}

impl ::protobuf::Clear for UnregisterResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnregisterResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnregisterResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompileRequest {
    // message fields
    pub computation: ::protobuf::SingularPtrField<super::hlo::HloModuleProto>,
    pub execution_options: ::protobuf::SingularPtrField<ExecutionOptions>,
    pub input_shape_with_layout: ::protobuf::RepeatedField<super::xla_data::ShapeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompileRequest {
    fn default() -> &'a CompileRequest {
        <CompileRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompileRequest {
    pub fn new() -> CompileRequest {
        ::std::default::Default::default()
    }

    // .xla.HloModuleProto computation = 1;


    pub fn get_computation(&self) -> &super::hlo::HloModuleProto {
        self.computation.as_ref().unwrap_or_else(|| <super::hlo::HloModuleProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_computation(&mut self) {
        self.computation.clear();
    }

    pub fn has_computation(&self) -> bool {
        self.computation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_computation(&mut self, v: super::hlo::HloModuleProto) {
        self.computation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_computation(&mut self) -> &mut super::hlo::HloModuleProto {
        if self.computation.is_none() {
            self.computation.set_default();
        }
        self.computation.as_mut().unwrap()
    }

    // Take field
    pub fn take_computation(&mut self) -> super::hlo::HloModuleProto {
        self.computation.take().unwrap_or_else(|| super::hlo::HloModuleProto::new())
    }

    // .xla.ExecutionOptions execution_options = 2;


    pub fn get_execution_options(&self) -> &ExecutionOptions {
        self.execution_options.as_ref().unwrap_or_else(|| <ExecutionOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execution_options(&mut self) {
        self.execution_options.clear();
    }

    pub fn has_execution_options(&self) -> bool {
        self.execution_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_options(&mut self, v: ExecutionOptions) {
        self.execution_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_options(&mut self) -> &mut ExecutionOptions {
        if self.execution_options.is_none() {
            self.execution_options.set_default();
        }
        self.execution_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_execution_options(&mut self) -> ExecutionOptions {
        self.execution_options.take().unwrap_or_else(|| ExecutionOptions::new())
    }

    // repeated .xla.ShapeProto input_shape_with_layout = 3;


    pub fn get_input_shape_with_layout(&self) -> &[super::xla_data::ShapeProto] {
        &self.input_shape_with_layout
    }
    pub fn clear_input_shape_with_layout(&mut self) {
        self.input_shape_with_layout.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_shape_with_layout(&mut self, v: ::protobuf::RepeatedField<super::xla_data::ShapeProto>) {
        self.input_shape_with_layout = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_shape_with_layout(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::ShapeProto> {
        &mut self.input_shape_with_layout
    }

    // Take field
    pub fn take_input_shape_with_layout(&mut self) -> ::protobuf::RepeatedField<super::xla_data::ShapeProto> {
        ::std::mem::replace(&mut self.input_shape_with_layout, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CompileRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.computation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.execution_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.input_shape_with_layout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.computation)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execution_options)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.input_shape_with_layout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.computation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.execution_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.input_shape_with_layout {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.computation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.execution_options.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.input_shape_with_layout {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompileRequest {
        CompileRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hlo::HloModuleProto>>(
                "computation",
                |m: &CompileRequest| { &m.computation },
                |m: &mut CompileRequest| { &mut m.computation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutionOptions>>(
                "execution_options",
                |m: &CompileRequest| { &m.execution_options },
                |m: &mut CompileRequest| { &mut m.execution_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "input_shape_with_layout",
                |m: &CompileRequest| { &m.input_shape_with_layout },
                |m: &mut CompileRequest| { &mut m.input_shape_with_layout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompileRequest>(
                "CompileRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompileRequest {
        static instance: ::protobuf::rt::LazyV2<CompileRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompileRequest::new)
    }
}

impl ::protobuf::Clear for CompileRequest {
    fn clear(&mut self) {
        self.computation.clear();
        self.execution_options.clear();
        self.input_shape_with_layout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompileRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompileRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompileResponse {
    // message fields
    pub handle: ::protobuf::SingularPtrField<super::xla_data::ExecutionHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompileResponse {
    fn default() -> &'a CompileResponse {
        <CompileResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompileResponse {
    pub fn new() -> CompileResponse {
        ::std::default::Default::default()
    }

    // .xla.ExecutionHandle handle = 1;


    pub fn get_handle(&self) -> &super::xla_data::ExecutionHandle {
        self.handle.as_ref().unwrap_or_else(|| <super::xla_data::ExecutionHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: super::xla_data::ExecutionHandle) {
        self.handle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut super::xla_data::ExecutionHandle {
        if self.handle.is_none() {
            self.handle.set_default();
        }
        self.handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_handle(&mut self) -> super::xla_data::ExecutionHandle {
        self.handle.take().unwrap_or_else(|| super::xla_data::ExecutionHandle::new())
    }
}

impl ::protobuf::Message for CompileResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.handle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.handle.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompileResponse {
        CompileResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ExecutionHandle>>(
                "handle",
                |m: &CompileResponse| { &m.handle },
                |m: &mut CompileResponse| { &mut m.handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompileResponse>(
                "CompileResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompileResponse {
        static instance: ::protobuf::rt::LazyV2<CompileResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompileResponse::new)
    }
}

impl ::protobuf::Clear for CompileResponse {
    fn clear(&mut self) {
        self.handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompileResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompileResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteRequest {
    // message fields
    pub handle: ::protobuf::SingularPtrField<super::xla_data::ExecutionHandle>,
    pub arguments: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteRequest {
    fn default() -> &'a ExecuteRequest {
        <ExecuteRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteRequest {
    pub fn new() -> ExecuteRequest {
        ::std::default::Default::default()
    }

    // .xla.ExecutionHandle handle = 1;


    pub fn get_handle(&self) -> &super::xla_data::ExecutionHandle {
        self.handle.as_ref().unwrap_or_else(|| <super::xla_data::ExecutionHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_handle(&mut self) {
        self.handle.clear();
    }

    pub fn has_handle(&self) -> bool {
        self.handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: super::xla_data::ExecutionHandle) {
        self.handle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handle(&mut self) -> &mut super::xla_data::ExecutionHandle {
        if self.handle.is_none() {
            self.handle.set_default();
        }
        self.handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_handle(&mut self) -> super::xla_data::ExecutionHandle {
        self.handle.take().unwrap_or_else(|| super::xla_data::ExecutionHandle::new())
    }

    // repeated .xla.GlobalDataHandle arguments = 2;


    pub fn get_arguments(&self) -> &[super::xla_data::GlobalDataHandle] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecuteRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.handle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arguments {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.handle)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arguments)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.handle.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.arguments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteRequest {
        ExecuteRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ExecutionHandle>>(
                "handle",
                |m: &ExecuteRequest| { &m.handle },
                |m: &mut ExecuteRequest| { &mut m.handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "arguments",
                |m: &ExecuteRequest| { &m.arguments },
                |m: &mut ExecuteRequest| { &mut m.arguments },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteRequest>(
                "ExecuteRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteRequest {
        static instance: ::protobuf::rt::LazyV2<ExecuteRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteRequest::new)
    }
}

impl ::protobuf::Clear for ExecuteRequest {
    fn clear(&mut self) {
        self.handle.clear();
        self.arguments.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteGraphRequest {
    // message fields
    pub computation: ::protobuf::SingularPtrField<super::hlo::HloModuleProto>,
    pub arguments: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>,
    pub execution_options: ::protobuf::SingularPtrField<ExecutionOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteGraphRequest {
    fn default() -> &'a ExecuteGraphRequest {
        <ExecuteGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteGraphRequest {
    pub fn new() -> ExecuteGraphRequest {
        ::std::default::Default::default()
    }

    // .xla.HloModuleProto computation = 1;


    pub fn get_computation(&self) -> &super::hlo::HloModuleProto {
        self.computation.as_ref().unwrap_or_else(|| <super::hlo::HloModuleProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_computation(&mut self) {
        self.computation.clear();
    }

    pub fn has_computation(&self) -> bool {
        self.computation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_computation(&mut self, v: super::hlo::HloModuleProto) {
        self.computation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_computation(&mut self) -> &mut super::hlo::HloModuleProto {
        if self.computation.is_none() {
            self.computation.set_default();
        }
        self.computation.as_mut().unwrap()
    }

    // Take field
    pub fn take_computation(&mut self) -> super::hlo::HloModuleProto {
        self.computation.take().unwrap_or_else(|| super::hlo::HloModuleProto::new())
    }

    // repeated .xla.GlobalDataHandle arguments = 2;


    pub fn get_arguments(&self) -> &[super::xla_data::GlobalDataHandle] {
        &self.arguments
    }
    pub fn clear_arguments(&mut self) {
        self.arguments.clear();
    }

    // Param is passed by value, moved
    pub fn set_arguments(&mut self, v: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>) {
        self.arguments = v;
    }

    // Mutable pointer to the field.
    pub fn mut_arguments(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        &mut self.arguments
    }

    // Take field
    pub fn take_arguments(&mut self) -> ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        ::std::mem::replace(&mut self.arguments, ::protobuf::RepeatedField::new())
    }

    // .xla.ExecutionOptions execution_options = 3;


    pub fn get_execution_options(&self) -> &ExecutionOptions {
        self.execution_options.as_ref().unwrap_or_else(|| <ExecutionOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execution_options(&mut self) {
        self.execution_options.clear();
    }

    pub fn has_execution_options(&self) -> bool {
        self.execution_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution_options(&mut self, v: ExecutionOptions) {
        self.execution_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution_options(&mut self) -> &mut ExecutionOptions {
        if self.execution_options.is_none() {
            self.execution_options.set_default();
        }
        self.execution_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_execution_options(&mut self) -> ExecutionOptions {
        self.execution_options.take().unwrap_or_else(|| ExecutionOptions::new())
    }
}

impl ::protobuf::Message for ExecuteGraphRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.computation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.arguments {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.execution_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.computation)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.arguments)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execution_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.computation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.arguments {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.execution_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.computation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.arguments {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.execution_options.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteGraphRequest {
        ExecuteGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hlo::HloModuleProto>>(
                "computation",
                |m: &ExecuteGraphRequest| { &m.computation },
                |m: &mut ExecuteGraphRequest| { &mut m.computation },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "arguments",
                |m: &ExecuteGraphRequest| { &m.arguments },
                |m: &mut ExecuteGraphRequest| { &mut m.arguments },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutionOptions>>(
                "execution_options",
                |m: &ExecuteGraphRequest| { &m.execution_options },
                |m: &mut ExecuteGraphRequest| { &mut m.execution_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteGraphRequest>(
                "ExecuteGraphRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteGraphRequest {
        static instance: ::protobuf::rt::LazyV2<ExecuteGraphRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteGraphRequest::new)
    }
}

impl ::protobuf::Clear for ExecuteGraphRequest {
    fn clear(&mut self) {
        self.computation.clear();
        self.arguments.clear();
        self.execution_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteGraphParallelRequest {
    // message fields
    pub requests: ::protobuf::RepeatedField<ExecuteGraphRequest>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteGraphParallelRequest {
    fn default() -> &'a ExecuteGraphParallelRequest {
        <ExecuteGraphParallelRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteGraphParallelRequest {
    pub fn new() -> ExecuteGraphParallelRequest {
        ::std::default::Default::default()
    }

    // repeated .xla.ExecuteGraphRequest requests = 1;


    pub fn get_requests(&self) -> &[ExecuteGraphRequest] {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<ExecuteGraphRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::protobuf::RepeatedField<ExecuteGraphRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<ExecuteGraphRequest> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecuteGraphParallelRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requests {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteGraphParallelRequest {
        ExecuteGraphParallelRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecuteGraphRequest>>(
                "requests",
                |m: &ExecuteGraphParallelRequest| { &m.requests },
                |m: &mut ExecuteGraphParallelRequest| { &mut m.requests },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteGraphParallelRequest>(
                "ExecuteGraphParallelRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteGraphParallelRequest {
        static instance: ::protobuf::rt::LazyV2<ExecuteGraphParallelRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteGraphParallelRequest::new)
    }
}

impl ::protobuf::Clear for ExecuteGraphParallelRequest {
    fn clear(&mut self) {
        self.requests.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteGraphParallelRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteGraphParallelRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteResponse {
    // message fields
    pub output: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    pub profile: ::protobuf::SingularPtrField<super::xla_data::ExecutionProfile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteResponse {
    fn default() -> &'a ExecuteResponse {
        <ExecuteResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteResponse {
    pub fn new() -> ExecuteResponse {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle output = 1;


    pub fn get_output(&self) -> &super::xla_data::GlobalDataHandle {
        self.output.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    pub fn has_output(&self) -> bool {
        self.output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.output = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.output.is_none() {
            self.output.set_default();
        }
        self.output.as_mut().unwrap()
    }

    // Take field
    pub fn take_output(&mut self) -> super::xla_data::GlobalDataHandle {
        self.output.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }

    // .xla.ExecutionProfile profile = 2;


    pub fn get_profile(&self) -> &super::xla_data::ExecutionProfile {
        self.profile.as_ref().unwrap_or_else(|| <super::xla_data::ExecutionProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile(&mut self) {
        self.profile.clear();
    }

    pub fn has_profile(&self) -> bool {
        self.profile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile(&mut self, v: super::xla_data::ExecutionProfile) {
        self.profile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile(&mut self) -> &mut super::xla_data::ExecutionProfile {
        if self.profile.is_none() {
            self.profile.set_default();
        }
        self.profile.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile(&mut self) -> super::xla_data::ExecutionProfile {
        self.profile.take().unwrap_or_else(|| super::xla_data::ExecutionProfile::new())
    }
}

impl ::protobuf::Message for ExecuteResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.output {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.output.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.profile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.output.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.profile.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteResponse {
        ExecuteResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "output",
                |m: &ExecuteResponse| { &m.output },
                |m: &mut ExecuteResponse| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ExecutionProfile>>(
                "profile",
                |m: &ExecuteResponse| { &m.profile },
                |m: &mut ExecuteResponse| { &mut m.profile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteResponse>(
                "ExecuteResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteResponse {
        static instance: ::protobuf::rt::LazyV2<ExecuteResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteResponse::new)
    }
}

impl ::protobuf::Clear for ExecuteResponse {
    fn clear(&mut self) {
        self.output.clear();
        self.profile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecuteParallelResponse {
    // message fields
    pub responses: ::protobuf::RepeatedField<ExecuteResponse>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecuteParallelResponse {
    fn default() -> &'a ExecuteParallelResponse {
        <ExecuteParallelResponse as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteParallelResponse {
    pub fn new() -> ExecuteParallelResponse {
        ::std::default::Default::default()
    }

    // repeated .xla.ExecuteResponse responses = 1;


    pub fn get_responses(&self) -> &[ExecuteResponse] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<ExecuteResponse>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<ExecuteResponse> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<ExecuteResponse> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecuteParallelResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.responses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecuteParallelResponse {
        ExecuteParallelResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecuteResponse>>(
                "responses",
                |m: &ExecuteParallelResponse| { &m.responses },
                |m: &mut ExecuteParallelResponse| { &mut m.responses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecuteParallelResponse>(
                "ExecuteParallelResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecuteParallelResponse {
        static instance: ::protobuf::rt::LazyV2<ExecuteParallelResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecuteParallelResponse::new)
    }
}

impl ::protobuf::Clear for ExecuteParallelResponse {
    fn clear(&mut self) {
        self.responses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecuteParallelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteParallelResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitForExecutionRequest {
    // message fields
    pub execution: ::protobuf::SingularPtrField<super::xla_data::ExecutionHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitForExecutionRequest {
    fn default() -> &'a WaitForExecutionRequest {
        <WaitForExecutionRequest as ::protobuf::Message>::default_instance()
    }
}

impl WaitForExecutionRequest {
    pub fn new() -> WaitForExecutionRequest {
        ::std::default::Default::default()
    }

    // .xla.ExecutionHandle execution = 1;


    pub fn get_execution(&self) -> &super::xla_data::ExecutionHandle {
        self.execution.as_ref().unwrap_or_else(|| <super::xla_data::ExecutionHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_execution(&mut self) {
        self.execution.clear();
    }

    pub fn has_execution(&self) -> bool {
        self.execution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_execution(&mut self, v: super::xla_data::ExecutionHandle) {
        self.execution = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_execution(&mut self) -> &mut super::xla_data::ExecutionHandle {
        if self.execution.is_none() {
            self.execution.set_default();
        }
        self.execution.as_mut().unwrap()
    }

    // Take field
    pub fn take_execution(&mut self) -> super::xla_data::ExecutionHandle {
        self.execution.take().unwrap_or_else(|| super::xla_data::ExecutionHandle::new())
    }
}

impl ::protobuf::Message for WaitForExecutionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.execution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.execution)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.execution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.execution.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitForExecutionRequest {
        WaitForExecutionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ExecutionHandle>>(
                "execution",
                |m: &WaitForExecutionRequest| { &m.execution },
                |m: &mut WaitForExecutionRequest| { &mut m.execution },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitForExecutionRequest>(
                "WaitForExecutionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WaitForExecutionRequest {
        static instance: ::protobuf::rt::LazyV2<WaitForExecutionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WaitForExecutionRequest::new)
    }
}

impl ::protobuf::Clear for WaitForExecutionRequest {
    fn clear(&mut self) {
        self.execution.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitForExecutionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitForExecutionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WaitForExecutionResponse {
    // message fields
    pub output: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    pub profile: ::protobuf::SingularPtrField<super::xla_data::ExecutionProfile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WaitForExecutionResponse {
    fn default() -> &'a WaitForExecutionResponse {
        <WaitForExecutionResponse as ::protobuf::Message>::default_instance()
    }
}

impl WaitForExecutionResponse {
    pub fn new() -> WaitForExecutionResponse {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle output = 1;


    pub fn get_output(&self) -> &super::xla_data::GlobalDataHandle {
        self.output.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output(&mut self) {
        self.output.clear();
    }

    pub fn has_output(&self) -> bool {
        self.output.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.output = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.output.is_none() {
            self.output.set_default();
        }
        self.output.as_mut().unwrap()
    }

    // Take field
    pub fn take_output(&mut self) -> super::xla_data::GlobalDataHandle {
        self.output.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }

    // .xla.ExecutionProfile profile = 2;


    pub fn get_profile(&self) -> &super::xla_data::ExecutionProfile {
        self.profile.as_ref().unwrap_or_else(|| <super::xla_data::ExecutionProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_profile(&mut self) {
        self.profile.clear();
    }

    pub fn has_profile(&self) -> bool {
        self.profile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_profile(&mut self, v: super::xla_data::ExecutionProfile) {
        self.profile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_profile(&mut self) -> &mut super::xla_data::ExecutionProfile {
        if self.profile.is_none() {
            self.profile.set_default();
        }
        self.profile.as_mut().unwrap()
    }

    // Take field
    pub fn take_profile(&mut self) -> super::xla_data::ExecutionProfile {
        self.profile.take().unwrap_or_else(|| super::xla_data::ExecutionProfile::new())
    }
}

impl ::protobuf::Message for WaitForExecutionResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.output {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.profile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.profile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.output.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.profile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.output.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.profile.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WaitForExecutionResponse {
        WaitForExecutionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "output",
                |m: &WaitForExecutionResponse| { &m.output },
                |m: &mut WaitForExecutionResponse| { &mut m.output },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ExecutionProfile>>(
                "profile",
                |m: &WaitForExecutionResponse| { &m.profile },
                |m: &mut WaitForExecutionResponse| { &mut m.profile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WaitForExecutionResponse>(
                "WaitForExecutionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WaitForExecutionResponse {
        static instance: ::protobuf::rt::LazyV2<WaitForExecutionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WaitForExecutionResponse::new)
    }
}

impl ::protobuf::Clear for WaitForExecutionResponse {
    fn clear(&mut self) {
        self.output.clear();
        self.profile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WaitForExecutionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WaitForExecutionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputeConstantGraphRequest {
    // message fields
    pub computation: ::protobuf::SingularPtrField<super::hlo::HloModuleProto>,
    pub output_layout: ::protobuf::SingularPtrField<super::xla_data::LayoutProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputeConstantGraphRequest {
    fn default() -> &'a ComputeConstantGraphRequest {
        <ComputeConstantGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl ComputeConstantGraphRequest {
    pub fn new() -> ComputeConstantGraphRequest {
        ::std::default::Default::default()
    }

    // .xla.HloModuleProto computation = 1;


    pub fn get_computation(&self) -> &super::hlo::HloModuleProto {
        self.computation.as_ref().unwrap_or_else(|| <super::hlo::HloModuleProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_computation(&mut self) {
        self.computation.clear();
    }

    pub fn has_computation(&self) -> bool {
        self.computation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_computation(&mut self, v: super::hlo::HloModuleProto) {
        self.computation = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_computation(&mut self) -> &mut super::hlo::HloModuleProto {
        if self.computation.is_none() {
            self.computation.set_default();
        }
        self.computation.as_mut().unwrap()
    }

    // Take field
    pub fn take_computation(&mut self) -> super::hlo::HloModuleProto {
        self.computation.take().unwrap_or_else(|| super::hlo::HloModuleProto::new())
    }

    // .xla.LayoutProto output_layout = 2;


    pub fn get_output_layout(&self) -> &super::xla_data::LayoutProto {
        self.output_layout.as_ref().unwrap_or_else(|| <super::xla_data::LayoutProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_output_layout(&mut self) {
        self.output_layout.clear();
    }

    pub fn has_output_layout(&self) -> bool {
        self.output_layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_output_layout(&mut self, v: super::xla_data::LayoutProto) {
        self.output_layout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_output_layout(&mut self) -> &mut super::xla_data::LayoutProto {
        if self.output_layout.is_none() {
            self.output_layout.set_default();
        }
        self.output_layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_output_layout(&mut self) -> super::xla_data::LayoutProto {
        self.output_layout.take().unwrap_or_else(|| super::xla_data::LayoutProto::new())
    }
}

impl ::protobuf::Message for ComputeConstantGraphRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.computation {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.output_layout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.computation)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.output_layout)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.computation.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.output_layout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.computation.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.output_layout.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputeConstantGraphRequest {
        ComputeConstantGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::hlo::HloModuleProto>>(
                "computation",
                |m: &ComputeConstantGraphRequest| { &m.computation },
                |m: &mut ComputeConstantGraphRequest| { &mut m.computation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LayoutProto>>(
                "output_layout",
                |m: &ComputeConstantGraphRequest| { &m.output_layout },
                |m: &mut ComputeConstantGraphRequest| { &mut m.output_layout },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputeConstantGraphRequest>(
                "ComputeConstantGraphRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputeConstantGraphRequest {
        static instance: ::protobuf::rt::LazyV2<ComputeConstantGraphRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputeConstantGraphRequest::new)
    }
}

impl ::protobuf::Clear for ComputeConstantGraphRequest {
    fn clear(&mut self) {
        self.computation.clear();
        self.output_layout.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputeConstantGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeConstantGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputeConstantResponse {
    // message fields
    pub literal: ::protobuf::SingularPtrField<super::xla_data::LiteralProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputeConstantResponse {
    fn default() -> &'a ComputeConstantResponse {
        <ComputeConstantResponse as ::protobuf::Message>::default_instance()
    }
}

impl ComputeConstantResponse {
    pub fn new() -> ComputeConstantResponse {
        ::std::default::Default::default()
    }

    // .xla.LiteralProto literal = 1;


    pub fn get_literal(&self) -> &super::xla_data::LiteralProto {
        self.literal.as_ref().unwrap_or_else(|| <super::xla_data::LiteralProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_literal(&mut self) {
        self.literal.clear();
    }

    pub fn has_literal(&self) -> bool {
        self.literal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_literal(&mut self, v: super::xla_data::LiteralProto) {
        self.literal = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_literal(&mut self) -> &mut super::xla_data::LiteralProto {
        if self.literal.is_none() {
            self.literal.set_default();
        }
        self.literal.as_mut().unwrap()
    }

    // Take field
    pub fn take_literal(&mut self) -> super::xla_data::LiteralProto {
        self.literal.take().unwrap_or_else(|| super::xla_data::LiteralProto::new())
    }
}

impl ::protobuf::Message for ComputeConstantResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.literal {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.literal)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.literal.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.literal.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputeConstantResponse {
        ComputeConstantResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::LiteralProto>>(
                "literal",
                |m: &ComputeConstantResponse| { &m.literal },
                |m: &mut ComputeConstantResponse| { &mut m.literal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputeConstantResponse>(
                "ComputeConstantResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputeConstantResponse {
        static instance: ::protobuf::rt::LazyV2<ComputeConstantResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputeConstantResponse::new)
    }
}

impl ::protobuf::Clear for ComputeConstantResponse {
    fn clear(&mut self) {
        self.literal.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputeConstantResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputeConstantResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeconstructTupleRequest {
    // message fields
    pub tuple_handle: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeconstructTupleRequest {
    fn default() -> &'a DeconstructTupleRequest {
        <DeconstructTupleRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeconstructTupleRequest {
    pub fn new() -> DeconstructTupleRequest {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle tuple_handle = 2;


    pub fn get_tuple_handle(&self) -> &super::xla_data::GlobalDataHandle {
        self.tuple_handle.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tuple_handle(&mut self) {
        self.tuple_handle.clear();
    }

    pub fn has_tuple_handle(&self) -> bool {
        self.tuple_handle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tuple_handle(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.tuple_handle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tuple_handle(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.tuple_handle.is_none() {
            self.tuple_handle.set_default();
        }
        self.tuple_handle.as_mut().unwrap()
    }

    // Take field
    pub fn take_tuple_handle(&mut self) -> super::xla_data::GlobalDataHandle {
        self.tuple_handle.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }
}

impl ::protobuf::Message for DeconstructTupleRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.tuple_handle {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tuple_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tuple_handle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tuple_handle.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeconstructTupleRequest {
        DeconstructTupleRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "tuple_handle",
                |m: &DeconstructTupleRequest| { &m.tuple_handle },
                |m: &mut DeconstructTupleRequest| { &mut m.tuple_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeconstructTupleRequest>(
                "DeconstructTupleRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeconstructTupleRequest {
        static instance: ::protobuf::rt::LazyV2<DeconstructTupleRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeconstructTupleRequest::new)
    }
}

impl ::protobuf::Clear for DeconstructTupleRequest {
    fn clear(&mut self) {
        self.tuple_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeconstructTupleRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeconstructTupleRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeconstructTupleResponse {
    // message fields
    pub element_handles: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeconstructTupleResponse {
    fn default() -> &'a DeconstructTupleResponse {
        <DeconstructTupleResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeconstructTupleResponse {
    pub fn new() -> DeconstructTupleResponse {
        ::std::default::Default::default()
    }

    // repeated .xla.GlobalDataHandle element_handles = 1;


    pub fn get_element_handles(&self) -> &[super::xla_data::GlobalDataHandle] {
        &self.element_handles
    }
    pub fn clear_element_handles(&mut self) {
        self.element_handles.clear();
    }

    // Param is passed by value, moved
    pub fn set_element_handles(&mut self, v: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>) {
        self.element_handles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_element_handles(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        &mut self.element_handles
    }

    // Take field
    pub fn take_element_handles(&mut self) -> ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        ::std::mem::replace(&mut self.element_handles, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeconstructTupleResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.element_handles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.element_handles)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.element_handles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.element_handles {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeconstructTupleResponse {
        DeconstructTupleResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "element_handles",
                |m: &DeconstructTupleResponse| { &m.element_handles },
                |m: &mut DeconstructTupleResponse| { &mut m.element_handles },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeconstructTupleResponse>(
                "DeconstructTupleResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeconstructTupleResponse {
        static instance: ::protobuf::rt::LazyV2<DeconstructTupleResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeconstructTupleResponse::new)
    }
}

impl ::protobuf::Clear for DeconstructTupleResponse {
    fn clear(&mut self) {
        self.element_handles.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeconstructTupleResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeconstructTupleResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadDataRequest {
    // message fields
    pub columnio_tablet_path: ::std::string::String,
    pub columnio_field: ::std::string::String,
    pub element_shape: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    pub offset: i64,
    pub limit: i64,
    pub zip: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadDataRequest {
    fn default() -> &'a LoadDataRequest {
        <LoadDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoadDataRequest {
    pub fn new() -> LoadDataRequest {
        ::std::default::Default::default()
    }

    // string columnio_tablet_path = 1;


    pub fn get_columnio_tablet_path(&self) -> &str {
        &self.columnio_tablet_path
    }
    pub fn clear_columnio_tablet_path(&mut self) {
        self.columnio_tablet_path.clear();
    }

    // Param is passed by value, moved
    pub fn set_columnio_tablet_path(&mut self, v: ::std::string::String) {
        self.columnio_tablet_path = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_columnio_tablet_path(&mut self) -> &mut ::std::string::String {
        &mut self.columnio_tablet_path
    }

    // Take field
    pub fn take_columnio_tablet_path(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.columnio_tablet_path, ::std::string::String::new())
    }

    // string columnio_field = 2;


    pub fn get_columnio_field(&self) -> &str {
        &self.columnio_field
    }
    pub fn clear_columnio_field(&mut self) {
        self.columnio_field.clear();
    }

    // Param is passed by value, moved
    pub fn set_columnio_field(&mut self, v: ::std::string::String) {
        self.columnio_field = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_columnio_field(&mut self) -> &mut ::std::string::String {
        &mut self.columnio_field
    }

    // Take field
    pub fn take_columnio_field(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.columnio_field, ::std::string::String::new())
    }

    // .xla.ShapeProto element_shape = 3;


    pub fn get_element_shape(&self) -> &super::xla_data::ShapeProto {
        self.element_shape.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_element_shape(&mut self) {
        self.element_shape.clear();
    }

    pub fn has_element_shape(&self) -> bool {
        self.element_shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_element_shape(&mut self, v: super::xla_data::ShapeProto) {
        self.element_shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_element_shape(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.element_shape.is_none() {
            self.element_shape.set_default();
        }
        self.element_shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_element_shape(&mut self) -> super::xla_data::ShapeProto {
        self.element_shape.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }

    // int64 offset = 4;


    pub fn get_offset(&self) -> i64 {
        self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: i64) {
        self.offset = v;
    }

    // int64 limit = 5;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }

    // bool zip = 6;


    pub fn get_zip(&self) -> bool {
        self.zip
    }
    pub fn clear_zip(&mut self) {
        self.zip = false;
    }

    // Param is passed by value, moved
    pub fn set_zip(&mut self, v: bool) {
        self.zip = v;
    }
}

impl ::protobuf::Message for LoadDataRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.element_shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.columnio_tablet_path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.columnio_field)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.element_shape)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.offset = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.zip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.columnio_tablet_path.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.columnio_tablet_path);
        }
        if !self.columnio_field.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.columnio_field);
        }
        if let Some(ref v) = self.element_shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(5, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.zip != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.columnio_tablet_path.is_empty() {
            os.write_string(1, &self.columnio_tablet_path)?;
        }
        if !self.columnio_field.is_empty() {
            os.write_string(2, &self.columnio_field)?;
        }
        if let Some(ref v) = self.element_shape.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.offset != 0 {
            os.write_int64(4, self.offset)?;
        }
        if self.limit != 0 {
            os.write_int64(5, self.limit)?;
        }
        if self.zip != false {
            os.write_bool(6, self.zip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadDataRequest {
        LoadDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columnio_tablet_path",
                |m: &LoadDataRequest| { &m.columnio_tablet_path },
                |m: &mut LoadDataRequest| { &mut m.columnio_tablet_path },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "columnio_field",
                |m: &LoadDataRequest| { &m.columnio_field },
                |m: &mut LoadDataRequest| { &mut m.columnio_field },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "element_shape",
                |m: &LoadDataRequest| { &m.element_shape },
                |m: &mut LoadDataRequest| { &mut m.element_shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "offset",
                |m: &LoadDataRequest| { &m.offset },
                |m: &mut LoadDataRequest| { &mut m.offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &LoadDataRequest| { &m.limit },
                |m: &mut LoadDataRequest| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "zip",
                |m: &LoadDataRequest| { &m.zip },
                |m: &mut LoadDataRequest| { &mut m.zip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadDataRequest>(
                "LoadDataRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadDataRequest {
        static instance: ::protobuf::rt::LazyV2<LoadDataRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadDataRequest::new)
    }
}

impl ::protobuf::Clear for LoadDataRequest {
    fn clear(&mut self) {
        self.columnio_tablet_path.clear();
        self.columnio_field.clear();
        self.element_shape.clear();
        self.offset = 0;
        self.limit = 0;
        self.zip = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadDataResponse {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    pub data_shape: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    pub available_rows: i64,
    pub rows_loaded: i64,
    pub nanoseconds: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadDataResponse {
    fn default() -> &'a LoadDataResponse {
        <LoadDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoadDataResponse {
    pub fn new() -> LoadDataResponse {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle data = 1;


    pub fn get_data(&self) -> &super::xla_data::GlobalDataHandle {
        self.data.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::xla_data::GlobalDataHandle {
        self.data.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }

    // .xla.ShapeProto data_shape = 2;


    pub fn get_data_shape(&self) -> &super::xla_data::ShapeProto {
        self.data_shape.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data_shape(&mut self) {
        self.data_shape.clear();
    }

    pub fn has_data_shape(&self) -> bool {
        self.data_shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data_shape(&mut self, v: super::xla_data::ShapeProto) {
        self.data_shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data_shape(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.data_shape.is_none() {
            self.data_shape.set_default();
        }
        self.data_shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_data_shape(&mut self) -> super::xla_data::ShapeProto {
        self.data_shape.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }

    // int64 available_rows = 3;


    pub fn get_available_rows(&self) -> i64 {
        self.available_rows
    }
    pub fn clear_available_rows(&mut self) {
        self.available_rows = 0;
    }

    // Param is passed by value, moved
    pub fn set_available_rows(&mut self, v: i64) {
        self.available_rows = v;
    }

    // int64 rows_loaded = 4;


    pub fn get_rows_loaded(&self) -> i64 {
        self.rows_loaded
    }
    pub fn clear_rows_loaded(&mut self) {
        self.rows_loaded = 0;
    }

    // Param is passed by value, moved
    pub fn set_rows_loaded(&mut self, v: i64) {
        self.rows_loaded = v;
    }

    // int64 nanoseconds = 5;


    pub fn get_nanoseconds(&self) -> i64 {
        self.nanoseconds
    }
    pub fn clear_nanoseconds(&mut self) {
        self.nanoseconds = 0;
    }

    // Param is passed by value, moved
    pub fn set_nanoseconds(&mut self, v: i64) {
        self.nanoseconds = v;
    }
}

impl ::protobuf::Message for LoadDataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data_shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data_shape)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.available_rows = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.rows_loaded = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nanoseconds = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.data_shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.available_rows != 0 {
            my_size += ::protobuf::rt::value_size(3, self.available_rows, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rows_loaded != 0 {
            my_size += ::protobuf::rt::value_size(4, self.rows_loaded, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nanoseconds != 0 {
            my_size += ::protobuf::rt::value_size(5, self.nanoseconds, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.data_shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.available_rows != 0 {
            os.write_int64(3, self.available_rows)?;
        }
        if self.rows_loaded != 0 {
            os.write_int64(4, self.rows_loaded)?;
        }
        if self.nanoseconds != 0 {
            os.write_int64(5, self.nanoseconds)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadDataResponse {
        LoadDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "data",
                |m: &LoadDataResponse| { &m.data },
                |m: &mut LoadDataResponse| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "data_shape",
                |m: &LoadDataResponse| { &m.data_shape },
                |m: &mut LoadDataResponse| { &mut m.data_shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "available_rows",
                |m: &LoadDataResponse| { &m.available_rows },
                |m: &mut LoadDataResponse| { &mut m.available_rows },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "rows_loaded",
                |m: &LoadDataResponse| { &m.rows_loaded },
                |m: &mut LoadDataResponse| { &mut m.rows_loaded },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nanoseconds",
                |m: &LoadDataResponse| { &m.nanoseconds },
                |m: &mut LoadDataResponse| { &mut m.nanoseconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadDataResponse>(
                "LoadDataResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadDataResponse {
        static instance: ::protobuf::rt::LazyV2<LoadDataResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadDataResponse::new)
    }
}

impl ::protobuf::Clear for LoadDataResponse {
    fn clear(&mut self) {
        self.data.clear();
        self.data_shape.clear();
        self.available_rows = 0;
        self.rows_loaded = 0;
        self.nanoseconds = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetShapeRequest {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetShapeRequest {
    fn default() -> &'a GetShapeRequest {
        <GetShapeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetShapeRequest {
    pub fn new() -> GetShapeRequest {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle data = 1;


    pub fn get_data(&self) -> &super::xla_data::GlobalDataHandle {
        self.data.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::xla_data::GlobalDataHandle {
        self.data.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }
}

impl ::protobuf::Message for GetShapeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetShapeRequest {
        GetShapeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "data",
                |m: &GetShapeRequest| { &m.data },
                |m: &mut GetShapeRequest| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetShapeRequest>(
                "GetShapeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetShapeRequest {
        static instance: ::protobuf::rt::LazyV2<GetShapeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetShapeRequest::new)
    }
}

impl ::protobuf::Clear for GetShapeRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetShapeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShapeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetShapeResponse {
    // message fields
    pub shape: ::protobuf::SingularPtrField<super::xla_data::ShapeProto>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetShapeResponse {
    fn default() -> &'a GetShapeResponse {
        <GetShapeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetShapeResponse {
    pub fn new() -> GetShapeResponse {
        ::std::default::Default::default()
    }

    // .xla.ShapeProto shape = 1;


    pub fn get_shape(&self) -> &super::xla_data::ShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <super::xla_data::ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: super::xla_data::ShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut super::xla_data::ShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> super::xla_data::ShapeProto {
        self.shape.take().unwrap_or_else(|| super::xla_data::ShapeProto::new())
    }
}

impl ::protobuf::Message for GetShapeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetShapeResponse {
        GetShapeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::ShapeProto>>(
                "shape",
                |m: &GetShapeResponse| { &m.shape },
                |m: &mut GetShapeResponse| { &mut m.shape },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetShapeResponse>(
                "GetShapeResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetShapeResponse {
        static instance: ::protobuf::rt::LazyV2<GetShapeResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetShapeResponse::new)
    }
}

impl ::protobuf::Clear for GetShapeResponse {
    fn clear(&mut self) {
        self.shape.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetShapeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetShapeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnpackRequest {
    // message fields
    pub data: ::protobuf::SingularPtrField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnpackRequest {
    fn default() -> &'a UnpackRequest {
        <UnpackRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnpackRequest {
    pub fn new() -> UnpackRequest {
        ::std::default::Default::default()
    }

    // .xla.GlobalDataHandle data = 1;


    pub fn get_data(&self) -> &super::xla_data::GlobalDataHandle {
        self.data.as_ref().unwrap_or_else(|| <super::xla_data::GlobalDataHandle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: super::xla_data::GlobalDataHandle) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut super::xla_data::GlobalDataHandle {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> super::xla_data::GlobalDataHandle {
        self.data.take().unwrap_or_else(|| super::xla_data::GlobalDataHandle::new())
    }
}

impl ::protobuf::Message for UnpackRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnpackRequest {
        UnpackRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "data",
                |m: &UnpackRequest| { &m.data },
                |m: &mut UnpackRequest| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnpackRequest>(
                "UnpackRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnpackRequest {
        static instance: ::protobuf::rt::LazyV2<UnpackRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnpackRequest::new)
    }
}

impl ::protobuf::Clear for UnpackRequest {
    fn clear(&mut self) {
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnpackRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnpackRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UnpackResponse {
    // message fields
    pub tied_data: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UnpackResponse {
    fn default() -> &'a UnpackResponse {
        <UnpackResponse as ::protobuf::Message>::default_instance()
    }
}

impl UnpackResponse {
    pub fn new() -> UnpackResponse {
        ::std::default::Default::default()
    }

    // repeated .xla.GlobalDataHandle tied_data = 1;


    pub fn get_tied_data(&self) -> &[super::xla_data::GlobalDataHandle] {
        &self.tied_data
    }
    pub fn clear_tied_data(&mut self) {
        self.tied_data.clear();
    }

    // Param is passed by value, moved
    pub fn set_tied_data(&mut self, v: ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle>) {
        self.tied_data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tied_data(&mut self) -> &mut ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        &mut self.tied_data
    }

    // Take field
    pub fn take_tied_data(&mut self) -> ::protobuf::RepeatedField<super::xla_data::GlobalDataHandle> {
        ::std::mem::replace(&mut self.tied_data, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UnpackResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tied_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tied_data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.tied_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.tied_data {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UnpackResponse {
        UnpackResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::xla_data::GlobalDataHandle>>(
                "tied_data",
                |m: &UnpackResponse| { &m.tied_data },
                |m: &mut UnpackResponse| { &mut m.tied_data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UnpackResponse>(
                "UnpackResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UnpackResponse {
        static instance: ::protobuf::rt::LazyV2<UnpackResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UnpackResponse::new)
    }
}

impl ::protobuf::Clear for UnpackResponse {
    fn clear(&mut self) {
        self.tied_data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UnpackResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnpackResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n!tensorflow/compiler/xla/xla.proto\x12\x03xla\x1a)tensorflow/compiler/\
    xla/service/hlo.proto\x1a&tensorflow/compiler/xla/xla_data.proto\"\x95\
    \x03\n\x19HloReducePrecisionOptions\x12C\n\x08location\x18\x01\x20\x01(\
    \x0e2'.xla.HloReducePrecisionOptions.LocationR\x08location\x12#\n\rexpon\
    ent_bits\x18\x02\x20\x01(\rR\x0cexponentBits\x12#\n\rmantissa_bits\x18\
    \x03\x20\x01(\rR\x0cmantissaBits\x12*\n\x11opcodes_to_suffix\x18\x04\x20\
    \x03(\rR\x0fopcodesToSuffix\x12=\n\x1bopname_substrings_to_suffix\x18\
    \x05\x20\x03(\tR\x18opnameSubstringsToSuffix\"~\n\x08Location\x12\r\n\tO\
    P_INPUTS\x10\0\x12\x0e\n\nOP_OUTPUTS\x10\x01\x12\x16\n\x12UNFUSED_OP_OUT\
    PUTS\x10\x02\x12\x1c\n\x18FUSION_INPUTS_BY_CONTENT\x10\x03\x12\x1d\n\x19\
    FUSION_OUTPUTS_BY_CONTENT\x10\x04\"\xc7\x1a\n\x0cDebugOptions\x125\n\x17\
    xla_hlo_graph_addresses\x18\x02\x20\x01(\x08R\x14xlaHloGraphAddresses\
    \x12&\n\x0fxla_hlo_profile\x18\t\x20\x01(\x08R\rxlaHloProfile\x123\n\x16\
    xla_disable_hlo_passes\x18\x1e\x20\x03(\tR\x13xlaDisableHloPasses\x12:\n\
    \x1axla_enable_hlo_passes_only\x18|\x20\x03(\tR\x16xlaEnableHloPassesOnl\
    y\x12:\n\x1axla_disable_all_hlo_passes\x18h\x20\x01(\x08R\x16xlaDisableA\
    llHloPasses\x12C\n\x1exla_backend_optimization_level\x18\x1f\x20\x01(\
    \x05R\x1bxlaBackendOptimizationLevel\x12:\n\x1axla_embed_ir_in_executabl\
    e\x18!\x20\x01(\x08R\x16xlaEmbedIrInExecutable\x12N\n$xla_eliminate_hlo_\
    implicit_broadcast\x18#\x20\x01(\x08R\x20xlaEliminateHloImplicitBroadcas\
    t\x12:\n\x1axla_cpu_multi_thread_eigen\x18<\x20\x01(\x08R\x16xlaCpuMulti\
    ThreadEigen\x120\n\x15xla_gpu_cuda_data_dir\x18=\x20\x01(\tR\x11xlaGpuCu\
    daDataDir\x12\x1e\n\x0bxla_gpu_ftz\x18>\x20\x01(\x08R\txlaGpuFtz\x12D\n\
    \x1fxla_gpu_disable_multi_streaming\x18?\x20\x01(\x08R\x1bxlaGpuDisableM\
    ultiStreaming\x12M\n$xla_llvm_enable_alias_scope_metadata\x18F\x20\x01(\
    \x08R\x1fxlaLlvmEnableAliasScopeMetadata\x12F\n\x20xla_llvm_enable_noali\
    as_metadata\x18G\x20\x01(\x08R\x1cxlaLlvmEnableNoaliasMetadata\x12S\n'xl\
    a_llvm_enable_invariant_load_metadata\x18H\x20\x01(\x08R\"xlaLlvmEnableI\
    nvariantLoadMetadata\x12H\n!xla_llvm_disable_expensive_passes\x18I\x20\
    \x01(\x08R\x1dxlaLlvmDisableExpensivePasses\x12_\n\x1chlo_reduce_precisi\
    on_options\x18P\x20\x03(\x0b2\x1e.xla.HloReducePrecisionOptionsR\x19hloR\
    educePrecisionOptions\x12<\n\x1bxla_test_all_output_layouts\x18Z\x20\x01\
    (\x08R\x17xlaTestAllOutputLayouts\x12:\n\x1axla_test_all_input_layouts\
    \x18[\x20\x01(\x08R\x16xlaTestAllInputLayouts\x12>\n\x1cxla_hlo_graph_sh\
    arding_color\x18\\\x20\x01(\x08R\x18xlaHloGraphShardingColor\x12<\n\x1bx\
    la_gpu_use_cudnn_batchnorm\x18^\x20\x01(\x08R\x17xlaGpuUseCudnnBatchnorm\
    \x12,\n\x13xla_cpu_use_mkl_dnn\x18a\x20\x01(\x08R\x0fxlaCpuUseMklDnn\x12\
    E\n\x20xla_gpu_max_kernel_unroll_factor\x18b\x20\x01(\x05R\x1bxlaGpuMaxK\
    ernelUnrollFactor\x126\n\x18xla_cpu_enable_fast_math\x18c\x20\x01(\x08R\
    \x14xlaCpuEnableFastMath\x12=\n\x1cxla_cpu_fast_math_honor_nans\x18x\x20\
    \x01(\x08R\x17xlaCpuFastMathHonorNans\x12=\n\x1cxla_cpu_fast_math_honor_\
    infs\x18y\x20\x01(\x08R\x17xlaCpuFastMathHonorInfs\x12E\n\x20xla_cpu_fas\
    t_math_honor_division\x18~\x20\x01(\x08R\x1bxlaCpuFastMathHonorDivision\
    \x12H\n!xla_cpu_fast_math_honor_functions\x18\x81\x01\x20\x01(\x08R\x1cx\
    laCpuFastMathHonorFunctions\x12;\n\x1bxla_gpu_enable_fast_min_max\x18d\
    \x20\x01(\x08R\x16xlaGpuEnableFastMinMax\x12;\n\x1axla_allow_excess_prec\
    ision\x18z\x20\x01(\x08R\x17xlaAllowExcessPrecision\x12Q\n&xla_gpu_crash\
    _on_verification_failures\x18e\x20\x01(\x08R!xlaGpuCrashOnVerificationFa\
    ilures\x127\n\x18xla_gpu_disable_autotune\x18{\x20\x01(\x08R\x15xlaGpuDi\
    sableAutotune\x12M\n$xla_force_host_platform_device_count\x18f\x20\x01(\
    \x05R\x1fxlaForceHostPlatformDeviceCount\x12L\n#xla_gpu_disable_ptxas_op\
    timizations\x18g\x20\x01(\x08R\x1fxlaGpuDisablePtxasOptimizations\x12C\n\
    \x1fxla_hlo_evaluator_use_fast_path\x18j\x20\x01(\x08R\x1axlaHloEvaluato\
    rUseFastPath\x12I\n\"xla_allow_scalar_index_dynamic_ops\x18k\x20\x01(\
    \x08R\x1dxlaAllowScalarIndexDynamicOps\x12]\n\x18xla_step_marker_locatio\
    n\x18l\x20\x01(\x0e2$.xla.DebugOptions.StepMarkerLocationR\x15xlaStepMar\
    kerLocation\x12\x1e\n\x0bxla_dump_to\x18m\x20\x01(\tR\txlaDumpTo\x122\n\
    \x16xla_dump_hlo_module_re\x18n\x20\x01(\tR\x12xlaDumpHloModuleRe\x12.\n\
    \x14xla_dump_hlo_pass_re\x18o\x20\x01(\tR\x10xlaDumpHloPassRe\x12.\n\x14\
    xla_dump_hlo_as_text\x18p\x20\x01(\x08R\x10xlaDumpHloAsText\x120\n\x15xl\
    a_dump_hlo_as_proto\x18q\x20\x01(\x08R\x11xlaDumpHloAsProto\x12,\n\x13xl\
    a_dump_hlo_as_dot\x18r\x20\x01(\x08R\x0fxlaDumpHloAsDot\x12,\n\x13xla_du\
    mp_hlo_as_url\x18s\x20\x01(\x08R\x0fxlaDumpHloAsUrl\x12.\n\x14xla_dump_h\
    lo_as_html\x18t\x20\x01(\x08R\x10xlaDumpHloAsHtml\x123\n\x16xla_dump_hlo\
    _snapshots\x18v\x20\x01(\x08R\x13xlaDumpHloSnapshots\x124\n\x17xla_gpu_f\
    orce_conv_nchw\x18}\x20\x01(\x08R\x13xlaGpuForceConvNchw\x12'\n\x10xla_g\
    pu_ptx_file\x18\x7f\x20\x03(\tR\rxlaGpuPtxFile\x12G\n\x20xla_gpu_algorit\
    hm_blacklist_path\x18\x80\x01\x20\x01(\tR\x1cxlaGpuAlgorithmBlacklistPat\
    h\x12i\n\x19xla_backend_extra_options\x18\xf4\x03\x20\x03(\x0b2-.xla.Deb\
    ugOptions.XlaBackendExtraOptionsEntryR\x16xlaBackendExtraOptions\x1aI\n\
    \x1bXlaBackendExtraOptionsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x91\x01\
    \n\x12StepMarkerLocation\x12\x16\n\x12STEP_MARK_AT_ENTRY\x10\0\x12%\n!ST\
    EP_MARK_AT_TOP_LEVEL_WHILE_LOOP\x10\x01\x12(\n$STEP_MARK_AT_SECOND_LEVEL\
    _WHILE_LOOP\x10\x03\x12\x12\n\x0eSTEP_MARK_NONE\x10\x02J\x04\x08]\x10^J\
    \x04\x08u\x10vJ\x04\x08\x05\x10\x06\"\xce\x02\n\x10ExecutionOptions\x12H\
    \n\x18shape_with_output_layout\x18\x02\x20\x01(\x0b2\x0f.xla.ShapeProtoR\
    \x15shapeWithOutputLayout\x12\x12\n\x04seed\x18\x03\x20\x01(\x04R\x04see\
    d\x126\n\rdebug_options\x18\x04\x20\x01(\x0b2\x11.xla.DebugOptionsR\x0cd\
    ebugOptions\x128\n\x0edevice_handles\x18\x05\x20\x03(\x0b2\x11.xla.Devic\
    eHandleR\rdeviceHandles\x12!\n\x0cnum_replicas\x18\x06\x20\x01(\x05R\x0b\
    numReplicas\x12G\n\x11device_assignment\x18\x07\x20\x01(\x0b2\x1a.xla.De\
    viceAssignmentProtoR\x10deviceAssignment\"<\n\x17GetDeviceHandlesRequest\
    \x12!\n\x0cdevice_count\x18\x01\x20\x01(\x03R\x0bdeviceCount\"T\n\x18Get\
    DeviceHandlesResponse\x128\n\x0edevice_handles\x18\x01\x20\x03(\x0b2\x11\
    .xla.DeviceHandleR\rdeviceHandles\"\x81\x01\n\x17TransferToClientRequest\
    \x12)\n\x04data\x18\x01\x20\x01(\x0b2\x15.xla.GlobalDataHandleR\x04data\
    \x12;\n\x11shape_with_layout\x18\x02\x20\x01(\x0b2\x0f.xla.ShapeProtoR\
    \x0fshapeWithLayout\"G\n\x18TransferToClientResponse\x12+\n\x07literal\
    \x18\x01\x20\x01(\x0b2\x11.xla.LiteralProtoR\x07literal\"~\n\x17Transfer\
    ToServerRequest\x12+\n\x07literal\x18\x01\x20\x01(\x0b2\x11.xla.LiteralP\
    rotoR\x07literal\x126\n\rdevice_handle\x18\x02\x20\x01(\x0b2\x11.xla.Dev\
    iceHandleR\x0cdeviceHandle\"E\n\x18TransferToServerResponse\x12)\n\x04da\
    ta\x18\x01\x20\x01(\x0b2\x15.xla.GlobalDataHandleR\x04data\"\x9d\x01\n\
    \x17TransferToInfeedRequest\x12+\n\x07literal\x18\x01\x20\x01(\x0b2\x11.\
    xla.LiteralProtoR\x07literal\x12\x1d\n\nreplica_id\x18\x02\x20\x01(\x03R\
    \treplicaId\x126\n\rdevice_handle\x18\x03\x20\x01(\x0b2\x11.xla.DeviceHa\
    ndleR\x0cdeviceHandle\"\x1a\n\x18TransferToInfeedResponse\"\xb0\x01\n\
    \x1aTransferFromOutfeedRequest\x12;\n\x11shape_with_layout\x18\x01\x20\
    \x01(\x0b2\x0f.xla.ShapeProtoR\x0fshapeWithLayout\x12\x1d\n\nreplica_id\
    \x18\x02\x20\x01(\x03R\treplicaId\x126\n\rdevice_handle\x18\x03\x20\x01(\
    \x0b2\x11.xla.DeviceHandleR\x0cdeviceHandle\"J\n\x1bTransferFromOutfeedR\
    esponse\x12+\n\x07literal\x18\x01\x20\x01(\x0b2\x11.xla.LiteralProtoR\
    \x07literal\"L\n\x12ResetDeviceRequest\x126\n\rdevice_handle\x18\x01\x20\
    \x01(\x0b2\x11.xla.DeviceHandleR\x0cdeviceHandle\"\x15\n\x13ResetDeviceR\
    esponse\"\x8d\x01\n\x1cComputationGraphStatsRequest\x125\n\x0bcomputatio\
    n\x18\x01\x20\x01(\x0b2\x13.xla.HloModuleProtoR\x0bcomputation\x126\n\rd\
    ebug_options\x18\x02\x20\x01(\x0b2\x11.xla.DebugOptionsR\x0cdebugOptions\
    \"G\n\x18ComputationStatsResponse\x12+\n\x05stats\x18\x01\x20\x01(\x0b2\
    \x15.xla.ComputationStatsR\x05stats\"_\n\x1aCreateChannelHandleRequest\
    \x12A\n\x0cchannel_type\x18\x01\x20\x01(\x0e2\x1e.xla.ChannelHandle.Chan\
    nelTypeR\x0bchannelType\"K\n\x1bCreateChannelHandleResponse\x12,\n\x07ch\
    annel\x18\x01\x20\x01(\x0b2\x12.xla.ChannelHandleR\x07channel\">\n\x11Un\
    registerRequest\x12)\n\x04data\x18\x01\x20\x03(\x0b2\x15.xla.GlobalDataH\
    andleR\x04data\"\x14\n\x12UnregisterResponse\"\xd3\x01\n\x0eCompileReque\
    st\x125\n\x0bcomputation\x18\x01\x20\x01(\x0b2\x13.xla.HloModuleProtoR\
    \x0bcomputation\x12B\n\x11execution_options\x18\x02\x20\x01(\x0b2\x15.xl\
    a.ExecutionOptionsR\x10executionOptions\x12F\n\x17input_shape_with_layou\
    t\x18\x03\x20\x03(\x0b2\x0f.xla.ShapeProtoR\x14inputShapeWithLayout\"?\n\
    \x0fCompileResponse\x12,\n\x06handle\x18\x01\x20\x01(\x0b2\x14.xla.Execu\
    tionHandleR\x06handle\"s\n\x0eExecuteRequest\x12,\n\x06handle\x18\x01\
    \x20\x01(\x0b2\x14.xla.ExecutionHandleR\x06handle\x123\n\targuments\x18\
    \x02\x20\x03(\x0b2\x15.xla.GlobalDataHandleR\targuments\"\xc5\x01\n\x13E\
    xecuteGraphRequest\x125\n\x0bcomputation\x18\x01\x20\x01(\x0b2\x13.xla.H\
    loModuleProtoR\x0bcomputation\x123\n\targuments\x18\x02\x20\x03(\x0b2\
    \x15.xla.GlobalDataHandleR\targuments\x12B\n\x11execution_options\x18\
    \x03\x20\x01(\x0b2\x15.xla.ExecutionOptionsR\x10executionOptions\"S\n\
    \x1bExecuteGraphParallelRequest\x124\n\x08requests\x18\x01\x20\x03(\x0b2\
    \x18.xla.ExecuteGraphRequestR\x08requests\"q\n\x0fExecuteResponse\x12-\n\
    \x06output\x18\x01\x20\x01(\x0b2\x15.xla.GlobalDataHandleR\x06output\x12\
    /\n\x07profile\x18\x02\x20\x01(\x0b2\x15.xla.ExecutionProfileR\x07profil\
    e\"M\n\x17ExecuteParallelResponse\x122\n\tresponses\x18\x01\x20\x03(\x0b\
    2\x14.xla.ExecuteResponseR\tresponses\"M\n\x17WaitForExecutionRequest\
    \x122\n\texecution\x18\x01\x20\x01(\x0b2\x14.xla.ExecutionHandleR\texecu\
    tion\"z\n\x18WaitForExecutionResponse\x12-\n\x06output\x18\x01\x20\x01(\
    \x0b2\x15.xla.GlobalDataHandleR\x06output\x12/\n\x07profile\x18\x02\x20\
    \x01(\x0b2\x15.xla.ExecutionProfileR\x07profile\"\x8b\x01\n\x1bComputeCo\
    nstantGraphRequest\x125\n\x0bcomputation\x18\x01\x20\x01(\x0b2\x13.xla.H\
    loModuleProtoR\x0bcomputation\x125\n\routput_layout\x18\x02\x20\x01(\x0b\
    2\x10.xla.LayoutProtoR\x0coutputLayout\"F\n\x17ComputeConstantResponse\
    \x12+\n\x07literal\x18\x01\x20\x01(\x0b2\x11.xla.LiteralProtoR\x07litera\
    l\"S\n\x17DeconstructTupleRequest\x128\n\x0ctuple_handle\x18\x02\x20\x01\
    (\x0b2\x15.xla.GlobalDataHandleR\x0btupleHandle\"Z\n\x18DeconstructTuple\
    Response\x12>\n\x0felement_handles\x18\x01\x20\x03(\x0b2\x15.xla.GlobalD\
    ataHandleR\x0eelementHandles\"\xe0\x01\n\x0fLoadDataRequest\x120\n\x14co\
    lumnio_tablet_path\x18\x01\x20\x01(\tR\x12columnioTabletPath\x12%\n\x0ec\
    olumnio_field\x18\x02\x20\x01(\tR\rcolumnioField\x124\n\relement_shape\
    \x18\x03\x20\x01(\x0b2\x0f.xla.ShapeProtoR\x0celementShape\x12\x16\n\x06\
    offset\x18\x04\x20\x01(\x03R\x06offset\x12\x14\n\x05limit\x18\x05\x20\
    \x01(\x03R\x05limit\x12\x10\n\x03zip\x18\x06\x20\x01(\x08R\x03zip\"\xd7\
    \x01\n\x10LoadDataResponse\x12)\n\x04data\x18\x01\x20\x01(\x0b2\x15.xla.\
    GlobalDataHandleR\x04data\x12.\n\ndata_shape\x18\x02\x20\x01(\x0b2\x0f.x\
    la.ShapeProtoR\tdataShape\x12%\n\x0eavailable_rows\x18\x03\x20\x01(\x03R\
    \ravailableRows\x12\x1f\n\x0brows_loaded\x18\x04\x20\x01(\x03R\nrowsLoad\
    ed\x12\x20\n\x0bnanoseconds\x18\x05\x20\x01(\x03R\x0bnanoseconds\"<\n\
    \x0fGetShapeRequest\x12)\n\x04data\x18\x01\x20\x01(\x0b2\x15.xla.GlobalD\
    ataHandleR\x04data\"9\n\x10GetShapeResponse\x12%\n\x05shape\x18\x01\x20\
    \x01(\x0b2\x0f.xla.ShapeProtoR\x05shape\":\n\rUnpackRequest\x12)\n\x04da\
    ta\x18\x01\x20\x01(\x0b2\x15.xla.GlobalDataHandleR\x04data\"D\n\x0eUnpac\
    kResponse\x122\n\ttied_data\x18\x01\x20\x03(\x0b2\x15.xla.GlobalDataHand\
    leR\x08tiedDatab\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
