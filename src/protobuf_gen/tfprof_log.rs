// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/profiler/tfprof_log.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct CodeDef {
    // message fields
    pub traces: ::protobuf::RepeatedField<CodeDef_Trace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CodeDef {
    fn default() -> &'a CodeDef {
        <CodeDef as ::protobuf::Message>::default_instance()
    }
}

impl CodeDef {
    pub fn new() -> CodeDef {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.tfprof.CodeDef.Trace traces = 1;


    pub fn get_traces(&self) -> &[CodeDef_Trace] {
        &self.traces
    }
    pub fn clear_traces(&mut self) {
        self.traces.clear();
    }

    // Param is passed by value, moved
    pub fn set_traces(&mut self, v: ::protobuf::RepeatedField<CodeDef_Trace>) {
        self.traces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_traces(&mut self) -> &mut ::protobuf::RepeatedField<CodeDef_Trace> {
        &mut self.traces
    }

    // Take field
    pub fn take_traces(&mut self) -> ::protobuf::RepeatedField<CodeDef_Trace> {
        ::std::mem::replace(&mut self.traces, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CodeDef {
    fn is_initialized(&self) -> bool {
        for v in &self.traces {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.traces)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.traces {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.traces {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeDef {
        CodeDef::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeDef_Trace>>(
                "traces",
                |m: &CodeDef| { &m.traces },
                |m: &mut CodeDef| { &mut m.traces },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CodeDef>(
                "CodeDef",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CodeDef {
        static instance: ::protobuf::rt::LazyV2<CodeDef> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CodeDef::new)
    }
}

impl ::protobuf::Clear for CodeDef {
    fn clear(&mut self) {
        self.traces.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeDef {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeDef {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CodeDef_Trace {
    // message fields
    pub file: ::std::string::String,
    pub file_id: i64,
    pub lineno: i32,
    pub function: ::std::string::String,
    pub function_id: i64,
    pub line: ::std::string::String,
    pub line_id: i64,
    pub func_start_line: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CodeDef_Trace {
    fn default() -> &'a CodeDef_Trace {
        <CodeDef_Trace as ::protobuf::Message>::default_instance()
    }
}

impl CodeDef_Trace {
    pub fn new() -> CodeDef_Trace {
        ::std::default::Default::default()
    }

    // string file = 1;


    pub fn get_file(&self) -> &str {
        &self.file
    }
    pub fn clear_file(&mut self) {
        self.file.clear();
    }

    // Param is passed by value, moved
    pub fn set_file(&mut self, v: ::std::string::String) {
        self.file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_file(&mut self) -> &mut ::std::string::String {
        &mut self.file
    }

    // Take field
    pub fn take_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.file, ::std::string::String::new())
    }

    // int64 file_id = 6;


    pub fn get_file_id(&self) -> i64 {
        self.file_id
    }
    pub fn clear_file_id(&mut self) {
        self.file_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_file_id(&mut self, v: i64) {
        self.file_id = v;
    }

    // int32 lineno = 2;


    pub fn get_lineno(&self) -> i32 {
        self.lineno
    }
    pub fn clear_lineno(&mut self) {
        self.lineno = 0;
    }

    // Param is passed by value, moved
    pub fn set_lineno(&mut self, v: i32) {
        self.lineno = v;
    }

    // string function = 3;


    pub fn get_function(&self) -> &str {
        &self.function
    }
    pub fn clear_function(&mut self) {
        self.function.clear();
    }

    // Param is passed by value, moved
    pub fn set_function(&mut self, v: ::std::string::String) {
        self.function = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_function(&mut self) -> &mut ::std::string::String {
        &mut self.function
    }

    // Take field
    pub fn take_function(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.function, ::std::string::String::new())
    }

    // int64 function_id = 7;


    pub fn get_function_id(&self) -> i64 {
        self.function_id
    }
    pub fn clear_function_id(&mut self) {
        self.function_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_function_id(&mut self, v: i64) {
        self.function_id = v;
    }

    // string line = 4;


    pub fn get_line(&self) -> &str {
        &self.line
    }
    pub fn clear_line(&mut self) {
        self.line.clear();
    }

    // Param is passed by value, moved
    pub fn set_line(&mut self, v: ::std::string::String) {
        self.line = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_line(&mut self) -> &mut ::std::string::String {
        &mut self.line
    }

    // Take field
    pub fn take_line(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.line, ::std::string::String::new())
    }

    // int64 line_id = 8;


    pub fn get_line_id(&self) -> i64 {
        self.line_id
    }
    pub fn clear_line_id(&mut self) {
        self.line_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_line_id(&mut self, v: i64) {
        self.line_id = v;
    }

    // int32 func_start_line = 5;


    pub fn get_func_start_line(&self) -> i32 {
        self.func_start_line
    }
    pub fn clear_func_start_line(&mut self) {
        self.func_start_line = 0;
    }

    // Param is passed by value, moved
    pub fn set_func_start_line(&mut self, v: i32) {
        self.func_start_line = v;
    }
}

impl ::protobuf::Message for CodeDef_Trace {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.file)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.file_id = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lineno = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.function)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.function_id = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.line)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.line_id = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.func_start_line = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.file.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.file);
        }
        if self.file_id != 0 {
            my_size += ::protobuf::rt::value_size(6, self.file_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lineno != 0 {
            my_size += ::protobuf::rt::value_size(2, self.lineno, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.function.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.function);
        }
        if self.function_id != 0 {
            my_size += ::protobuf::rt::value_size(7, self.function_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.line.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.line);
        }
        if self.line_id != 0 {
            my_size += ::protobuf::rt::value_size(8, self.line_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.func_start_line != 0 {
            my_size += ::protobuf::rt::value_size(5, self.func_start_line, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.file.is_empty() {
            os.write_string(1, &self.file)?;
        }
        if self.file_id != 0 {
            os.write_int64(6, self.file_id)?;
        }
        if self.lineno != 0 {
            os.write_int32(2, self.lineno)?;
        }
        if !self.function.is_empty() {
            os.write_string(3, &self.function)?;
        }
        if self.function_id != 0 {
            os.write_int64(7, self.function_id)?;
        }
        if !self.line.is_empty() {
            os.write_string(4, &self.line)?;
        }
        if self.line_id != 0 {
            os.write_int64(8, self.line_id)?;
        }
        if self.func_start_line != 0 {
            os.write_int32(5, self.func_start_line)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CodeDef_Trace {
        CodeDef_Trace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "file",
                |m: &CodeDef_Trace| { &m.file },
                |m: &mut CodeDef_Trace| { &mut m.file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "file_id",
                |m: &CodeDef_Trace| { &m.file_id },
                |m: &mut CodeDef_Trace| { &mut m.file_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lineno",
                |m: &CodeDef_Trace| { &m.lineno },
                |m: &mut CodeDef_Trace| { &mut m.lineno },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "function",
                |m: &CodeDef_Trace| { &m.function },
                |m: &mut CodeDef_Trace| { &mut m.function },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "function_id",
                |m: &CodeDef_Trace| { &m.function_id },
                |m: &mut CodeDef_Trace| { &mut m.function_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "line",
                |m: &CodeDef_Trace| { &m.line },
                |m: &mut CodeDef_Trace| { &mut m.line },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "line_id",
                |m: &CodeDef_Trace| { &m.line_id },
                |m: &mut CodeDef_Trace| { &mut m.line_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "func_start_line",
                |m: &CodeDef_Trace| { &m.func_start_line },
                |m: &mut CodeDef_Trace| { &mut m.func_start_line },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CodeDef_Trace>(
                "CodeDef.Trace",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CodeDef_Trace {
        static instance: ::protobuf::rt::LazyV2<CodeDef_Trace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CodeDef_Trace::new)
    }
}

impl ::protobuf::Clear for CodeDef_Trace {
    fn clear(&mut self) {
        self.file.clear();
        self.file_id = 0;
        self.lineno = 0;
        self.function.clear();
        self.function_id = 0;
        self.line.clear();
        self.line_id = 0;
        self.func_start_line = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CodeDef_Trace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CodeDef_Trace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpLogEntry {
    // message fields
    pub name: ::std::string::String,
    pub float_ops: i64,
    pub types: ::protobuf::RepeatedField<::std::string::String>,
    pub code_def: ::protobuf::SingularPtrField<CodeDef>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpLogEntry {
    fn default() -> &'a OpLogEntry {
        <OpLogEntry as ::protobuf::Message>::default_instance()
    }
}

impl OpLogEntry {
    pub fn new() -> OpLogEntry {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int64 float_ops = 2;


    pub fn get_float_ops(&self) -> i64 {
        self.float_ops
    }
    pub fn clear_float_ops(&mut self) {
        self.float_ops = 0;
    }

    // Param is passed by value, moved
    pub fn set_float_ops(&mut self, v: i64) {
        self.float_ops = v;
    }

    // repeated string types = 3;


    pub fn get_types(&self) -> &[::std::string::String] {
        &self.types
    }
    pub fn clear_types(&mut self) {
        self.types.clear();
    }

    // Param is passed by value, moved
    pub fn set_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.types
    }

    // Take field
    pub fn take_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.types, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.tfprof.CodeDef code_def = 4;


    pub fn get_code_def(&self) -> &CodeDef {
        self.code_def.as_ref().unwrap_or_else(|| <CodeDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_code_def(&mut self) {
        self.code_def.clear();
    }

    pub fn has_code_def(&self) -> bool {
        self.code_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code_def(&mut self, v: CodeDef) {
        self.code_def = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code_def(&mut self) -> &mut CodeDef {
        if self.code_def.is_none() {
            self.code_def.set_default();
        }
        self.code_def.as_mut().unwrap()
    }

    // Take field
    pub fn take_code_def(&mut self) -> CodeDef {
        self.code_def.take().unwrap_or_else(|| CodeDef::new())
    }
}

impl ::protobuf::Message for OpLogEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.code_def {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.float_ops = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.types)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.code_def)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.float_ops != 0 {
            my_size += ::protobuf::rt::value_size(2, self.float_ops, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.types {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.code_def.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.float_ops != 0 {
            os.write_int64(2, self.float_ops)?;
        }
        for v in &self.types {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.code_def.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpLogEntry {
        OpLogEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OpLogEntry| { &m.name },
                |m: &mut OpLogEntry| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "float_ops",
                |m: &OpLogEntry| { &m.float_ops },
                |m: &mut OpLogEntry| { &mut m.float_ops },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "types",
                |m: &OpLogEntry| { &m.types },
                |m: &mut OpLogEntry| { &mut m.types },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeDef>>(
                "code_def",
                |m: &OpLogEntry| { &m.code_def },
                |m: &mut OpLogEntry| { &mut m.code_def },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpLogEntry>(
                "OpLogEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpLogEntry {
        static instance: ::protobuf::rt::LazyV2<OpLogEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpLogEntry::new)
    }
}

impl ::protobuf::Clear for OpLogEntry {
    fn clear(&mut self) {
        self.name.clear();
        self.float_ops = 0;
        self.types.clear();
        self.code_def.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpLogEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpLogEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpLogProto {
    // message fields
    pub log_entries: ::protobuf::RepeatedField<OpLogEntry>,
    pub id_to_string: ::std::collections::HashMap<i64, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpLogProto {
    fn default() -> &'a OpLogProto {
        <OpLogProto as ::protobuf::Message>::default_instance()
    }
}

impl OpLogProto {
    pub fn new() -> OpLogProto {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.tfprof.OpLogEntry log_entries = 1;


    pub fn get_log_entries(&self) -> &[OpLogEntry] {
        &self.log_entries
    }
    pub fn clear_log_entries(&mut self) {
        self.log_entries.clear();
    }

    // Param is passed by value, moved
    pub fn set_log_entries(&mut self, v: ::protobuf::RepeatedField<OpLogEntry>) {
        self.log_entries = v;
    }

    // Mutable pointer to the field.
    pub fn mut_log_entries(&mut self) -> &mut ::protobuf::RepeatedField<OpLogEntry> {
        &mut self.log_entries
    }

    // Take field
    pub fn take_log_entries(&mut self) -> ::protobuf::RepeatedField<OpLogEntry> {
        ::std::mem::replace(&mut self.log_entries, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.tfprof.OpLogProto.IdToStringEntry id_to_string = 2;


    pub fn get_id_to_string(&self) -> &::std::collections::HashMap<i64, ::std::string::String> {
        &self.id_to_string
    }
    pub fn clear_id_to_string(&mut self) {
        self.id_to_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_to_string(&mut self, v: ::std::collections::HashMap<i64, ::std::string::String>) {
        self.id_to_string = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id_to_string(&mut self) -> &mut ::std::collections::HashMap<i64, ::std::string::String> {
        &mut self.id_to_string
    }

    // Take field
    pub fn take_id_to_string(&mut self) -> ::std::collections::HashMap<i64, ::std::string::String> {
        ::std::mem::replace(&mut self.id_to_string, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for OpLogProto {
    fn is_initialized(&self) -> bool {
        for v in &self.log_entries {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.log_entries)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.id_to_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.log_entries {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(2, &self.id_to_string);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.log_entries {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(2, &self.id_to_string, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpLogProto {
        OpLogProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpLogEntry>>(
                "log_entries",
                |m: &OpLogProto| { &m.log_entries },
                |m: &mut OpLogProto| { &mut m.log_entries },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(
                "id_to_string",
                |m: &OpLogProto| { &m.id_to_string },
                |m: &mut OpLogProto| { &mut m.id_to_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpLogProto>(
                "OpLogProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpLogProto {
        static instance: ::protobuf::rt::LazyV2<OpLogProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpLogProto::new)
    }
}

impl ::protobuf::Clear for OpLogProto {
    fn clear(&mut self) {
        self.log_entries.clear();
        self.id_to_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpLogProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpLogProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProfileProto {
    // message fields
    pub nodes: ::std::collections::HashMap<i64, ProfileNode>,
    pub has_trace: bool,
    pub miss_accelerator_stream: bool,
    pub steps: ::std::vec::Vec<i64>,
    pub id_to_string: ::std::collections::HashMap<i64, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfileProto {
    fn default() -> &'a ProfileProto {
        <ProfileProto as ::protobuf::Message>::default_instance()
    }
}

impl ProfileProto {
    pub fn new() -> ProfileProto {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.tfprof.ProfileProto.NodesEntry nodes = 1;


    pub fn get_nodes(&self) -> &::std::collections::HashMap<i64, ProfileNode> {
        &self.nodes
    }
    pub fn clear_nodes(&mut self) {
        self.nodes.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodes(&mut self, v: ::std::collections::HashMap<i64, ProfileNode>) {
        self.nodes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodes(&mut self) -> &mut ::std::collections::HashMap<i64, ProfileNode> {
        &mut self.nodes
    }

    // Take field
    pub fn take_nodes(&mut self) -> ::std::collections::HashMap<i64, ProfileNode> {
        ::std::mem::replace(&mut self.nodes, ::std::collections::HashMap::new())
    }

    // bool has_trace = 2;


    pub fn get_has_trace(&self) -> bool {
        self.has_trace
    }
    pub fn clear_has_trace(&mut self) {
        self.has_trace = false;
    }

    // Param is passed by value, moved
    pub fn set_has_trace(&mut self, v: bool) {
        self.has_trace = v;
    }

    // bool miss_accelerator_stream = 5;


    pub fn get_miss_accelerator_stream(&self) -> bool {
        self.miss_accelerator_stream
    }
    pub fn clear_miss_accelerator_stream(&mut self) {
        self.miss_accelerator_stream = false;
    }

    // Param is passed by value, moved
    pub fn set_miss_accelerator_stream(&mut self, v: bool) {
        self.miss_accelerator_stream = v;
    }

    // repeated int64 steps = 3;


    pub fn get_steps(&self) -> &[i64] {
        &self.steps
    }
    pub fn clear_steps(&mut self) {
        self.steps.clear();
    }

    // Param is passed by value, moved
    pub fn set_steps(&mut self, v: ::std::vec::Vec<i64>) {
        self.steps = v;
    }

    // Mutable pointer to the field.
    pub fn mut_steps(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.steps
    }

    // Take field
    pub fn take_steps(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.steps, ::std::vec::Vec::new())
    }

    // repeated .tensorflow.tfprof.ProfileProto.IdToStringEntry id_to_string = 4;


    pub fn get_id_to_string(&self) -> &::std::collections::HashMap<i64, ::std::string::String> {
        &self.id_to_string
    }
    pub fn clear_id_to_string(&mut self) {
        self.id_to_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_id_to_string(&mut self, v: ::std::collections::HashMap<i64, ::std::string::String>) {
        self.id_to_string = v;
    }

    // Mutable pointer to the field.
    pub fn mut_id_to_string(&mut self) -> &mut ::std::collections::HashMap<i64, ::std::string::String> {
        &mut self.id_to_string
    }

    // Take field
    pub fn take_id_to_string(&mut self) -> ::std::collections::HashMap<i64, ::std::string::String> {
        ::std::mem::replace(&mut self.id_to_string, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ProfileProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ProfileNode>>(wire_type, is, &mut self.nodes)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_trace = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.miss_accelerator_stream = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.steps)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.id_to_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ProfileNode>>(1, &self.nodes);
        if self.has_trace != false {
            my_size += 2;
        }
        if self.miss_accelerator_stream != false {
            my_size += 2;
        }
        for value in &self.steps {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(4, &self.id_to_string);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ProfileNode>>(1, &self.nodes, os)?;
        if self.has_trace != false {
            os.write_bool(2, self.has_trace)?;
        }
        if self.miss_accelerator_stream != false {
            os.write_bool(5, self.miss_accelerator_stream)?;
        }
        for v in &self.steps {
            os.write_int64(3, *v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(4, &self.id_to_string, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfileProto {
        ProfileProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ProfileNode>>(
                "nodes",
                |m: &ProfileProto| { &m.nodes },
                |m: &mut ProfileProto| { &mut m.nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_trace",
                |m: &ProfileProto| { &m.has_trace },
                |m: &mut ProfileProto| { &mut m.has_trace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "miss_accelerator_stream",
                |m: &ProfileProto| { &m.miss_accelerator_stream },
                |m: &mut ProfileProto| { &mut m.miss_accelerator_stream },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "steps",
                |m: &ProfileProto| { &m.steps },
                |m: &mut ProfileProto| { &mut m.steps },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeString>(
                "id_to_string",
                |m: &ProfileProto| { &m.id_to_string },
                |m: &mut ProfileProto| { &mut m.id_to_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfileProto>(
                "ProfileProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfileProto {
        static instance: ::protobuf::rt::LazyV2<ProfileProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfileProto::new)
    }
}

impl ::protobuf::Clear for ProfileProto {
    fn clear(&mut self) {
        self.nodes.clear();
        self.has_trace = false;
        self.miss_accelerator_stream = false;
        self.steps.clear();
        self.id_to_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfileProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProfileNode {
    // message fields
    pub name: ::std::string::String,
    pub op: ::std::string::String,
    pub id: i64,
    pub inputs: ::std::collections::HashMap<i32, i64>,
    pub input_shapes: ::std::collections::HashMap<i32, Tuple>,
    pub outputs: ::std::collections::HashMap<i32, i64>,
    pub output_shapes: ::std::collections::HashMap<i32, Tuple>,
    pub src_output_index: ::std::collections::HashMap<i64, i32>,
    pub shape: ::std::vec::Vec<i64>,
    pub op_types: ::protobuf::RepeatedField<::std::string::String>,
    pub canonical_device: ::std::string::String,
    pub host_device: ::std::string::String,
    pub float_ops: i64,
    pub trace: ::protobuf::SingularPtrField<CodeDef>,
    pub attrs: ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue>,
    pub execs: ::std::collections::HashMap<i64, ExecProfile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProfileNode {
    fn default() -> &'a ProfileNode {
        <ProfileNode as ::protobuf::Message>::default_instance()
    }
}

impl ProfileNode {
    pub fn new() -> ProfileNode {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string op = 9;


    pub fn get_op(&self) -> &str {
        &self.op
    }
    pub fn clear_op(&mut self) {
        self.op.clear();
    }

    // Param is passed by value, moved
    pub fn set_op(&mut self, v: ::std::string::String) {
        self.op = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op(&mut self) -> &mut ::std::string::String {
        &mut self.op
    }

    // Take field
    pub fn take_op(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op, ::std::string::String::new())
    }

    // int64 id = 13;


    pub fn get_id(&self) -> i64 {
        self.id
    }
    pub fn clear_id(&mut self) {
        self.id = 0;
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: i64) {
        self.id = v;
    }

    // repeated .tensorflow.tfprof.ProfileNode.InputsEntry inputs = 2;


    pub fn get_inputs(&self) -> &::std::collections::HashMap<i32, i64> {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::std::collections::HashMap<i32, i64>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::std::collections::HashMap<i32, i64> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::std::collections::HashMap<i32, i64> {
        ::std::mem::replace(&mut self.inputs, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.tfprof.ProfileNode.InputShapesEntry input_shapes = 16;


    pub fn get_input_shapes(&self) -> &::std::collections::HashMap<i32, Tuple> {
        &self.input_shapes
    }
    pub fn clear_input_shapes(&mut self) {
        self.input_shapes.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_shapes(&mut self, v: ::std::collections::HashMap<i32, Tuple>) {
        self.input_shapes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_shapes(&mut self) -> &mut ::std::collections::HashMap<i32, Tuple> {
        &mut self.input_shapes
    }

    // Take field
    pub fn take_input_shapes(&mut self) -> ::std::collections::HashMap<i32, Tuple> {
        ::std::mem::replace(&mut self.input_shapes, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.tfprof.ProfileNode.OutputsEntry outputs = 3;


    pub fn get_outputs(&self) -> &::std::collections::HashMap<i32, i64> {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::std::collections::HashMap<i32, i64>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::std::collections::HashMap<i32, i64> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::std::collections::HashMap<i32, i64> {
        ::std::mem::replace(&mut self.outputs, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.tfprof.ProfileNode.OutputShapesEntry output_shapes = 15;


    pub fn get_output_shapes(&self) -> &::std::collections::HashMap<i32, Tuple> {
        &self.output_shapes
    }
    pub fn clear_output_shapes(&mut self) {
        self.output_shapes.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_shapes(&mut self, v: ::std::collections::HashMap<i32, Tuple>) {
        self.output_shapes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_shapes(&mut self) -> &mut ::std::collections::HashMap<i32, Tuple> {
        &mut self.output_shapes
    }

    // Take field
    pub fn take_output_shapes(&mut self) -> ::std::collections::HashMap<i32, Tuple> {
        ::std::mem::replace(&mut self.output_shapes, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.tfprof.ProfileNode.SrcOutputIndexEntry src_output_index = 14;


    pub fn get_src_output_index(&self) -> &::std::collections::HashMap<i64, i32> {
        &self.src_output_index
    }
    pub fn clear_src_output_index(&mut self) {
        self.src_output_index.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_output_index(&mut self, v: ::std::collections::HashMap<i64, i32>) {
        self.src_output_index = v;
    }

    // Mutable pointer to the field.
    pub fn mut_src_output_index(&mut self) -> &mut ::std::collections::HashMap<i64, i32> {
        &mut self.src_output_index
    }

    // Take field
    pub fn take_src_output_index(&mut self) -> ::std::collections::HashMap<i64, i32> {
        ::std::mem::replace(&mut self.src_output_index, ::std::collections::HashMap::new())
    }

    // repeated int64 shape = 4;


    pub fn get_shape(&self) -> &[i64] {
        &self.shape
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: ::std::vec::Vec<i64>) {
        self.shape = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shape(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.shape
    }

    // Take field
    pub fn take_shape(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.shape, ::std::vec::Vec::new())
    }

    // repeated string op_types = 5;


    pub fn get_op_types(&self) -> &[::std::string::String] {
        &self.op_types
    }
    pub fn clear_op_types(&mut self) {
        self.op_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.op_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_op_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.op_types
    }

    // Take field
    pub fn take_op_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.op_types, ::protobuf::RepeatedField::new())
    }

    // string canonical_device = 6;


    pub fn get_canonical_device(&self) -> &str {
        &self.canonical_device
    }
    pub fn clear_canonical_device(&mut self) {
        self.canonical_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_canonical_device(&mut self, v: ::std::string::String) {
        self.canonical_device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_canonical_device(&mut self) -> &mut ::std::string::String {
        &mut self.canonical_device
    }

    // Take field
    pub fn take_canonical_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.canonical_device, ::std::string::String::new())
    }

    // string host_device = 7;


    pub fn get_host_device(&self) -> &str {
        &self.host_device
    }
    pub fn clear_host_device(&mut self) {
        self.host_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_host_device(&mut self, v: ::std::string::String) {
        self.host_device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host_device(&mut self) -> &mut ::std::string::String {
        &mut self.host_device
    }

    // Take field
    pub fn take_host_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.host_device, ::std::string::String::new())
    }

    // int64 float_ops = 8;


    pub fn get_float_ops(&self) -> i64 {
        self.float_ops
    }
    pub fn clear_float_ops(&mut self) {
        self.float_ops = 0;
    }

    // Param is passed by value, moved
    pub fn set_float_ops(&mut self, v: i64) {
        self.float_ops = v;
    }

    // .tensorflow.tfprof.CodeDef trace = 10;


    pub fn get_trace(&self) -> &CodeDef {
        self.trace.as_ref().unwrap_or_else(|| <CodeDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_trace(&mut self) {
        self.trace.clear();
    }

    pub fn has_trace(&self) -> bool {
        self.trace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace(&mut self, v: CodeDef) {
        self.trace = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trace(&mut self) -> &mut CodeDef {
        if self.trace.is_none() {
            self.trace.set_default();
        }
        self.trace.as_mut().unwrap()
    }

    // Take field
    pub fn take_trace(&mut self) -> CodeDef {
        self.trace.take().unwrap_or_else(|| CodeDef::new())
    }

    // repeated .tensorflow.tfprof.ProfileNode.AttrsEntry attrs = 11;


    pub fn get_attrs(&self) -> &::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        &self.attrs
    }
    pub fn clear_attrs(&mut self) {
        self.attrs.clear();
    }

    // Param is passed by value, moved
    pub fn set_attrs(&mut self, v: ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue>) {
        self.attrs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_attrs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        &mut self.attrs
    }

    // Take field
    pub fn take_attrs(&mut self) -> ::std::collections::HashMap<::std::string::String, super::attr_value::AttrValue> {
        ::std::mem::replace(&mut self.attrs, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.tfprof.ProfileNode.ExecsEntry execs = 12;


    pub fn get_execs(&self) -> &::std::collections::HashMap<i64, ExecProfile> {
        &self.execs
    }
    pub fn clear_execs(&mut self) {
        self.execs.clear();
    }

    // Param is passed by value, moved
    pub fn set_execs(&mut self, v: ::std::collections::HashMap<i64, ExecProfile>) {
        self.execs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_execs(&mut self) -> &mut ::std::collections::HashMap<i64, ExecProfile> {
        &mut self.execs
    }

    // Take field
    pub fn take_execs(&mut self) -> ::std::collections::HashMap<i64, ExecProfile> {
        ::std::mem::replace(&mut self.execs, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ProfileNode {
    fn is_initialized(&self) -> bool {
        for v in &self.trace {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.inputs)?;
                },
                16 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(wire_type, is, &mut self.input_shapes)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(wire_type, is, &mut self.outputs)?;
                },
                15 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(wire_type, is, &mut self.output_shapes)?;
                },
                14 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(wire_type, is, &mut self.src_output_index)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.shape)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.op_types)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.canonical_device)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.host_device)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.float_ops = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.trace)?;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(wire_type, is, &mut self.attrs)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ExecProfile>>(wire_type, is, &mut self.execs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.op.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.op);
        }
        if self.id != 0 {
            my_size += ::protobuf::rt::value_size(13, self.id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(2, &self.inputs);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(16, &self.input_shapes);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(3, &self.outputs);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(15, &self.output_shapes);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(14, &self.src_output_index);
        for value in &self.shape {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.op_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if !self.canonical_device.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.canonical_device);
        }
        if !self.host_device.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.host_device);
        }
        if self.float_ops != 0 {
            my_size += ::protobuf::rt::value_size(8, self.float_ops, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.trace.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(11, &self.attrs);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ExecProfile>>(12, &self.execs);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.op.is_empty() {
            os.write_string(9, &self.op)?;
        }
        if self.id != 0 {
            os.write_int64(13, self.id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(2, &self.inputs, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(16, &self.input_shapes, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(3, &self.outputs, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(15, &self.output_shapes, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(14, &self.src_output_index, os)?;
        for v in &self.shape {
            os.write_int64(4, *v)?;
        };
        for v in &self.op_types {
            os.write_string(5, &v)?;
        };
        if !self.canonical_device.is_empty() {
            os.write_string(6, &self.canonical_device)?;
        }
        if !self.host_device.is_empty() {
            os.write_string(7, &self.host_device)?;
        }
        if self.float_ops != 0 {
            os.write_int64(8, self.float_ops)?;
        }
        if let Some(ref v) = self.trace.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(11, &self.attrs, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ExecProfile>>(12, &self.execs, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProfileNode {
        ProfileNode::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ProfileNode| { &m.name },
                |m: &mut ProfileNode| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op",
                |m: &ProfileNode| { &m.op },
                |m: &mut ProfileNode| { &mut m.op },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "id",
                |m: &ProfileNode| { &m.id },
                |m: &mut ProfileNode| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(
                "inputs",
                |m: &ProfileNode| { &m.inputs },
                |m: &mut ProfileNode| { &mut m.inputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(
                "input_shapes",
                |m: &ProfileNode| { &m.input_shapes },
                |m: &mut ProfileNode| { &mut m.input_shapes },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeInt64>(
                "outputs",
                |m: &ProfileNode| { &m.outputs },
                |m: &mut ProfileNode| { &mut m.outputs },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Tuple>>(
                "output_shapes",
                |m: &ProfileNode| { &m.output_shapes },
                |m: &mut ProfileNode| { &mut m.output_shapes },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeInt32>(
                "src_output_index",
                |m: &ProfileNode| { &m.src_output_index },
                |m: &mut ProfileNode| { &mut m.src_output_index },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "shape",
                |m: &ProfileNode| { &m.shape },
                |m: &mut ProfileNode| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op_types",
                |m: &ProfileNode| { &m.op_types },
                |m: &mut ProfileNode| { &mut m.op_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "canonical_device",
                |m: &ProfileNode| { &m.canonical_device },
                |m: &mut ProfileNode| { &mut m.canonical_device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host_device",
                |m: &ProfileNode| { &m.host_device },
                |m: &mut ProfileNode| { &mut m.host_device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "float_ops",
                |m: &ProfileNode| { &m.float_ops },
                |m: &mut ProfileNode| { &mut m.float_ops },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CodeDef>>(
                "trace",
                |m: &ProfileNode| { &m.trace },
                |m: &mut ProfileNode| { &mut m.trace },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::attr_value::AttrValue>>(
                "attrs",
                |m: &ProfileNode| { &m.attrs },
                |m: &mut ProfileNode| { &mut m.attrs },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt64, ::protobuf::types::ProtobufTypeMessage<ExecProfile>>(
                "execs",
                |m: &ProfileNode| { &m.execs },
                |m: &mut ProfileNode| { &mut m.execs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProfileNode>(
                "ProfileNode",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProfileNode {
        static instance: ::protobuf::rt::LazyV2<ProfileNode> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProfileNode::new)
    }
}

impl ::protobuf::Clear for ProfileNode {
    fn clear(&mut self) {
        self.name.clear();
        self.op.clear();
        self.id = 0;
        self.inputs.clear();
        self.input_shapes.clear();
        self.outputs.clear();
        self.output_shapes.clear();
        self.src_output_index.clear();
        self.shape.clear();
        self.op_types.clear();
        self.canonical_device.clear();
        self.host_device.clear();
        self.float_ops = 0;
        self.trace.clear();
        self.attrs.clear();
        self.execs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProfileNode {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProfileNode {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecProfile {
    // message fields
    pub run_count: i64,
    pub all_start_micros: i64,
    pub latest_end_micros: i64,
    pub accelerator_execs: ::std::collections::HashMap<::std::string::String, ExecTime>,
    pub cpu_execs: ::std::collections::HashMap<::std::string::String, ExecTime>,
    pub memory_execs: ::protobuf::RepeatedField<ExecMemory>,
    pub allocations: ::protobuf::RepeatedField<super::step_stats::AllocationRecord>,
    pub devices: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecProfile {
    fn default() -> &'a ExecProfile {
        <ExecProfile as ::protobuf::Message>::default_instance()
    }
}

impl ExecProfile {
    pub fn new() -> ExecProfile {
        ::std::default::Default::default()
    }

    // int64 run_count = 1;


    pub fn get_run_count(&self) -> i64 {
        self.run_count
    }
    pub fn clear_run_count(&mut self) {
        self.run_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_run_count(&mut self, v: i64) {
        self.run_count = v;
    }

    // int64 all_start_micros = 2;


    pub fn get_all_start_micros(&self) -> i64 {
        self.all_start_micros
    }
    pub fn clear_all_start_micros(&mut self) {
        self.all_start_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_all_start_micros(&mut self, v: i64) {
        self.all_start_micros = v;
    }

    // int64 latest_end_micros = 3;


    pub fn get_latest_end_micros(&self) -> i64 {
        self.latest_end_micros
    }
    pub fn clear_latest_end_micros(&mut self) {
        self.latest_end_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_latest_end_micros(&mut self, v: i64) {
        self.latest_end_micros = v;
    }

    // repeated .tensorflow.tfprof.ExecProfile.AcceleratorExecsEntry accelerator_execs = 4;


    pub fn get_accelerator_execs(&self) -> &::std::collections::HashMap<::std::string::String, ExecTime> {
        &self.accelerator_execs
    }
    pub fn clear_accelerator_execs(&mut self) {
        self.accelerator_execs.clear();
    }

    // Param is passed by value, moved
    pub fn set_accelerator_execs(&mut self, v: ::std::collections::HashMap<::std::string::String, ExecTime>) {
        self.accelerator_execs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accelerator_execs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ExecTime> {
        &mut self.accelerator_execs
    }

    // Take field
    pub fn take_accelerator_execs(&mut self) -> ::std::collections::HashMap<::std::string::String, ExecTime> {
        ::std::mem::replace(&mut self.accelerator_execs, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.tfprof.ExecProfile.CpuExecsEntry cpu_execs = 5;


    pub fn get_cpu_execs(&self) -> &::std::collections::HashMap<::std::string::String, ExecTime> {
        &self.cpu_execs
    }
    pub fn clear_cpu_execs(&mut self) {
        self.cpu_execs.clear();
    }

    // Param is passed by value, moved
    pub fn set_cpu_execs(&mut self, v: ::std::collections::HashMap<::std::string::String, ExecTime>) {
        self.cpu_execs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cpu_execs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ExecTime> {
        &mut self.cpu_execs
    }

    // Take field
    pub fn take_cpu_execs(&mut self) -> ::std::collections::HashMap<::std::string::String, ExecTime> {
        ::std::mem::replace(&mut self.cpu_execs, ::std::collections::HashMap::new())
    }

    // repeated .tensorflow.tfprof.ExecMemory memory_execs = 7;


    pub fn get_memory_execs(&self) -> &[ExecMemory] {
        &self.memory_execs
    }
    pub fn clear_memory_execs(&mut self) {
        self.memory_execs.clear();
    }

    // Param is passed by value, moved
    pub fn set_memory_execs(&mut self, v: ::protobuf::RepeatedField<ExecMemory>) {
        self.memory_execs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_memory_execs(&mut self) -> &mut ::protobuf::RepeatedField<ExecMemory> {
        &mut self.memory_execs
    }

    // Take field
    pub fn take_memory_execs(&mut self) -> ::protobuf::RepeatedField<ExecMemory> {
        ::std::mem::replace(&mut self.memory_execs, ::protobuf::RepeatedField::new())
    }

    // repeated .tensorflow.AllocationRecord allocations = 11;


    pub fn get_allocations(&self) -> &[super::step_stats::AllocationRecord] {
        &self.allocations
    }
    pub fn clear_allocations(&mut self) {
        self.allocations.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocations(&mut self, v: ::protobuf::RepeatedField<super::step_stats::AllocationRecord>) {
        self.allocations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocations(&mut self) -> &mut ::protobuf::RepeatedField<super::step_stats::AllocationRecord> {
        &mut self.allocations
    }

    // Take field
    pub fn take_allocations(&mut self) -> ::protobuf::RepeatedField<super::step_stats::AllocationRecord> {
        ::std::mem::replace(&mut self.allocations, ::protobuf::RepeatedField::new())
    }

    // repeated string devices = 6;


    pub fn get_devices(&self) -> &[::std::string::String] {
        &self.devices
    }
    pub fn clear_devices(&mut self) {
        self.devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_devices(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_devices(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.devices
    }

    // Take field
    pub fn take_devices(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.devices, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecProfile {
    fn is_initialized(&self) -> bool {
        for v in &self.memory_execs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allocations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.run_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.all_start_micros = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.latest_end_micros = tmp;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(wire_type, is, &mut self.accelerator_execs)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(wire_type, is, &mut self.cpu_execs)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.memory_execs)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allocations)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.devices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.run_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.run_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.all_start_micros != 0 {
            my_size += ::protobuf::rt::value_size(2, self.all_start_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.latest_end_micros != 0 {
            my_size += ::protobuf::rt::value_size(3, self.latest_end_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(4, &self.accelerator_execs);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(5, &self.cpu_execs);
        for value in &self.memory_execs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.allocations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.devices {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.run_count != 0 {
            os.write_int64(1, self.run_count)?;
        }
        if self.all_start_micros != 0 {
            os.write_int64(2, self.all_start_micros)?;
        }
        if self.latest_end_micros != 0 {
            os.write_int64(3, self.latest_end_micros)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(4, &self.accelerator_execs, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(5, &self.cpu_execs, os)?;
        for v in &self.memory_execs {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.allocations {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.devices {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecProfile {
        ExecProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "run_count",
                |m: &ExecProfile| { &m.run_count },
                |m: &mut ExecProfile| { &mut m.run_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "all_start_micros",
                |m: &ExecProfile| { &m.all_start_micros },
                |m: &mut ExecProfile| { &mut m.all_start_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "latest_end_micros",
                |m: &ExecProfile| { &m.latest_end_micros },
                |m: &mut ExecProfile| { &mut m.latest_end_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(
                "accelerator_execs",
                |m: &ExecProfile| { &m.accelerator_execs },
                |m: &mut ExecProfile| { &mut m.accelerator_execs },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<ExecTime>>(
                "cpu_execs",
                |m: &ExecProfile| { &m.cpu_execs },
                |m: &mut ExecProfile| { &mut m.cpu_execs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecMemory>>(
                "memory_execs",
                |m: &ExecProfile| { &m.memory_execs },
                |m: &mut ExecProfile| { &mut m.memory_execs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::step_stats::AllocationRecord>>(
                "allocations",
                |m: &ExecProfile| { &m.allocations },
                |m: &mut ExecProfile| { &mut m.allocations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "devices",
                |m: &ExecProfile| { &m.devices },
                |m: &mut ExecProfile| { &mut m.devices },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecProfile>(
                "ExecProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecProfile {
        static instance: ::protobuf::rt::LazyV2<ExecProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecProfile::new)
    }
}

impl ::protobuf::Clear for ExecProfile {
    fn clear(&mut self) {
        self.run_count = 0;
        self.all_start_micros = 0;
        self.latest_end_micros = 0;
        self.accelerator_execs.clear();
        self.cpu_execs.clear();
        self.memory_execs.clear();
        self.allocations.clear();
        self.devices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecTime {
    // message fields
    pub times: ::protobuf::RepeatedField<Tuple>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecTime {
    fn default() -> &'a ExecTime {
        <ExecTime as ::protobuf::Message>::default_instance()
    }
}

impl ExecTime {
    pub fn new() -> ExecTime {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.tfprof.Tuple times = 1;


    pub fn get_times(&self) -> &[Tuple] {
        &self.times
    }
    pub fn clear_times(&mut self) {
        self.times.clear();
    }

    // Param is passed by value, moved
    pub fn set_times(&mut self, v: ::protobuf::RepeatedField<Tuple>) {
        self.times = v;
    }

    // Mutable pointer to the field.
    pub fn mut_times(&mut self) -> &mut ::protobuf::RepeatedField<Tuple> {
        &mut self.times
    }

    // Take field
    pub fn take_times(&mut self) -> ::protobuf::RepeatedField<Tuple> {
        ::std::mem::replace(&mut self.times, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecTime {
    fn is_initialized(&self) -> bool {
        for v in &self.times {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.times)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.times {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.times {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecTime {
        ExecTime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tuple>>(
                "times",
                |m: &ExecTime| { &m.times },
                |m: &mut ExecTime| { &mut m.times },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecTime>(
                "ExecTime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecTime {
        static instance: ::protobuf::rt::LazyV2<ExecTime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecTime::new)
    }
}

impl ::protobuf::Clear for ExecTime {
    fn clear(&mut self) {
        self.times.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecTime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecMemory {
    // message fields
    pub memory_micros: i64,
    pub host_temp_bytes: i64,
    pub host_persistent_bytes: i64,
    pub accelerator_temp_bytes: i64,
    pub accelerator_persistent_bytes: i64,
    pub requested_bytes: i64,
    pub peak_bytes: i64,
    pub residual_bytes: i64,
    pub output_bytes: i64,
    pub allocator_bytes_in_use: i64,
    pub output_memory: ::std::collections::HashMap<i32, Memory>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecMemory {
    fn default() -> &'a ExecMemory {
        <ExecMemory as ::protobuf::Message>::default_instance()
    }
}

impl ExecMemory {
    pub fn new() -> ExecMemory {
        ::std::default::Default::default()
    }

    // int64 memory_micros = 1;


    pub fn get_memory_micros(&self) -> i64 {
        self.memory_micros
    }
    pub fn clear_memory_micros(&mut self) {
        self.memory_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory_micros(&mut self, v: i64) {
        self.memory_micros = v;
    }

    // int64 host_temp_bytes = 2;


    pub fn get_host_temp_bytes(&self) -> i64 {
        self.host_temp_bytes
    }
    pub fn clear_host_temp_bytes(&mut self) {
        self.host_temp_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_host_temp_bytes(&mut self, v: i64) {
        self.host_temp_bytes = v;
    }

    // int64 host_persistent_bytes = 3;


    pub fn get_host_persistent_bytes(&self) -> i64 {
        self.host_persistent_bytes
    }
    pub fn clear_host_persistent_bytes(&mut self) {
        self.host_persistent_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_host_persistent_bytes(&mut self, v: i64) {
        self.host_persistent_bytes = v;
    }

    // int64 accelerator_temp_bytes = 4;


    pub fn get_accelerator_temp_bytes(&self) -> i64 {
        self.accelerator_temp_bytes
    }
    pub fn clear_accelerator_temp_bytes(&mut self) {
        self.accelerator_temp_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_accelerator_temp_bytes(&mut self, v: i64) {
        self.accelerator_temp_bytes = v;
    }

    // int64 accelerator_persistent_bytes = 5;


    pub fn get_accelerator_persistent_bytes(&self) -> i64 {
        self.accelerator_persistent_bytes
    }
    pub fn clear_accelerator_persistent_bytes(&mut self) {
        self.accelerator_persistent_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_accelerator_persistent_bytes(&mut self, v: i64) {
        self.accelerator_persistent_bytes = v;
    }

    // int64 requested_bytes = 6;


    pub fn get_requested_bytes(&self) -> i64 {
        self.requested_bytes
    }
    pub fn clear_requested_bytes(&mut self) {
        self.requested_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_requested_bytes(&mut self, v: i64) {
        self.requested_bytes = v;
    }

    // int64 peak_bytes = 7;


    pub fn get_peak_bytes(&self) -> i64 {
        self.peak_bytes
    }
    pub fn clear_peak_bytes(&mut self) {
        self.peak_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_peak_bytes(&mut self, v: i64) {
        self.peak_bytes = v;
    }

    // int64 residual_bytes = 8;


    pub fn get_residual_bytes(&self) -> i64 {
        self.residual_bytes
    }
    pub fn clear_residual_bytes(&mut self) {
        self.residual_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_residual_bytes(&mut self, v: i64) {
        self.residual_bytes = v;
    }

    // int64 output_bytes = 9;


    pub fn get_output_bytes(&self) -> i64 {
        self.output_bytes
    }
    pub fn clear_output_bytes(&mut self) {
        self.output_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_bytes(&mut self, v: i64) {
        self.output_bytes = v;
    }

    // int64 allocator_bytes_in_use = 10;


    pub fn get_allocator_bytes_in_use(&self) -> i64 {
        self.allocator_bytes_in_use
    }
    pub fn clear_allocator_bytes_in_use(&mut self) {
        self.allocator_bytes_in_use = 0;
    }

    // Param is passed by value, moved
    pub fn set_allocator_bytes_in_use(&mut self, v: i64) {
        self.allocator_bytes_in_use = v;
    }

    // repeated .tensorflow.tfprof.ExecMemory.OutputMemoryEntry output_memory = 11;


    pub fn get_output_memory(&self) -> &::std::collections::HashMap<i32, Memory> {
        &self.output_memory
    }
    pub fn clear_output_memory(&mut self) {
        self.output_memory.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_memory(&mut self, v: ::std::collections::HashMap<i32, Memory>) {
        self.output_memory = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_memory(&mut self) -> &mut ::std::collections::HashMap<i32, Memory> {
        &mut self.output_memory
    }

    // Take field
    pub fn take_output_memory(&mut self) -> ::std::collections::HashMap<i32, Memory> {
        ::std::mem::replace(&mut self.output_memory, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ExecMemory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory_micros = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.host_temp_bytes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.host_persistent_bytes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.accelerator_temp_bytes = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.accelerator_persistent_bytes = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.requested_bytes = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.peak_bytes = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.residual_bytes = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.output_bytes = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.allocator_bytes_in_use = tmp;
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Memory>>(wire_type, is, &mut self.output_memory)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.memory_micros != 0 {
            my_size += ::protobuf::rt::value_size(1, self.memory_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.host_temp_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.host_temp_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.host_persistent_bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.host_persistent_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accelerator_temp_bytes != 0 {
            my_size += ::protobuf::rt::value_size(4, self.accelerator_temp_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accelerator_persistent_bytes != 0 {
            my_size += ::protobuf::rt::value_size(5, self.accelerator_persistent_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.requested_bytes != 0 {
            my_size += ::protobuf::rt::value_size(6, self.requested_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.peak_bytes != 0 {
            my_size += ::protobuf::rt::value_size(7, self.peak_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.residual_bytes != 0 {
            my_size += ::protobuf::rt::value_size(8, self.residual_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output_bytes != 0 {
            my_size += ::protobuf::rt::value_size(9, self.output_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.allocator_bytes_in_use != 0 {
            my_size += ::protobuf::rt::value_size(10, self.allocator_bytes_in_use, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Memory>>(11, &self.output_memory);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.memory_micros != 0 {
            os.write_int64(1, self.memory_micros)?;
        }
        if self.host_temp_bytes != 0 {
            os.write_int64(2, self.host_temp_bytes)?;
        }
        if self.host_persistent_bytes != 0 {
            os.write_int64(3, self.host_persistent_bytes)?;
        }
        if self.accelerator_temp_bytes != 0 {
            os.write_int64(4, self.accelerator_temp_bytes)?;
        }
        if self.accelerator_persistent_bytes != 0 {
            os.write_int64(5, self.accelerator_persistent_bytes)?;
        }
        if self.requested_bytes != 0 {
            os.write_int64(6, self.requested_bytes)?;
        }
        if self.peak_bytes != 0 {
            os.write_int64(7, self.peak_bytes)?;
        }
        if self.residual_bytes != 0 {
            os.write_int64(8, self.residual_bytes)?;
        }
        if self.output_bytes != 0 {
            os.write_int64(9, self.output_bytes)?;
        }
        if self.allocator_bytes_in_use != 0 {
            os.write_int64(10, self.allocator_bytes_in_use)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Memory>>(11, &self.output_memory, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecMemory {
        ExecMemory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "memory_micros",
                |m: &ExecMemory| { &m.memory_micros },
                |m: &mut ExecMemory| { &mut m.memory_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "host_temp_bytes",
                |m: &ExecMemory| { &m.host_temp_bytes },
                |m: &mut ExecMemory| { &mut m.host_temp_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "host_persistent_bytes",
                |m: &ExecMemory| { &m.host_persistent_bytes },
                |m: &mut ExecMemory| { &mut m.host_persistent_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "accelerator_temp_bytes",
                |m: &ExecMemory| { &m.accelerator_temp_bytes },
                |m: &mut ExecMemory| { &mut m.accelerator_temp_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "accelerator_persistent_bytes",
                |m: &ExecMemory| { &m.accelerator_persistent_bytes },
                |m: &mut ExecMemory| { &mut m.accelerator_persistent_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "requested_bytes",
                |m: &ExecMemory| { &m.requested_bytes },
                |m: &mut ExecMemory| { &mut m.requested_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "peak_bytes",
                |m: &ExecMemory| { &m.peak_bytes },
                |m: &mut ExecMemory| { &mut m.peak_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "residual_bytes",
                |m: &ExecMemory| { &m.residual_bytes },
                |m: &mut ExecMemory| { &mut m.residual_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "output_bytes",
                |m: &ExecMemory| { &m.output_bytes },
                |m: &mut ExecMemory| { &mut m.output_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "allocator_bytes_in_use",
                |m: &ExecMemory| { &m.allocator_bytes_in_use },
                |m: &mut ExecMemory| { &mut m.allocator_bytes_in_use },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeInt32, ::protobuf::types::ProtobufTypeMessage<Memory>>(
                "output_memory",
                |m: &ExecMemory| { &m.output_memory },
                |m: &mut ExecMemory| { &mut m.output_memory },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecMemory>(
                "ExecMemory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecMemory {
        static instance: ::protobuf::rt::LazyV2<ExecMemory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecMemory::new)
    }
}

impl ::protobuf::Clear for ExecMemory {
    fn clear(&mut self) {
        self.memory_micros = 0;
        self.host_temp_bytes = 0;
        self.host_persistent_bytes = 0;
        self.accelerator_temp_bytes = 0;
        self.accelerator_persistent_bytes = 0;
        self.requested_bytes = 0;
        self.peak_bytes = 0;
        self.residual_bytes = 0;
        self.output_bytes = 0;
        self.allocator_bytes_in_use = 0;
        self.output_memory.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecMemory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecMemory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tuple {
    // message fields
    pub int64_values: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tuple {
    fn default() -> &'a Tuple {
        <Tuple as ::protobuf::Message>::default_instance()
    }
}

impl Tuple {
    pub fn new() -> Tuple {
        ::std::default::Default::default()
    }

    // repeated int64 int64_values = 1;


    pub fn get_int64_values(&self) -> &[i64] {
        &self.int64_values
    }
    pub fn clear_int64_values(&mut self) {
        self.int64_values.clear();
    }

    // Param is passed by value, moved
    pub fn set_int64_values(&mut self, v: ::std::vec::Vec<i64>) {
        self.int64_values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_int64_values(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.int64_values
    }

    // Take field
    pub fn take_int64_values(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.int64_values, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Tuple {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.int64_values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.int64_values {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.int64_values {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tuple {
        Tuple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "int64_values",
                |m: &Tuple| { &m.int64_values },
                |m: &mut Tuple| { &mut m.int64_values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tuple>(
                "Tuple",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tuple {
        static instance: ::protobuf::rt::LazyV2<Tuple> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tuple::new)
    }
}

impl ::protobuf::Clear for Tuple {
    fn clear(&mut self) {
        self.int64_values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tuple {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Memory {
    // message fields
    pub bytes: i64,
    pub ptr: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Memory {
    fn default() -> &'a Memory {
        <Memory as ::protobuf::Message>::default_instance()
    }
}

impl Memory {
    pub fn new() -> Memory {
        ::std::default::Default::default()
    }

    // int64 bytes = 1;


    pub fn get_bytes(&self) -> i64 {
        self.bytes
    }
    pub fn clear_bytes(&mut self) {
        self.bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_bytes(&mut self, v: i64) {
        self.bytes = v;
    }

    // uint64 ptr = 2;


    pub fn get_ptr(&self) -> u64 {
        self.ptr
    }
    pub fn clear_ptr(&mut self) {
        self.ptr = 0;
    }

    // Param is passed by value, moved
    pub fn set_ptr(&mut self, v: u64) {
        self.ptr = v;
    }
}

impl ::protobuf::Message for Memory {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.bytes = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.ptr = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.bytes != 0 {
            my_size += ::protobuf::rt::value_size(1, self.bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ptr != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ptr, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.bytes != 0 {
            os.write_int64(1, self.bytes)?;
        }
        if self.ptr != 0 {
            os.write_uint64(2, self.ptr)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Memory {
        Memory::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "bytes",
                |m: &Memory| { &m.bytes },
                |m: &mut Memory| { &mut m.bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "ptr",
                |m: &Memory| { &m.ptr },
                |m: &mut Memory| { &mut m.ptr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Memory>(
                "Memory",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Memory {
        static instance: ::protobuf::rt::LazyV2<Memory> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Memory::new)
    }
}

impl ::protobuf::Clear for Memory {
    fn clear(&mut self) {
        self.bytes = 0;
        self.ptr = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Memory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Memory {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)tensorflow/core/profiler/tfprof_log.proto\x12\x11tensorflow.tfprof\
    \x1a*tensorflow/core/framework/attr_value.proto\x1a*tensorflow/core/fram\
    ework/step_stats.proto\"\xb0\x02\n\x07CodeDef\x128\n\x06traces\x18\x01\
    \x20\x03(\x0b2\x20.tensorflow.tfprof.CodeDef.TraceR\x06traces\x1a\xea\
    \x01\n\x05Trace\x12\x16\n\x04file\x18\x01\x20\x01(\tR\x04fileB\x02\x18\
    \x01\x12\x17\n\x07file_id\x18\x06\x20\x01(\x03R\x06fileId\x12\x16\n\x06l\
    ineno\x18\x02\x20\x01(\x05R\x06lineno\x12\x1e\n\x08function\x18\x03\x20\
    \x01(\tR\x08functionB\x02\x18\x01\x12\x1f\n\x0bfunction_id\x18\x07\x20\
    \x01(\x03R\nfunctionId\x12\x16\n\x04line\x18\x04\x20\x01(\tR\x04lineB\
    \x02\x18\x01\x12\x17\n\x07line_id\x18\x08\x20\x01(\x03R\x06lineId\x12&\n\
    \x0ffunc_start_line\x18\x05\x20\x01(\x05R\rfuncStartLine\"\x8a\x01\n\nOp\
    LogEntry\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1b\n\tfloat_\
    ops\x18\x02\x20\x01(\x03R\x08floatOps\x12\x14\n\x05types\x18\x03\x20\x03\
    (\tR\x05types\x125\n\x08code_def\x18\x04\x20\x01(\x0b2\x1a.tensorflow.tf\
    prof.CodeDefR\x07codeDef\"\xdc\x01\n\nOpLogProto\x12>\n\x0blog_entries\
    \x18\x01\x20\x03(\x0b2\x1d.tensorflow.tfprof.OpLogEntryR\nlogEntries\x12\
    O\n\x0cid_to_string\x18\x02\x20\x03(\x0b2-.tensorflow.tfprof.OpLogProto.\
    IdToStringEntryR\nidToString\x1a=\n\x0fIdToStringEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05\
    value:\x028\x01\"\xa7\x03\n\x0cProfileProto\x12@\n\x05nodes\x18\x01\x20\
    \x03(\x0b2*.tensorflow.tfprof.ProfileProto.NodesEntryR\x05nodes\x12\x1b\
    \n\thas_trace\x18\x02\x20\x01(\x08R\x08hasTrace\x126\n\x17miss_accelerat\
    or_stream\x18\x05\x20\x01(\x08R\x15missAcceleratorStream\x12\x14\n\x05st\
    eps\x18\x03\x20\x03(\x03R\x05steps\x12Q\n\x0cid_to_string\x18\x04\x20\
    \x03(\x0b2/.tensorflow.tfprof.ProfileProto.IdToStringEntryR\nidToString\
    \x1aX\n\nNodesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03key\x124\n\
    \x05value\x18\x02\x20\x01(\x0b2\x1e.tensorflow.tfprof.ProfileNodeR\x05va\
    lue:\x028\x01\x1a=\n\x0fIdToStringEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\
    \"\xbd\n\n\x0bProfileNode\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x0e\n\x02op\x18\t\x20\x01(\tR\x02op\x12\x0e\n\x02id\x18\r\x20\x01(\
    \x03R\x02id\x12B\n\x06inputs\x18\x02\x20\x03(\x0b2*.tensorflow.tfprof.Pr\
    ofileNode.InputsEntryR\x06inputs\x12R\n\x0cinput_shapes\x18\x10\x20\x03(\
    \x0b2/.tensorflow.tfprof.ProfileNode.InputShapesEntryR\x0binputShapes\
    \x12E\n\x07outputs\x18\x03\x20\x03(\x0b2+.tensorflow.tfprof.ProfileNode.\
    OutputsEntryR\x07outputs\x12U\n\routput_shapes\x18\x0f\x20\x03(\x0b20.te\
    nsorflow.tfprof.ProfileNode.OutputShapesEntryR\x0coutputShapes\x12\\\n\
    \x10src_output_index\x18\x0e\x20\x03(\x0b22.tensorflow.tfprof.ProfileNod\
    e.SrcOutputIndexEntryR\x0esrcOutputIndex\x12\x14\n\x05shape\x18\x04\x20\
    \x03(\x03R\x05shape\x12\x19\n\x08op_types\x18\x05\x20\x03(\tR\x07opTypes\
    \x12)\n\x10canonical_device\x18\x06\x20\x01(\tR\x0fcanonicalDevice\x12\
    \x1f\n\x0bhost_device\x18\x07\x20\x01(\tR\nhostDevice\x12\x1b\n\tfloat_o\
    ps\x18\x08\x20\x01(\x03R\x08floatOps\x120\n\x05trace\x18\n\x20\x01(\x0b2\
    \x1a.tensorflow.tfprof.CodeDefR\x05trace\x12?\n\x05attrs\x18\x0b\x20\x03\
    (\x0b2).tensorflow.tfprof.ProfileNode.AttrsEntryR\x05attrs\x12?\n\x05exe\
    cs\x18\x0c\x20\x03(\x0b2).tensorflow.tfprof.ProfileNode.ExecsEntryR\x05e\
    xecs\x1a9\n\x0bInputsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1aX\n\x10I\
    nputShapesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x12.\n\x05\
    value\x18\x02\x20\x01(\x0b2\x18.tensorflow.tfprof.TupleR\x05value:\x028\
    \x01\x1a:\n\x0cOutputsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\x03R\x05value:\x028\x01\x1aY\n\x11\
    OutputShapesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x05R\x03key\x12.\n\
    \x05value\x18\x02\x20\x01(\x0b2\x18.tensorflow.tfprof.TupleR\x05value:\
    \x028\x01\x1aA\n\x13SrcOutputIndexEntry\x12\x10\n\x03key\x18\x01\x20\x01\
    (\x03R\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x05R\x05value:\x028\
    \x01\x1aO\n\nAttrsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12+\
    \n\x05value\x18\x02\x20\x01(\x0b2\x15.tensorflow.AttrValueR\x05value:\
    \x028\x01\x1aX\n\nExecsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\x03R\x03k\
    ey\x124\n\x05value\x18\x02\x20\x01(\x0b2\x1e.tensorflow.tfprof.ExecProfi\
    leR\x05value:\x028\x01\"\x86\x05\n\x0bExecProfile\x12\x1b\n\trun_count\
    \x18\x01\x20\x01(\x03R\x08runCount\x12(\n\x10all_start_micros\x18\x02\
    \x20\x01(\x03R\x0eallStartMicros\x12*\n\x11latest_end_micros\x18\x03\x20\
    \x01(\x03R\x0flatestEndMicros\x12a\n\x11accelerator_execs\x18\x04\x20\
    \x03(\x0b24.tensorflow.tfprof.ExecProfile.AcceleratorExecsEntryR\x10acce\
    leratorExecs\x12I\n\tcpu_execs\x18\x05\x20\x03(\x0b2,.tensorflow.tfprof.\
    ExecProfile.CpuExecsEntryR\x08cpuExecs\x12@\n\x0cmemory_execs\x18\x07\
    \x20\x03(\x0b2\x1d.tensorflow.tfprof.ExecMemoryR\x0bmemoryExecs\x12>\n\
    \x0ballocations\x18\x0b\x20\x03(\x0b2\x1c.tensorflow.AllocationRecordR\
    \x0ballocations\x12\x18\n\x07devices\x18\x06\x20\x03(\tR\x07devices\x1a`\
    \n\x15AcceleratorExecsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x121\n\x05value\x18\x02\x20\x01(\x0b2\x1b.tensorflow.tfprof.ExecTimeR\
    \x05value:\x028\x01\x1aX\n\rCpuExecsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x121\n\x05value\x18\x02\x20\x01(\x0b2\x1b.tensorflow.tfp\
    rof.ExecTimeR\x05value:\x028\x01\":\n\x08ExecTime\x12.\n\x05times\x18\
    \x01\x20\x03(\x0b2\x18.tensorflow.tfprof.TupleR\x05times\"\xfe\x04\n\nEx\
    ecMemory\x12#\n\rmemory_micros\x18\x01\x20\x01(\x03R\x0cmemoryMicros\x12\
    &\n\x0fhost_temp_bytes\x18\x02\x20\x01(\x03R\rhostTempBytes\x122\n\x15ho\
    st_persistent_bytes\x18\x03\x20\x01(\x03R\x13hostPersistentBytes\x124\n\
    \x16accelerator_temp_bytes\x18\x04\x20\x01(\x03R\x14acceleratorTempBytes\
    \x12@\n\x1caccelerator_persistent_bytes\x18\x05\x20\x01(\x03R\x1aacceler\
    atorPersistentBytes\x12'\n\x0frequested_bytes\x18\x06\x20\x01(\x03R\x0er\
    equestedBytes\x12\x1d\n\npeak_bytes\x18\x07\x20\x01(\x03R\tpeakBytes\x12\
    %\n\x0eresidual_bytes\x18\x08\x20\x01(\x03R\rresidualBytes\x12!\n\x0cout\
    put_bytes\x18\t\x20\x01(\x03R\x0boutputBytes\x123\n\x16allocator_bytes_i\
    n_use\x18\n\x20\x01(\x03R\x13allocatorBytesInUse\x12T\n\routput_memory\
    \x18\x0b\x20\x03(\x0b2/.tensorflow.tfprof.ExecMemory.OutputMemoryEntryR\
    \x0coutputMemory\x1aZ\n\x11OutputMemoryEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x05R\x03key\x12/\n\x05value\x18\x02\x20\x01(\x0b2\x19.tensorfl\
    ow.tfprof.MemoryR\x05value:\x028\x01\"*\n\x05Tuple\x12!\n\x0cint64_value\
    s\x18\x01\x20\x03(\x03R\x0bint64Values\"0\n\x06Memory\x12\x14\n\x05bytes\
    \x18\x01\x20\x01(\x03R\x05bytes\x12\x10\n\x03ptr\x18\x02\x20\x01(\x04R\
    \x03ptrb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
