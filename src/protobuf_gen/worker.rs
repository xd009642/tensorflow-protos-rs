// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/protobuf/worker.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct GetStatusRequest {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStatusRequest {
    fn default() -> &'a GetStatusRequest {
        <GetStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusRequest {
    pub fn new() -> GetStatusRequest {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for GetStatusRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStatusRequest {
        GetStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStatusRequest>(
                "GetStatusRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStatusRequest {
        static instance: ::protobuf::rt::LazyV2<GetStatusRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStatusRequest::new)
    }
}

impl ::protobuf::Clear for GetStatusRequest {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStatusResponse {
    // message fields
    pub device_attributes: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStatusResponse {
    fn default() -> &'a GetStatusResponse {
        <GetStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetStatusResponse {
    pub fn new() -> GetStatusResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.DeviceAttributes device_attributes = 1;


    pub fn get_device_attributes(&self) -> &[super::device_attributes::DeviceAttributes] {
        &self.device_attributes
    }
    pub fn clear_device_attributes(&mut self) {
        self.device_attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_attributes(&mut self, v: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>) {
        self.device_attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_attributes(&mut self) -> &mut ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        &mut self.device_attributes
    }

    // Take field
    pub fn take_device_attributes(&mut self) -> ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        ::std::mem::replace(&mut self.device_attributes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.device_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.device_attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.device_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.device_attributes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStatusResponse {
        GetStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceAttributes>>(
                "device_attributes",
                |m: &GetStatusResponse| { &m.device_attributes },
                |m: &mut GetStatusResponse| { &mut m.device_attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStatusResponse>(
                "GetStatusResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStatusResponse {
        static instance: ::protobuf::rt::LazyV2<GetStatusResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStatusResponse::new)
    }
}

impl ::protobuf::Clear for GetStatusResponse {
    fn clear(&mut self) {
        self.device_attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateWorkerSessionRequest {
    // message fields
    pub session_handle: ::std::string::String,
    pub server_def: ::protobuf::SingularPtrField<super::tensorflow_server::ServerDef>,
    pub isolate_session_state: bool,
    pub cluster_device_attributes: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateWorkerSessionRequest {
    fn default() -> &'a CreateWorkerSessionRequest {
        <CreateWorkerSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateWorkerSessionRequest {
    pub fn new() -> CreateWorkerSessionRequest {
        ::std::default::Default::default()
    }

    // string session_handle = 1;


    pub fn get_session_handle(&self) -> &str {
        &self.session_handle
    }
    pub fn clear_session_handle(&mut self) {
        self.session_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_handle(&mut self, v: ::std::string::String) {
        self.session_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_handle(&mut self) -> &mut ::std::string::String {
        &mut self.session_handle
    }

    // Take field
    pub fn take_session_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_handle, ::std::string::String::new())
    }

    // .tensorflow.ServerDef server_def = 2;


    pub fn get_server_def(&self) -> &super::tensorflow_server::ServerDef {
        self.server_def.as_ref().unwrap_or_else(|| <super::tensorflow_server::ServerDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_def(&mut self) {
        self.server_def.clear();
    }

    pub fn has_server_def(&self) -> bool {
        self.server_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_def(&mut self, v: super::tensorflow_server::ServerDef) {
        self.server_def = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_def(&mut self) -> &mut super::tensorflow_server::ServerDef {
        if self.server_def.is_none() {
            self.server_def.set_default();
        }
        self.server_def.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_def(&mut self) -> super::tensorflow_server::ServerDef {
        self.server_def.take().unwrap_or_else(|| super::tensorflow_server::ServerDef::new())
    }

    // bool isolate_session_state = 3;


    pub fn get_isolate_session_state(&self) -> bool {
        self.isolate_session_state
    }
    pub fn clear_isolate_session_state(&mut self) {
        self.isolate_session_state = false;
    }

    // Param is passed by value, moved
    pub fn set_isolate_session_state(&mut self, v: bool) {
        self.isolate_session_state = v;
    }

    // repeated .tensorflow.DeviceAttributes cluster_device_attributes = 4;


    pub fn get_cluster_device_attributes(&self) -> &[super::device_attributes::DeviceAttributes] {
        &self.cluster_device_attributes
    }
    pub fn clear_cluster_device_attributes(&mut self) {
        self.cluster_device_attributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_device_attributes(&mut self, v: ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes>) {
        self.cluster_device_attributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_device_attributes(&mut self) -> &mut ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        &mut self.cluster_device_attributes
    }

    // Take field
    pub fn take_cluster_device_attributes(&mut self) -> ::protobuf::RepeatedField<super::device_attributes::DeviceAttributes> {
        ::std::mem::replace(&mut self.cluster_device_attributes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CreateWorkerSessionRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.server_def {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cluster_device_attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_handle)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_def)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isolate_session_state = tmp;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cluster_device_attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_handle);
        }
        if let Some(ref v) = self.server_def.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.isolate_session_state != false {
            my_size += 2;
        }
        for value in &self.cluster_device_attributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_handle.is_empty() {
            os.write_string(1, &self.session_handle)?;
        }
        if let Some(ref v) = self.server_def.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.isolate_session_state != false {
            os.write_bool(3, self.isolate_session_state)?;
        }
        for v in &self.cluster_device_attributes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateWorkerSessionRequest {
        CreateWorkerSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_handle",
                |m: &CreateWorkerSessionRequest| { &m.session_handle },
                |m: &mut CreateWorkerSessionRequest| { &mut m.session_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensorflow_server::ServerDef>>(
                "server_def",
                |m: &CreateWorkerSessionRequest| { &m.server_def },
                |m: &mut CreateWorkerSessionRequest| { &mut m.server_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isolate_session_state",
                |m: &CreateWorkerSessionRequest| { &m.isolate_session_state },
                |m: &mut CreateWorkerSessionRequest| { &mut m.isolate_session_state },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceAttributes>>(
                "cluster_device_attributes",
                |m: &CreateWorkerSessionRequest| { &m.cluster_device_attributes },
                |m: &mut CreateWorkerSessionRequest| { &mut m.cluster_device_attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateWorkerSessionRequest>(
                "CreateWorkerSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateWorkerSessionRequest {
        static instance: ::protobuf::rt::LazyV2<CreateWorkerSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateWorkerSessionRequest::new)
    }
}

impl ::protobuf::Clear for CreateWorkerSessionRequest {
    fn clear(&mut self) {
        self.session_handle.clear();
        self.server_def.clear();
        self.isolate_session_state = false;
        self.cluster_device_attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateWorkerSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateWorkerSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateWorkerSessionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateWorkerSessionResponse {
    fn default() -> &'a CreateWorkerSessionResponse {
        <CreateWorkerSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl CreateWorkerSessionResponse {
    pub fn new() -> CreateWorkerSessionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CreateWorkerSessionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateWorkerSessionResponse {
        CreateWorkerSessionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateWorkerSessionResponse>(
                "CreateWorkerSessionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateWorkerSessionResponse {
        static instance: ::protobuf::rt::LazyV2<CreateWorkerSessionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateWorkerSessionResponse::new)
    }
}

impl ::protobuf::Clear for CreateWorkerSessionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateWorkerSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateWorkerSessionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWorkerSessionRequest {
    // message fields
    pub session_handle: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWorkerSessionRequest {
    fn default() -> &'a DeleteWorkerSessionRequest {
        <DeleteWorkerSessionRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkerSessionRequest {
    pub fn new() -> DeleteWorkerSessionRequest {
        ::std::default::Default::default()
    }

    // string session_handle = 1;


    pub fn get_session_handle(&self) -> &str {
        &self.session_handle
    }
    pub fn clear_session_handle(&mut self) {
        self.session_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_handle(&mut self, v: ::std::string::String) {
        self.session_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_handle(&mut self) -> &mut ::std::string::String {
        &mut self.session_handle
    }

    // Take field
    pub fn take_session_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_handle, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteWorkerSessionRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_handle.is_empty() {
            os.write_string(1, &self.session_handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWorkerSessionRequest {
        DeleteWorkerSessionRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_handle",
                |m: &DeleteWorkerSessionRequest| { &m.session_handle },
                |m: &mut DeleteWorkerSessionRequest| { &mut m.session_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteWorkerSessionRequest>(
                "DeleteWorkerSessionRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteWorkerSessionRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteWorkerSessionRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteWorkerSessionRequest::new)
    }
}

impl ::protobuf::Clear for DeleteWorkerSessionRequest {
    fn clear(&mut self) {
        self.session_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWorkerSessionRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkerSessionRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteWorkerSessionResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteWorkerSessionResponse {
    fn default() -> &'a DeleteWorkerSessionResponse {
        <DeleteWorkerSessionResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeleteWorkerSessionResponse {
    pub fn new() -> DeleteWorkerSessionResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeleteWorkerSessionResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteWorkerSessionResponse {
        DeleteWorkerSessionResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteWorkerSessionResponse>(
                "DeleteWorkerSessionResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteWorkerSessionResponse {
        static instance: ::protobuf::rt::LazyV2<DeleteWorkerSessionResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteWorkerSessionResponse::new)
    }
}

impl ::protobuf::Clear for DeleteWorkerSessionResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteWorkerSessionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteWorkerSessionResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterGraphRequest {
    // message fields
    pub session_handle: ::std::string::String,
    pub create_worker_session_called: bool,
    pub graph_def: ::protobuf::SingularPtrField<super::graph::GraphDef>,
    pub has_control_flow: bool,
    pub graph_options: ::protobuf::SingularPtrField<super::config::GraphOptions>,
    pub debug_options: ::protobuf::SingularPtrField<super::debug::DebugOptions>,
    pub collective_graph_key: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterGraphRequest {
    fn default() -> &'a RegisterGraphRequest {
        <RegisterGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl RegisterGraphRequest {
    pub fn new() -> RegisterGraphRequest {
        ::std::default::Default::default()
    }

    // string session_handle = 1;


    pub fn get_session_handle(&self) -> &str {
        &self.session_handle
    }
    pub fn clear_session_handle(&mut self) {
        self.session_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_handle(&mut self, v: ::std::string::String) {
        self.session_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_handle(&mut self) -> &mut ::std::string::String {
        &mut self.session_handle
    }

    // Take field
    pub fn take_session_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_handle, ::std::string::String::new())
    }

    // bool create_worker_session_called = 6;


    pub fn get_create_worker_session_called(&self) -> bool {
        self.create_worker_session_called
    }
    pub fn clear_create_worker_session_called(&mut self) {
        self.create_worker_session_called = false;
    }

    // Param is passed by value, moved
    pub fn set_create_worker_session_called(&mut self, v: bool) {
        self.create_worker_session_called = v;
    }

    // .tensorflow.GraphDef graph_def = 2;


    pub fn get_graph_def(&self) -> &super::graph::GraphDef {
        self.graph_def.as_ref().unwrap_or_else(|| <super::graph::GraphDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_graph_def(&mut self) {
        self.graph_def.clear();
    }

    pub fn has_graph_def(&self) -> bool {
        self.graph_def.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graph_def(&mut self, v: super::graph::GraphDef) {
        self.graph_def = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_def(&mut self) -> &mut super::graph::GraphDef {
        if self.graph_def.is_none() {
            self.graph_def.set_default();
        }
        self.graph_def.as_mut().unwrap()
    }

    // Take field
    pub fn take_graph_def(&mut self) -> super::graph::GraphDef {
        self.graph_def.take().unwrap_or_else(|| super::graph::GraphDef::new())
    }

    // bool has_control_flow = 3;


    pub fn get_has_control_flow(&self) -> bool {
        self.has_control_flow
    }
    pub fn clear_has_control_flow(&mut self) {
        self.has_control_flow = false;
    }

    // Param is passed by value, moved
    pub fn set_has_control_flow(&mut self, v: bool) {
        self.has_control_flow = v;
    }

    // .tensorflow.GraphOptions graph_options = 4;


    pub fn get_graph_options(&self) -> &super::config::GraphOptions {
        self.graph_options.as_ref().unwrap_or_else(|| <super::config::GraphOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_graph_options(&mut self) {
        self.graph_options.clear();
    }

    pub fn has_graph_options(&self) -> bool {
        self.graph_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_graph_options(&mut self, v: super::config::GraphOptions) {
        self.graph_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_options(&mut self) -> &mut super::config::GraphOptions {
        if self.graph_options.is_none() {
            self.graph_options.set_default();
        }
        self.graph_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_graph_options(&mut self) -> super::config::GraphOptions {
        self.graph_options.take().unwrap_or_else(|| super::config::GraphOptions::new())
    }

    // .tensorflow.DebugOptions debug_options = 5;


    pub fn get_debug_options(&self) -> &super::debug::DebugOptions {
        self.debug_options.as_ref().unwrap_or_else(|| <super::debug::DebugOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_debug_options(&mut self) {
        self.debug_options.clear();
    }

    pub fn has_debug_options(&self) -> bool {
        self.debug_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_debug_options(&mut self, v: super::debug::DebugOptions) {
        self.debug_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_debug_options(&mut self) -> &mut super::debug::DebugOptions {
        if self.debug_options.is_none() {
            self.debug_options.set_default();
        }
        self.debug_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_debug_options(&mut self) -> super::debug::DebugOptions {
        self.debug_options.take().unwrap_or_else(|| super::debug::DebugOptions::new())
    }

    // int64 collective_graph_key = 7;


    pub fn get_collective_graph_key(&self) -> i64 {
        self.collective_graph_key
    }
    pub fn clear_collective_graph_key(&mut self) {
        self.collective_graph_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_collective_graph_key(&mut self, v: i64) {
        self.collective_graph_key = v;
    }
}

impl ::protobuf::Message for RegisterGraphRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.graph_def {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.graph_options {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.debug_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_handle)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.create_worker_session_called = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graph_def)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_control_flow = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.graph_options)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.debug_options)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.collective_graph_key = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.session_handle);
        }
        if self.create_worker_session_called != false {
            my_size += 2;
        }
        if let Some(ref v) = self.graph_def.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.has_control_flow != false {
            my_size += 2;
        }
        if let Some(ref v) = self.graph_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.collective_graph_key != 0 {
            my_size += ::protobuf::rt::value_size(7, self.collective_graph_key, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_handle.is_empty() {
            os.write_string(1, &self.session_handle)?;
        }
        if self.create_worker_session_called != false {
            os.write_bool(6, self.create_worker_session_called)?;
        }
        if let Some(ref v) = self.graph_def.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.has_control_flow != false {
            os.write_bool(3, self.has_control_flow)?;
        }
        if let Some(ref v) = self.graph_options.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.debug_options.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.collective_graph_key != 0 {
            os.write_int64(7, self.collective_graph_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterGraphRequest {
        RegisterGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_handle",
                |m: &RegisterGraphRequest| { &m.session_handle },
                |m: &mut RegisterGraphRequest| { &mut m.session_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "create_worker_session_called",
                |m: &RegisterGraphRequest| { &m.create_worker_session_called },
                |m: &mut RegisterGraphRequest| { &mut m.create_worker_session_called },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::graph::GraphDef>>(
                "graph_def",
                |m: &RegisterGraphRequest| { &m.graph_def },
                |m: &mut RegisterGraphRequest| { &mut m.graph_def },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "has_control_flow",
                |m: &RegisterGraphRequest| { &m.has_control_flow },
                |m: &mut RegisterGraphRequest| { &mut m.has_control_flow },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::config::GraphOptions>>(
                "graph_options",
                |m: &RegisterGraphRequest| { &m.graph_options },
                |m: &mut RegisterGraphRequest| { &mut m.graph_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::debug::DebugOptions>>(
                "debug_options",
                |m: &RegisterGraphRequest| { &m.debug_options },
                |m: &mut RegisterGraphRequest| { &mut m.debug_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "collective_graph_key",
                |m: &RegisterGraphRequest| { &m.collective_graph_key },
                |m: &mut RegisterGraphRequest| { &mut m.collective_graph_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterGraphRequest>(
                "RegisterGraphRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterGraphRequest {
        static instance: ::protobuf::rt::LazyV2<RegisterGraphRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterGraphRequest::new)
    }
}

impl ::protobuf::Clear for RegisterGraphRequest {
    fn clear(&mut self) {
        self.session_handle.clear();
        self.create_worker_session_called = false;
        self.graph_def.clear();
        self.has_control_flow = false;
        self.graph_options.clear();
        self.debug_options.clear();
        self.collective_graph_key = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RegisterGraphResponse {
    // message fields
    pub graph_handle: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RegisterGraphResponse {
    fn default() -> &'a RegisterGraphResponse {
        <RegisterGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl RegisterGraphResponse {
    pub fn new() -> RegisterGraphResponse {
        ::std::default::Default::default()
    }

    // string graph_handle = 1;


    pub fn get_graph_handle(&self) -> &str {
        &self.graph_handle
    }
    pub fn clear_graph_handle(&mut self) {
        self.graph_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_handle(&mut self, v: ::std::string::String) {
        self.graph_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_handle(&mut self) -> &mut ::std::string::String {
        &mut self.graph_handle
    }

    // Take field
    pub fn take_graph_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graph_handle, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RegisterGraphResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graph_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.graph_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph_handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.graph_handle.is_empty() {
            os.write_string(1, &self.graph_handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RegisterGraphResponse {
        RegisterGraphResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "graph_handle",
                |m: &RegisterGraphResponse| { &m.graph_handle },
                |m: &mut RegisterGraphResponse| { &mut m.graph_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RegisterGraphResponse>(
                "RegisterGraphResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RegisterGraphResponse {
        static instance: ::protobuf::rt::LazyV2<RegisterGraphResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RegisterGraphResponse::new)
    }
}

impl ::protobuf::Clear for RegisterGraphResponse {
    fn clear(&mut self) {
        self.graph_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RegisterGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RegisterGraphResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeregisterGraphRequest {
    // message fields
    pub session_handle: ::std::string::String,
    pub create_worker_session_called: bool,
    pub graph_handle: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeregisterGraphRequest {
    fn default() -> &'a DeregisterGraphRequest {
        <DeregisterGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeregisterGraphRequest {
    pub fn new() -> DeregisterGraphRequest {
        ::std::default::Default::default()
    }

    // string session_handle = 2;


    pub fn get_session_handle(&self) -> &str {
        &self.session_handle
    }
    pub fn clear_session_handle(&mut self) {
        self.session_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_handle(&mut self, v: ::std::string::String) {
        self.session_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_handle(&mut self) -> &mut ::std::string::String {
        &mut self.session_handle
    }

    // Take field
    pub fn take_session_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_handle, ::std::string::String::new())
    }

    // bool create_worker_session_called = 3;


    pub fn get_create_worker_session_called(&self) -> bool {
        self.create_worker_session_called
    }
    pub fn clear_create_worker_session_called(&mut self) {
        self.create_worker_session_called = false;
    }

    // Param is passed by value, moved
    pub fn set_create_worker_session_called(&mut self, v: bool) {
        self.create_worker_session_called = v;
    }

    // string graph_handle = 1;


    pub fn get_graph_handle(&self) -> &str {
        &self.graph_handle
    }
    pub fn clear_graph_handle(&mut self) {
        self.graph_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_handle(&mut self, v: ::std::string::String) {
        self.graph_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_handle(&mut self) -> &mut ::std::string::String {
        &mut self.graph_handle
    }

    // Take field
    pub fn take_graph_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graph_handle, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeregisterGraphRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_handle)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.create_worker_session_called = tmp;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graph_handle)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.session_handle);
        }
        if self.create_worker_session_called != false {
            my_size += 2;
        }
        if !self.graph_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph_handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_handle.is_empty() {
            os.write_string(2, &self.session_handle)?;
        }
        if self.create_worker_session_called != false {
            os.write_bool(3, self.create_worker_session_called)?;
        }
        if !self.graph_handle.is_empty() {
            os.write_string(1, &self.graph_handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeregisterGraphRequest {
        DeregisterGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_handle",
                |m: &DeregisterGraphRequest| { &m.session_handle },
                |m: &mut DeregisterGraphRequest| { &mut m.session_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "create_worker_session_called",
                |m: &DeregisterGraphRequest| { &m.create_worker_session_called },
                |m: &mut DeregisterGraphRequest| { &mut m.create_worker_session_called },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "graph_handle",
                |m: &DeregisterGraphRequest| { &m.graph_handle },
                |m: &mut DeregisterGraphRequest| { &mut m.graph_handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeregisterGraphRequest>(
                "DeregisterGraphRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeregisterGraphRequest {
        static instance: ::protobuf::rt::LazyV2<DeregisterGraphRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeregisterGraphRequest::new)
    }
}

impl ::protobuf::Clear for DeregisterGraphRequest {
    fn clear(&mut self) {
        self.session_handle.clear();
        self.create_worker_session_called = false;
        self.graph_handle.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeregisterGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeregisterGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeregisterGraphResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeregisterGraphResponse {
    fn default() -> &'a DeregisterGraphResponse {
        <DeregisterGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeregisterGraphResponse {
    pub fn new() -> DeregisterGraphResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for DeregisterGraphResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeregisterGraphResponse {
        DeregisterGraphResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeregisterGraphResponse>(
                "DeregisterGraphResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeregisterGraphResponse {
        static instance: ::protobuf::rt::LazyV2<DeregisterGraphResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeregisterGraphResponse::new)
    }
}

impl ::protobuf::Clear for DeregisterGraphResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeregisterGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeregisterGraphResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CleanupAllRequest {
    // message fields
    pub container: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CleanupAllRequest {
    fn default() -> &'a CleanupAllRequest {
        <CleanupAllRequest as ::protobuf::Message>::default_instance()
    }
}

impl CleanupAllRequest {
    pub fn new() -> CleanupAllRequest {
        ::std::default::Default::default()
    }

    // repeated string container = 1;


    pub fn get_container(&self) -> &[::std::string::String] {
        &self.container
    }
    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.container = v;
    }

    // Mutable pointer to the field.
    pub fn mut_container(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.container
    }

    // Take field
    pub fn take_container(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.container, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CleanupAllRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.container)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.container {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.container {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CleanupAllRequest {
        CleanupAllRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container",
                |m: &CleanupAllRequest| { &m.container },
                |m: &mut CleanupAllRequest| { &mut m.container },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CleanupAllRequest>(
                "CleanupAllRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CleanupAllRequest {
        static instance: ::protobuf::rt::LazyV2<CleanupAllRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CleanupAllRequest::new)
    }
}

impl ::protobuf::Clear for CleanupAllRequest {
    fn clear(&mut self) {
        self.container.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CleanupAllRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CleanupAllRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CleanupAllResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CleanupAllResponse {
    fn default() -> &'a CleanupAllResponse {
        <CleanupAllResponse as ::protobuf::Message>::default_instance()
    }
}

impl CleanupAllResponse {
    pub fn new() -> CleanupAllResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CleanupAllResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CleanupAllResponse {
        CleanupAllResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CleanupAllResponse>(
                "CleanupAllResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CleanupAllResponse {
        static instance: ::protobuf::rt::LazyV2<CleanupAllResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CleanupAllResponse::new)
    }
}

impl ::protobuf::Clear for CleanupAllResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CleanupAllResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CleanupAllResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutorOpts {
    // message fields
    pub record_costs: bool,
    pub record_timeline: bool,
    pub record_partition_graphs: bool,
    pub report_tensor_allocations_upon_oom: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutorOpts {
    fn default() -> &'a ExecutorOpts {
        <ExecutorOpts as ::protobuf::Message>::default_instance()
    }
}

impl ExecutorOpts {
    pub fn new() -> ExecutorOpts {
        ::std::default::Default::default()
    }

    // bool record_costs = 1;


    pub fn get_record_costs(&self) -> bool {
        self.record_costs
    }
    pub fn clear_record_costs(&mut self) {
        self.record_costs = false;
    }

    // Param is passed by value, moved
    pub fn set_record_costs(&mut self, v: bool) {
        self.record_costs = v;
    }

    // bool record_timeline = 3;


    pub fn get_record_timeline(&self) -> bool {
        self.record_timeline
    }
    pub fn clear_record_timeline(&mut self) {
        self.record_timeline = false;
    }

    // Param is passed by value, moved
    pub fn set_record_timeline(&mut self, v: bool) {
        self.record_timeline = v;
    }

    // bool record_partition_graphs = 4;


    pub fn get_record_partition_graphs(&self) -> bool {
        self.record_partition_graphs
    }
    pub fn clear_record_partition_graphs(&mut self) {
        self.record_partition_graphs = false;
    }

    // Param is passed by value, moved
    pub fn set_record_partition_graphs(&mut self, v: bool) {
        self.record_partition_graphs = v;
    }

    // bool report_tensor_allocations_upon_oom = 5;


    pub fn get_report_tensor_allocations_upon_oom(&self) -> bool {
        self.report_tensor_allocations_upon_oom
    }
    pub fn clear_report_tensor_allocations_upon_oom(&mut self) {
        self.report_tensor_allocations_upon_oom = false;
    }

    // Param is passed by value, moved
    pub fn set_report_tensor_allocations_upon_oom(&mut self, v: bool) {
        self.report_tensor_allocations_upon_oom = v;
    }
}

impl ::protobuf::Message for ExecutorOpts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_costs = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_timeline = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.record_partition_graphs = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.report_tensor_allocations_upon_oom = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.record_costs != false {
            my_size += 2;
        }
        if self.record_timeline != false {
            my_size += 2;
        }
        if self.record_partition_graphs != false {
            my_size += 2;
        }
        if self.report_tensor_allocations_upon_oom != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.record_costs != false {
            os.write_bool(1, self.record_costs)?;
        }
        if self.record_timeline != false {
            os.write_bool(3, self.record_timeline)?;
        }
        if self.record_partition_graphs != false {
            os.write_bool(4, self.record_partition_graphs)?;
        }
        if self.report_tensor_allocations_upon_oom != false {
            os.write_bool(5, self.report_tensor_allocations_upon_oom)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutorOpts {
        ExecutorOpts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "record_costs",
                |m: &ExecutorOpts| { &m.record_costs },
                |m: &mut ExecutorOpts| { &mut m.record_costs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "record_timeline",
                |m: &ExecutorOpts| { &m.record_timeline },
                |m: &mut ExecutorOpts| { &mut m.record_timeline },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "record_partition_graphs",
                |m: &ExecutorOpts| { &m.record_partition_graphs },
                |m: &mut ExecutorOpts| { &mut m.record_partition_graphs },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "report_tensor_allocations_upon_oom",
                |m: &ExecutorOpts| { &m.report_tensor_allocations_upon_oom },
                |m: &mut ExecutorOpts| { &mut m.report_tensor_allocations_upon_oom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecutorOpts>(
                "ExecutorOpts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecutorOpts {
        static instance: ::protobuf::rt::LazyV2<ExecutorOpts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecutorOpts::new)
    }
}

impl ::protobuf::Clear for ExecutorOpts {
    fn clear(&mut self) {
        self.record_costs = false;
        self.record_timeline = false;
        self.record_partition_graphs = false;
        self.report_tensor_allocations_upon_oom = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutorOpts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutorOpts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunGraphRequest {
    // message fields
    pub session_handle: ::std::string::String,
    pub create_worker_session_called: bool,
    pub graph_handle: ::std::string::String,
    pub step_id: i64,
    pub exec_opts: ::protobuf::SingularPtrField<ExecutorOpts>,
    pub send: ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto>,
    pub recv_key: ::protobuf::RepeatedField<::std::string::String>,
    pub is_partial: bool,
    pub is_last_partial_run: bool,
    pub store_errors_in_response_body: bool,
    pub request_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunGraphRequest {
    fn default() -> &'a RunGraphRequest {
        <RunGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl RunGraphRequest {
    pub fn new() -> RunGraphRequest {
        ::std::default::Default::default()
    }

    // string session_handle = 8;


    pub fn get_session_handle(&self) -> &str {
        &self.session_handle
    }
    pub fn clear_session_handle(&mut self) {
        self.session_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_session_handle(&mut self, v: ::std::string::String) {
        self.session_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_session_handle(&mut self) -> &mut ::std::string::String {
        &mut self.session_handle
    }

    // Take field
    pub fn take_session_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.session_handle, ::std::string::String::new())
    }

    // bool create_worker_session_called = 10;


    pub fn get_create_worker_session_called(&self) -> bool {
        self.create_worker_session_called
    }
    pub fn clear_create_worker_session_called(&mut self) {
        self.create_worker_session_called = false;
    }

    // Param is passed by value, moved
    pub fn set_create_worker_session_called(&mut self, v: bool) {
        self.create_worker_session_called = v;
    }

    // string graph_handle = 1;


    pub fn get_graph_handle(&self) -> &str {
        &self.graph_handle
    }
    pub fn clear_graph_handle(&mut self) {
        self.graph_handle.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_handle(&mut self, v: ::std::string::String) {
        self.graph_handle = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_graph_handle(&mut self) -> &mut ::std::string::String {
        &mut self.graph_handle
    }

    // Take field
    pub fn take_graph_handle(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.graph_handle, ::std::string::String::new())
    }

    // int64 step_id = 2;


    pub fn get_step_id(&self) -> i64 {
        self.step_id
    }
    pub fn clear_step_id(&mut self) {
        self.step_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_step_id(&mut self, v: i64) {
        self.step_id = v;
    }

    // .tensorflow.ExecutorOpts exec_opts = 5;


    pub fn get_exec_opts(&self) -> &ExecutorOpts {
        self.exec_opts.as_ref().unwrap_or_else(|| <ExecutorOpts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_exec_opts(&mut self) {
        self.exec_opts.clear();
    }

    pub fn has_exec_opts(&self) -> bool {
        self.exec_opts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec_opts(&mut self, v: ExecutorOpts) {
        self.exec_opts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec_opts(&mut self) -> &mut ExecutorOpts {
        if self.exec_opts.is_none() {
            self.exec_opts.set_default();
        }
        self.exec_opts.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec_opts(&mut self) -> ExecutorOpts {
        self.exec_opts.take().unwrap_or_else(|| ExecutorOpts::new())
    }

    // repeated .tensorflow.NamedTensorProto send = 3;


    pub fn get_send(&self) -> &[super::named_tensor::NamedTensorProto] {
        &self.send
    }
    pub fn clear_send(&mut self) {
        self.send.clear();
    }

    // Param is passed by value, moved
    pub fn set_send(&mut self, v: ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto>) {
        self.send = v;
    }

    // Mutable pointer to the field.
    pub fn mut_send(&mut self) -> &mut ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto> {
        &mut self.send
    }

    // Take field
    pub fn take_send(&mut self) -> ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto> {
        ::std::mem::replace(&mut self.send, ::protobuf::RepeatedField::new())
    }

    // repeated string recv_key = 4;


    pub fn get_recv_key(&self) -> &[::std::string::String] {
        &self.recv_key
    }
    pub fn clear_recv_key(&mut self) {
        self.recv_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_recv_key(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.recv_key = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recv_key(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.recv_key
    }

    // Take field
    pub fn take_recv_key(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.recv_key, ::protobuf::RepeatedField::new())
    }

    // bool is_partial = 6;


    pub fn get_is_partial(&self) -> bool {
        self.is_partial
    }
    pub fn clear_is_partial(&mut self) {
        self.is_partial = false;
    }

    // Param is passed by value, moved
    pub fn set_is_partial(&mut self, v: bool) {
        self.is_partial = v;
    }

    // bool is_last_partial_run = 7;


    pub fn get_is_last_partial_run(&self) -> bool {
        self.is_last_partial_run
    }
    pub fn clear_is_last_partial_run(&mut self) {
        self.is_last_partial_run = false;
    }

    // Param is passed by value, moved
    pub fn set_is_last_partial_run(&mut self, v: bool) {
        self.is_last_partial_run = v;
    }

    // bool store_errors_in_response_body = 9;


    pub fn get_store_errors_in_response_body(&self) -> bool {
        self.store_errors_in_response_body
    }
    pub fn clear_store_errors_in_response_body(&mut self) {
        self.store_errors_in_response_body = false;
    }

    // Param is passed by value, moved
    pub fn set_store_errors_in_response_body(&mut self, v: bool) {
        self.store_errors_in_response_body = v;
    }

    // int64 request_id = 11;


    pub fn get_request_id(&self) -> i64 {
        self.request_id
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: i64) {
        self.request_id = v;
    }
}

impl ::protobuf::Message for RunGraphRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.exec_opts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.send {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.session_handle)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.create_worker_session_called = tmp;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.graph_handle)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.step_id = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec_opts)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.send)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.recv_key)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_partial = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_last_partial_run = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.store_errors_in_response_body = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.request_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.session_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.session_handle);
        }
        if self.create_worker_session_called != false {
            my_size += 2;
        }
        if !self.graph_handle.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.graph_handle);
        }
        if self.step_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.step_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.exec_opts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.send {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.recv_key {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.is_partial != false {
            my_size += 2;
        }
        if self.is_last_partial_run != false {
            my_size += 2;
        }
        if self.store_errors_in_response_body != false {
            my_size += 2;
        }
        if self.request_id != 0 {
            my_size += ::protobuf::rt::value_size(11, self.request_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.session_handle.is_empty() {
            os.write_string(8, &self.session_handle)?;
        }
        if self.create_worker_session_called != false {
            os.write_bool(10, self.create_worker_session_called)?;
        }
        if !self.graph_handle.is_empty() {
            os.write_string(1, &self.graph_handle)?;
        }
        if self.step_id != 0 {
            os.write_int64(2, self.step_id)?;
        }
        if let Some(ref v) = self.exec_opts.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.send {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.recv_key {
            os.write_string(4, &v)?;
        };
        if self.is_partial != false {
            os.write_bool(6, self.is_partial)?;
        }
        if self.is_last_partial_run != false {
            os.write_bool(7, self.is_last_partial_run)?;
        }
        if self.store_errors_in_response_body != false {
            os.write_bool(9, self.store_errors_in_response_body)?;
        }
        if self.request_id != 0 {
            os.write_int64(11, self.request_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunGraphRequest {
        RunGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "session_handle",
                |m: &RunGraphRequest| { &m.session_handle },
                |m: &mut RunGraphRequest| { &mut m.session_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "create_worker_session_called",
                |m: &RunGraphRequest| { &m.create_worker_session_called },
                |m: &mut RunGraphRequest| { &mut m.create_worker_session_called },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "graph_handle",
                |m: &RunGraphRequest| { &m.graph_handle },
                |m: &mut RunGraphRequest| { &mut m.graph_handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "step_id",
                |m: &RunGraphRequest| { &m.step_id },
                |m: &mut RunGraphRequest| { &mut m.step_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecutorOpts>>(
                "exec_opts",
                |m: &RunGraphRequest| { &m.exec_opts },
                |m: &mut RunGraphRequest| { &mut m.exec_opts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::named_tensor::NamedTensorProto>>(
                "send",
                |m: &RunGraphRequest| { &m.send },
                |m: &mut RunGraphRequest| { &mut m.send },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recv_key",
                |m: &RunGraphRequest| { &m.recv_key },
                |m: &mut RunGraphRequest| { &mut m.recv_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_partial",
                |m: &RunGraphRequest| { &m.is_partial },
                |m: &mut RunGraphRequest| { &mut m.is_partial },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_last_partial_run",
                |m: &RunGraphRequest| { &m.is_last_partial_run },
                |m: &mut RunGraphRequest| { &mut m.is_last_partial_run },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "store_errors_in_response_body",
                |m: &RunGraphRequest| { &m.store_errors_in_response_body },
                |m: &mut RunGraphRequest| { &mut m.store_errors_in_response_body },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "request_id",
                |m: &RunGraphRequest| { &m.request_id },
                |m: &mut RunGraphRequest| { &mut m.request_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RunGraphRequest>(
                "RunGraphRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RunGraphRequest {
        static instance: ::protobuf::rt::LazyV2<RunGraphRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RunGraphRequest::new)
    }
}

impl ::protobuf::Clear for RunGraphRequest {
    fn clear(&mut self) {
        self.session_handle.clear();
        self.create_worker_session_called = false;
        self.graph_handle.clear();
        self.step_id = 0;
        self.exec_opts.clear();
        self.send.clear();
        self.recv_key.clear();
        self.is_partial = false;
        self.is_last_partial_run = false;
        self.store_errors_in_response_body = false;
        self.request_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RunGraphResponse {
    // message fields
    pub recv: ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto>,
    pub step_stats: ::protobuf::SingularPtrField<super::step_stats::StepStats>,
    pub cost_graph: ::protobuf::SingularPtrField<super::cost_graph::CostGraphDef>,
    pub partition_graph: ::protobuf::RepeatedField<super::graph::GraphDef>,
    pub status_code: super::error_codes::Code,
    pub status_error_message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RunGraphResponse {
    fn default() -> &'a RunGraphResponse {
        <RunGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl RunGraphResponse {
    pub fn new() -> RunGraphResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.NamedTensorProto recv = 1;


    pub fn get_recv(&self) -> &[super::named_tensor::NamedTensorProto] {
        &self.recv
    }
    pub fn clear_recv(&mut self) {
        self.recv.clear();
    }

    // Param is passed by value, moved
    pub fn set_recv(&mut self, v: ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto>) {
        self.recv = v;
    }

    // Mutable pointer to the field.
    pub fn mut_recv(&mut self) -> &mut ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto> {
        &mut self.recv
    }

    // Take field
    pub fn take_recv(&mut self) -> ::protobuf::RepeatedField<super::named_tensor::NamedTensorProto> {
        ::std::mem::replace(&mut self.recv, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.StepStats step_stats = 2;


    pub fn get_step_stats(&self) -> &super::step_stats::StepStats {
        self.step_stats.as_ref().unwrap_or_else(|| <super::step_stats::StepStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_step_stats(&mut self) {
        self.step_stats.clear();
    }

    pub fn has_step_stats(&self) -> bool {
        self.step_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_step_stats(&mut self, v: super::step_stats::StepStats) {
        self.step_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_step_stats(&mut self) -> &mut super::step_stats::StepStats {
        if self.step_stats.is_none() {
            self.step_stats.set_default();
        }
        self.step_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_step_stats(&mut self) -> super::step_stats::StepStats {
        self.step_stats.take().unwrap_or_else(|| super::step_stats::StepStats::new())
    }

    // .tensorflow.CostGraphDef cost_graph = 3;


    pub fn get_cost_graph(&self) -> &super::cost_graph::CostGraphDef {
        self.cost_graph.as_ref().unwrap_or_else(|| <super::cost_graph::CostGraphDef as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cost_graph(&mut self) {
        self.cost_graph.clear();
    }

    pub fn has_cost_graph(&self) -> bool {
        self.cost_graph.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cost_graph(&mut self, v: super::cost_graph::CostGraphDef) {
        self.cost_graph = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cost_graph(&mut self) -> &mut super::cost_graph::CostGraphDef {
        if self.cost_graph.is_none() {
            self.cost_graph.set_default();
        }
        self.cost_graph.as_mut().unwrap()
    }

    // Take field
    pub fn take_cost_graph(&mut self) -> super::cost_graph::CostGraphDef {
        self.cost_graph.take().unwrap_or_else(|| super::cost_graph::CostGraphDef::new())
    }

    // repeated .tensorflow.GraphDef partition_graph = 4;


    pub fn get_partition_graph(&self) -> &[super::graph::GraphDef] {
        &self.partition_graph
    }
    pub fn clear_partition_graph(&mut self) {
        self.partition_graph.clear();
    }

    // Param is passed by value, moved
    pub fn set_partition_graph(&mut self, v: ::protobuf::RepeatedField<super::graph::GraphDef>) {
        self.partition_graph = v;
    }

    // Mutable pointer to the field.
    pub fn mut_partition_graph(&mut self) -> &mut ::protobuf::RepeatedField<super::graph::GraphDef> {
        &mut self.partition_graph
    }

    // Take field
    pub fn take_partition_graph(&mut self) -> ::protobuf::RepeatedField<super::graph::GraphDef> {
        ::std::mem::replace(&mut self.partition_graph, ::protobuf::RepeatedField::new())
    }

    // .tensorflow.error.Code status_code = 5;


    pub fn get_status_code(&self) -> super::error_codes::Code {
        self.status_code
    }
    pub fn clear_status_code(&mut self) {
        self.status_code = super::error_codes::Code::OK;
    }

    // Param is passed by value, moved
    pub fn set_status_code(&mut self, v: super::error_codes::Code) {
        self.status_code = v;
    }

    // string status_error_message = 6;


    pub fn get_status_error_message(&self) -> &str {
        &self.status_error_message
    }
    pub fn clear_status_error_message(&mut self) {
        self.status_error_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_error_message(&mut self, v: ::std::string::String) {
        self.status_error_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_error_message(&mut self) -> &mut ::std::string::String {
        &mut self.status_error_message
    }

    // Take field
    pub fn take_status_error_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_error_message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RunGraphResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.recv {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.step_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cost_graph {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.partition_graph {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.recv)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.step_stats)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cost_graph)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.partition_graph)?;
                },
                5 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status_code, 5, &mut self.unknown_fields)?
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_error_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.recv {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.step_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cost_graph.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.partition_graph {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.status_code != super::error_codes::Code::OK {
            my_size += ::protobuf::rt::enum_size(5, self.status_code);
        }
        if !self.status_error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.status_error_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.recv {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.step_stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cost_graph.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.partition_graph {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.status_code != super::error_codes::Code::OK {
            os.write_enum(5, ::protobuf::ProtobufEnum::value(&self.status_code))?;
        }
        if !self.status_error_message.is_empty() {
            os.write_string(6, &self.status_error_message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RunGraphResponse {
        RunGraphResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::named_tensor::NamedTensorProto>>(
                "recv",
                |m: &RunGraphResponse| { &m.recv },
                |m: &mut RunGraphResponse| { &mut m.recv },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::step_stats::StepStats>>(
                "step_stats",
                |m: &RunGraphResponse| { &m.step_stats },
                |m: &mut RunGraphResponse| { &mut m.step_stats },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::cost_graph::CostGraphDef>>(
                "cost_graph",
                |m: &RunGraphResponse| { &m.cost_graph },
                |m: &mut RunGraphResponse| { &mut m.cost_graph },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::graph::GraphDef>>(
                "partition_graph",
                |m: &RunGraphResponse| { &m.partition_graph },
                |m: &mut RunGraphResponse| { &mut m.partition_graph },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::error_codes::Code>>(
                "status_code",
                |m: &RunGraphResponse| { &m.status_code },
                |m: &mut RunGraphResponse| { &mut m.status_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_error_message",
                |m: &RunGraphResponse| { &m.status_error_message },
                |m: &mut RunGraphResponse| { &mut m.status_error_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RunGraphResponse>(
                "RunGraphResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RunGraphResponse {
        static instance: ::protobuf::rt::LazyV2<RunGraphResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RunGraphResponse::new)
    }
}

impl ::protobuf::Clear for RunGraphResponse {
    fn clear(&mut self) {
        self.recv.clear();
        self.step_stats.clear();
        self.cost_graph.clear();
        self.partition_graph.clear();
        self.status_code = super::error_codes::Code::OK;
        self.status_error_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RunGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RunGraphResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CleanupGraphRequest {
    // message fields
    pub step_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CleanupGraphRequest {
    fn default() -> &'a CleanupGraphRequest {
        <CleanupGraphRequest as ::protobuf::Message>::default_instance()
    }
}

impl CleanupGraphRequest {
    pub fn new() -> CleanupGraphRequest {
        ::std::default::Default::default()
    }

    // int64 step_id = 1;


    pub fn get_step_id(&self) -> i64 {
        self.step_id
    }
    pub fn clear_step_id(&mut self) {
        self.step_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_step_id(&mut self, v: i64) {
        self.step_id = v;
    }
}

impl ::protobuf::Message for CleanupGraphRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.step_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.step_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.step_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.step_id != 0 {
            os.write_int64(1, self.step_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CleanupGraphRequest {
        CleanupGraphRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "step_id",
                |m: &CleanupGraphRequest| { &m.step_id },
                |m: &mut CleanupGraphRequest| { &mut m.step_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CleanupGraphRequest>(
                "CleanupGraphRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CleanupGraphRequest {
        static instance: ::protobuf::rt::LazyV2<CleanupGraphRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CleanupGraphRequest::new)
    }
}

impl ::protobuf::Clear for CleanupGraphRequest {
    fn clear(&mut self) {
        self.step_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CleanupGraphRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CleanupGraphRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CleanupGraphResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CleanupGraphResponse {
    fn default() -> &'a CleanupGraphResponse {
        <CleanupGraphResponse as ::protobuf::Message>::default_instance()
    }
}

impl CleanupGraphResponse {
    pub fn new() -> CleanupGraphResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for CleanupGraphResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CleanupGraphResponse {
        CleanupGraphResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CleanupGraphResponse>(
                "CleanupGraphResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CleanupGraphResponse {
        static instance: ::protobuf::rt::LazyV2<CleanupGraphResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CleanupGraphResponse::new)
    }
}

impl ::protobuf::Clear for CleanupGraphResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CleanupGraphResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CleanupGraphResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecvTensorRequest {
    // message fields
    pub step_id: i64,
    pub rendezvous_key: ::std::string::String,
    pub dma_ok: bool,
    pub client_locality: ::protobuf::SingularPtrField<super::device_attributes::DeviceLocality>,
    pub server_locality: ::protobuf::SingularPtrField<super::device_attributes::DeviceLocality>,
    pub transport_options: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub request_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecvTensorRequest {
    fn default() -> &'a RecvTensorRequest {
        <RecvTensorRequest as ::protobuf::Message>::default_instance()
    }
}

impl RecvTensorRequest {
    pub fn new() -> RecvTensorRequest {
        ::std::default::Default::default()
    }

    // int64 step_id = 1;


    pub fn get_step_id(&self) -> i64 {
        self.step_id
    }
    pub fn clear_step_id(&mut self) {
        self.step_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_step_id(&mut self, v: i64) {
        self.step_id = v;
    }

    // string rendezvous_key = 2;


    pub fn get_rendezvous_key(&self) -> &str {
        &self.rendezvous_key
    }
    pub fn clear_rendezvous_key(&mut self) {
        self.rendezvous_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_rendezvous_key(&mut self, v: ::std::string::String) {
        self.rendezvous_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rendezvous_key(&mut self) -> &mut ::std::string::String {
        &mut self.rendezvous_key
    }

    // Take field
    pub fn take_rendezvous_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rendezvous_key, ::std::string::String::new())
    }

    // bool dma_ok = 3;


    pub fn get_dma_ok(&self) -> bool {
        self.dma_ok
    }
    pub fn clear_dma_ok(&mut self) {
        self.dma_ok = false;
    }

    // Param is passed by value, moved
    pub fn set_dma_ok(&mut self, v: bool) {
        self.dma_ok = v;
    }

    // .tensorflow.DeviceLocality client_locality = 4;


    pub fn get_client_locality(&self) -> &super::device_attributes::DeviceLocality {
        self.client_locality.as_ref().unwrap_or_else(|| <super::device_attributes::DeviceLocality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_client_locality(&mut self) {
        self.client_locality.clear();
    }

    pub fn has_client_locality(&self) -> bool {
        self.client_locality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_locality(&mut self, v: super::device_attributes::DeviceLocality) {
        self.client_locality = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_locality(&mut self) -> &mut super::device_attributes::DeviceLocality {
        if self.client_locality.is_none() {
            self.client_locality.set_default();
        }
        self.client_locality.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_locality(&mut self) -> super::device_attributes::DeviceLocality {
        self.client_locality.take().unwrap_or_else(|| super::device_attributes::DeviceLocality::new())
    }

    // .tensorflow.DeviceLocality server_locality = 5;


    pub fn get_server_locality(&self) -> &super::device_attributes::DeviceLocality {
        self.server_locality.as_ref().unwrap_or_else(|| <super::device_attributes::DeviceLocality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_locality(&mut self) {
        self.server_locality.clear();
    }

    pub fn has_server_locality(&self) -> bool {
        self.server_locality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_locality(&mut self, v: super::device_attributes::DeviceLocality) {
        self.server_locality = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_locality(&mut self) -> &mut super::device_attributes::DeviceLocality {
        if self.server_locality.is_none() {
            self.server_locality.set_default();
        }
        self.server_locality.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_locality(&mut self) -> super::device_attributes::DeviceLocality {
        self.server_locality.take().unwrap_or_else(|| super::device_attributes::DeviceLocality::new())
    }

    // .google.protobuf.Any transport_options = 6;


    pub fn get_transport_options(&self) -> &::protobuf::well_known_types::Any {
        self.transport_options.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transport_options(&mut self) {
        self.transport_options.clear();
    }

    pub fn has_transport_options(&self) -> bool {
        self.transport_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_options(&mut self, v: ::protobuf::well_known_types::Any) {
        self.transport_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transport_options(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.transport_options.is_none() {
            self.transport_options.set_default();
        }
        self.transport_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_transport_options(&mut self) -> ::protobuf::well_known_types::Any {
        self.transport_options.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // int64 request_id = 7;


    pub fn get_request_id(&self) -> i64 {
        self.request_id
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: i64) {
        self.request_id = v;
    }
}

impl ::protobuf::Message for RecvTensorRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.client_locality {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_locality {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.step_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rendezvous_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.dma_ok = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_locality)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_locality)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transport_options)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.request_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.step_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.step_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.rendezvous_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rendezvous_key);
        }
        if self.dma_ok != false {
            my_size += 2;
        }
        if let Some(ref v) = self.client_locality.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.server_locality.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.request_id != 0 {
            my_size += ::protobuf::rt::value_size(7, self.request_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.step_id != 0 {
            os.write_int64(1, self.step_id)?;
        }
        if !self.rendezvous_key.is_empty() {
            os.write_string(2, &self.rendezvous_key)?;
        }
        if self.dma_ok != false {
            os.write_bool(3, self.dma_ok)?;
        }
        if let Some(ref v) = self.client_locality.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.server_locality.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.request_id != 0 {
            os.write_int64(7, self.request_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecvTensorRequest {
        RecvTensorRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "step_id",
                |m: &RecvTensorRequest| { &m.step_id },
                |m: &mut RecvTensorRequest| { &mut m.step_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rendezvous_key",
                |m: &RecvTensorRequest| { &m.rendezvous_key },
                |m: &mut RecvTensorRequest| { &mut m.rendezvous_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "dma_ok",
                |m: &RecvTensorRequest| { &m.dma_ok },
                |m: &mut RecvTensorRequest| { &mut m.dma_ok },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceLocality>>(
                "client_locality",
                |m: &RecvTensorRequest| { &m.client_locality },
                |m: &mut RecvTensorRequest| { &mut m.client_locality },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceLocality>>(
                "server_locality",
                |m: &RecvTensorRequest| { &m.server_locality },
                |m: &mut RecvTensorRequest| { &mut m.server_locality },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "transport_options",
                |m: &RecvTensorRequest| { &m.transport_options },
                |m: &mut RecvTensorRequest| { &mut m.transport_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "request_id",
                |m: &RecvTensorRequest| { &m.request_id },
                |m: &mut RecvTensorRequest| { &mut m.request_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecvTensorRequest>(
                "RecvTensorRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecvTensorRequest {
        static instance: ::protobuf::rt::LazyV2<RecvTensorRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecvTensorRequest::new)
    }
}

impl ::protobuf::Clear for RecvTensorRequest {
    fn clear(&mut self) {
        self.step_id = 0;
        self.rendezvous_key.clear();
        self.dma_ok = false;
        self.client_locality.clear();
        self.server_locality.clear();
        self.transport_options.clear();
        self.request_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecvTensorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecvTensorRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecvTensorResponse {
    // message fields
    pub tensor: ::protobuf::SingularPtrField<super::tensor::TensorProto>,
    pub is_dead: bool,
    pub send_start_micros: i64,
    pub transport_options: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub require_ack: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecvTensorResponse {
    fn default() -> &'a RecvTensorResponse {
        <RecvTensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl RecvTensorResponse {
    pub fn new() -> RecvTensorResponse {
        ::std::default::Default::default()
    }

    // .tensorflow.TensorProto tensor = 1;


    pub fn get_tensor(&self) -> &super::tensor::TensorProto {
        self.tensor.as_ref().unwrap_or_else(|| <super::tensor::TensorProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tensor(&mut self) {
        self.tensor.clear();
    }

    pub fn has_tensor(&self) -> bool {
        self.tensor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tensor(&mut self, v: super::tensor::TensorProto) {
        self.tensor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tensor(&mut self) -> &mut super::tensor::TensorProto {
        if self.tensor.is_none() {
            self.tensor.set_default();
        }
        self.tensor.as_mut().unwrap()
    }

    // Take field
    pub fn take_tensor(&mut self) -> super::tensor::TensorProto {
        self.tensor.take().unwrap_or_else(|| super::tensor::TensorProto::new())
    }

    // bool is_dead = 2;


    pub fn get_is_dead(&self) -> bool {
        self.is_dead
    }
    pub fn clear_is_dead(&mut self) {
        self.is_dead = false;
    }

    // Param is passed by value, moved
    pub fn set_is_dead(&mut self, v: bool) {
        self.is_dead = v;
    }

    // int64 send_start_micros = 3;


    pub fn get_send_start_micros(&self) -> i64 {
        self.send_start_micros
    }
    pub fn clear_send_start_micros(&mut self) {
        self.send_start_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_start_micros(&mut self, v: i64) {
        self.send_start_micros = v;
    }

    // .google.protobuf.Any transport_options = 4;


    pub fn get_transport_options(&self) -> &::protobuf::well_known_types::Any {
        self.transport_options.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transport_options(&mut self) {
        self.transport_options.clear();
    }

    pub fn has_transport_options(&self) -> bool {
        self.transport_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_options(&mut self, v: ::protobuf::well_known_types::Any) {
        self.transport_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transport_options(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.transport_options.is_none() {
            self.transport_options.set_default();
        }
        self.transport_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_transport_options(&mut self) -> ::protobuf::well_known_types::Any {
        self.transport_options.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // bool require_ack = 5;


    pub fn get_require_ack(&self) -> bool {
        self.require_ack
    }
    pub fn clear_require_ack(&mut self) {
        self.require_ack = false;
    }

    // Param is passed by value, moved
    pub fn set_require_ack(&mut self, v: bool) {
        self.require_ack = v;
    }
}

impl ::protobuf::Message for RecvTensorResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.tensor {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tensor)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_dead = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.send_start_micros = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transport_options)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_ack = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.tensor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_dead != false {
            my_size += 2;
        }
        if self.send_start_micros != 0 {
            my_size += ::protobuf::rt::value_size(3, self.send_start_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.require_ack != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.tensor.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_dead != false {
            os.write_bool(2, self.is_dead)?;
        }
        if self.send_start_micros != 0 {
            os.write_int64(3, self.send_start_micros)?;
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.require_ack != false {
            os.write_bool(5, self.require_ack)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecvTensorResponse {
        RecvTensorResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor::TensorProto>>(
                "tensor",
                |m: &RecvTensorResponse| { &m.tensor },
                |m: &mut RecvTensorResponse| { &mut m.tensor },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_dead",
                |m: &RecvTensorResponse| { &m.is_dead },
                |m: &mut RecvTensorResponse| { &mut m.is_dead },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "send_start_micros",
                |m: &RecvTensorResponse| { &m.send_start_micros },
                |m: &mut RecvTensorResponse| { &mut m.send_start_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "transport_options",
                |m: &RecvTensorResponse| { &m.transport_options },
                |m: &mut RecvTensorResponse| { &mut m.transport_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "require_ack",
                |m: &RecvTensorResponse| { &m.require_ack },
                |m: &mut RecvTensorResponse| { &mut m.require_ack },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecvTensorResponse>(
                "RecvTensorResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecvTensorResponse {
        static instance: ::protobuf::rt::LazyV2<RecvTensorResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecvTensorResponse::new)
    }
}

impl ::protobuf::Clear for RecvTensorResponse {
    fn clear(&mut self) {
        self.tensor.clear();
        self.is_dead = false;
        self.send_start_micros = 0;
        self.transport_options.clear();
        self.require_ack = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecvTensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecvTensorResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MarkRecvFinishedRequest {
    // message fields
    pub request_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarkRecvFinishedRequest {
    fn default() -> &'a MarkRecvFinishedRequest {
        <MarkRecvFinishedRequest as ::protobuf::Message>::default_instance()
    }
}

impl MarkRecvFinishedRequest {
    pub fn new() -> MarkRecvFinishedRequest {
        ::std::default::Default::default()
    }

    // int64 request_id = 1;


    pub fn get_request_id(&self) -> i64 {
        self.request_id
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: i64) {
        self.request_id = v;
    }
}

impl ::protobuf::Message for MarkRecvFinishedRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.request_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.request_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.request_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.request_id != 0 {
            os.write_int64(1, self.request_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarkRecvFinishedRequest {
        MarkRecvFinishedRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "request_id",
                |m: &MarkRecvFinishedRequest| { &m.request_id },
                |m: &mut MarkRecvFinishedRequest| { &mut m.request_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MarkRecvFinishedRequest>(
                "MarkRecvFinishedRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MarkRecvFinishedRequest {
        static instance: ::protobuf::rt::LazyV2<MarkRecvFinishedRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarkRecvFinishedRequest::new)
    }
}

impl ::protobuf::Clear for MarkRecvFinishedRequest {
    fn clear(&mut self) {
        self.request_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MarkRecvFinishedRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkRecvFinishedRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MarkRecvFinishedResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MarkRecvFinishedResponse {
    fn default() -> &'a MarkRecvFinishedResponse {
        <MarkRecvFinishedResponse as ::protobuf::Message>::default_instance()
    }
}

impl MarkRecvFinishedResponse {
    pub fn new() -> MarkRecvFinishedResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for MarkRecvFinishedResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MarkRecvFinishedResponse {
        MarkRecvFinishedResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MarkRecvFinishedResponse>(
                "MarkRecvFinishedResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MarkRecvFinishedResponse {
        static instance: ::protobuf::rt::LazyV2<MarkRecvFinishedResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MarkRecvFinishedResponse::new)
    }
}

impl ::protobuf::Clear for MarkRecvFinishedResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MarkRecvFinishedResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MarkRecvFinishedResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoggingRequest {
    // message fields
    pub enable_rpc_logging: bool,
    pub disable_rpc_logging: bool,
    pub clear: bool,
    pub fetch_step_id: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoggingRequest {
    fn default() -> &'a LoggingRequest {
        <LoggingRequest as ::protobuf::Message>::default_instance()
    }
}

impl LoggingRequest {
    pub fn new() -> LoggingRequest {
        ::std::default::Default::default()
    }

    // bool enable_rpc_logging = 1;


    pub fn get_enable_rpc_logging(&self) -> bool {
        self.enable_rpc_logging
    }
    pub fn clear_enable_rpc_logging(&mut self) {
        self.enable_rpc_logging = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_rpc_logging(&mut self, v: bool) {
        self.enable_rpc_logging = v;
    }

    // bool disable_rpc_logging = 4;


    pub fn get_disable_rpc_logging(&self) -> bool {
        self.disable_rpc_logging
    }
    pub fn clear_disable_rpc_logging(&mut self) {
        self.disable_rpc_logging = false;
    }

    // Param is passed by value, moved
    pub fn set_disable_rpc_logging(&mut self, v: bool) {
        self.disable_rpc_logging = v;
    }

    // bool clear = 2;


    pub fn get_clear(&self) -> bool {
        self.clear
    }
    pub fn clear_clear(&mut self) {
        self.clear = false;
    }

    // Param is passed by value, moved
    pub fn set_clear(&mut self, v: bool) {
        self.clear = v;
    }

    // repeated int64 fetch_step_id = 3;


    pub fn get_fetch_step_id(&self) -> &[i64] {
        &self.fetch_step_id
    }
    pub fn clear_fetch_step_id(&mut self) {
        self.fetch_step_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_fetch_step_id(&mut self, v: ::std::vec::Vec<i64>) {
        self.fetch_step_id = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fetch_step_id(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.fetch_step_id
    }

    // Take field
    pub fn take_fetch_step_id(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.fetch_step_id, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LoggingRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_rpc_logging = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disable_rpc_logging = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.clear = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.fetch_step_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable_rpc_logging != false {
            my_size += 2;
        }
        if self.disable_rpc_logging != false {
            my_size += 2;
        }
        if self.clear != false {
            my_size += 2;
        }
        for value in &self.fetch_step_id {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable_rpc_logging != false {
            os.write_bool(1, self.enable_rpc_logging)?;
        }
        if self.disable_rpc_logging != false {
            os.write_bool(4, self.disable_rpc_logging)?;
        }
        if self.clear != false {
            os.write_bool(2, self.clear)?;
        }
        for v in &self.fetch_step_id {
            os.write_int64(3, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoggingRequest {
        LoggingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_rpc_logging",
                |m: &LoggingRequest| { &m.enable_rpc_logging },
                |m: &mut LoggingRequest| { &mut m.enable_rpc_logging },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disable_rpc_logging",
                |m: &LoggingRequest| { &m.disable_rpc_logging },
                |m: &mut LoggingRequest| { &mut m.disable_rpc_logging },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "clear",
                |m: &LoggingRequest| { &m.clear },
                |m: &mut LoggingRequest| { &mut m.clear },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fetch_step_id",
                |m: &LoggingRequest| { &m.fetch_step_id },
                |m: &mut LoggingRequest| { &mut m.fetch_step_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoggingRequest>(
                "LoggingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoggingRequest {
        static instance: ::protobuf::rt::LazyV2<LoggingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoggingRequest::new)
    }
}

impl ::protobuf::Clear for LoggingRequest {
    fn clear(&mut self) {
        self.enable_rpc_logging = false;
        self.disable_rpc_logging = false;
        self.clear = false;
        self.fetch_step_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoggingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoggingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabeledStepStats {
    // message fields
    pub step_id: i64,
    pub step_stats: ::protobuf::SingularPtrField<super::step_stats::StepStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabeledStepStats {
    fn default() -> &'a LabeledStepStats {
        <LabeledStepStats as ::protobuf::Message>::default_instance()
    }
}

impl LabeledStepStats {
    pub fn new() -> LabeledStepStats {
        ::std::default::Default::default()
    }

    // int64 step_id = 1;


    pub fn get_step_id(&self) -> i64 {
        self.step_id
    }
    pub fn clear_step_id(&mut self) {
        self.step_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_step_id(&mut self, v: i64) {
        self.step_id = v;
    }

    // .tensorflow.StepStats step_stats = 2;


    pub fn get_step_stats(&self) -> &super::step_stats::StepStats {
        self.step_stats.as_ref().unwrap_or_else(|| <super::step_stats::StepStats as ::protobuf::Message>::default_instance())
    }
    pub fn clear_step_stats(&mut self) {
        self.step_stats.clear();
    }

    pub fn has_step_stats(&self) -> bool {
        self.step_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_step_stats(&mut self, v: super::step_stats::StepStats) {
        self.step_stats = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_step_stats(&mut self) -> &mut super::step_stats::StepStats {
        if self.step_stats.is_none() {
            self.step_stats.set_default();
        }
        self.step_stats.as_mut().unwrap()
    }

    // Take field
    pub fn take_step_stats(&mut self) -> super::step_stats::StepStats {
        self.step_stats.take().unwrap_or_else(|| super::step_stats::StepStats::new())
    }
}

impl ::protobuf::Message for LabeledStepStats {
    fn is_initialized(&self) -> bool {
        for v in &self.step_stats {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.step_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.step_stats)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.step_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.step_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.step_stats.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.step_id != 0 {
            os.write_int64(1, self.step_id)?;
        }
        if let Some(ref v) = self.step_stats.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabeledStepStats {
        LabeledStepStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "step_id",
                |m: &LabeledStepStats| { &m.step_id },
                |m: &mut LabeledStepStats| { &mut m.step_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::step_stats::StepStats>>(
                "step_stats",
                |m: &LabeledStepStats| { &m.step_stats },
                |m: &mut LabeledStepStats| { &mut m.step_stats },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabeledStepStats>(
                "LabeledStepStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabeledStepStats {
        static instance: ::protobuf::rt::LazyV2<LabeledStepStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabeledStepStats::new)
    }
}

impl ::protobuf::Clear for LabeledStepStats {
    fn clear(&mut self) {
        self.step_id = 0;
        self.step_stats.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabeledStepStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabeledStepStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoggingResponse {
    // message fields
    pub step: ::protobuf::RepeatedField<LabeledStepStats>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoggingResponse {
    fn default() -> &'a LoggingResponse {
        <LoggingResponse as ::protobuf::Message>::default_instance()
    }
}

impl LoggingResponse {
    pub fn new() -> LoggingResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.LabeledStepStats step = 1;


    pub fn get_step(&self) -> &[LabeledStepStats] {
        &self.step
    }
    pub fn clear_step(&mut self) {
        self.step.clear();
    }

    // Param is passed by value, moved
    pub fn set_step(&mut self, v: ::protobuf::RepeatedField<LabeledStepStats>) {
        self.step = v;
    }

    // Mutable pointer to the field.
    pub fn mut_step(&mut self) -> &mut ::protobuf::RepeatedField<LabeledStepStats> {
        &mut self.step
    }

    // Take field
    pub fn take_step(&mut self) -> ::protobuf::RepeatedField<LabeledStepStats> {
        ::std::mem::replace(&mut self.step, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LoggingResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.step {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.step)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.step {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.step {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoggingResponse {
        LoggingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabeledStepStats>>(
                "step",
                |m: &LoggingResponse| { &m.step },
                |m: &mut LoggingResponse| { &mut m.step },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoggingResponse>(
                "LoggingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoggingResponse {
        static instance: ::protobuf::rt::LazyV2<LoggingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoggingResponse::new)
    }
}

impl ::protobuf::Clear for LoggingResponse {
    fn clear(&mut self) {
        self.step.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoggingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoggingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TraceOpts {
    // message fields
    pub duration: f64,
    pub use_step_profiler: bool,
    pub use_kernel_profiler: bool,
    pub use_extended_profiler: bool,
    pub use_gpu_profiler: bool,
    pub use_sample_profiler: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TraceOpts {
    fn default() -> &'a TraceOpts {
        <TraceOpts as ::protobuf::Message>::default_instance()
    }
}

impl TraceOpts {
    pub fn new() -> TraceOpts {
        ::std::default::Default::default()
    }

    // double duration = 1;


    pub fn get_duration(&self) -> f64 {
        self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration = 0.;
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: f64) {
        self.duration = v;
    }

    // bool use_step_profiler = 2;


    pub fn get_use_step_profiler(&self) -> bool {
        self.use_step_profiler
    }
    pub fn clear_use_step_profiler(&mut self) {
        self.use_step_profiler = false;
    }

    // Param is passed by value, moved
    pub fn set_use_step_profiler(&mut self, v: bool) {
        self.use_step_profiler = v;
    }

    // bool use_kernel_profiler = 3;


    pub fn get_use_kernel_profiler(&self) -> bool {
        self.use_kernel_profiler
    }
    pub fn clear_use_kernel_profiler(&mut self) {
        self.use_kernel_profiler = false;
    }

    // Param is passed by value, moved
    pub fn set_use_kernel_profiler(&mut self, v: bool) {
        self.use_kernel_profiler = v;
    }

    // bool use_extended_profiler = 4;


    pub fn get_use_extended_profiler(&self) -> bool {
        self.use_extended_profiler
    }
    pub fn clear_use_extended_profiler(&mut self) {
        self.use_extended_profiler = false;
    }

    // Param is passed by value, moved
    pub fn set_use_extended_profiler(&mut self, v: bool) {
        self.use_extended_profiler = v;
    }

    // bool use_gpu_profiler = 5;


    pub fn get_use_gpu_profiler(&self) -> bool {
        self.use_gpu_profiler
    }
    pub fn clear_use_gpu_profiler(&mut self) {
        self.use_gpu_profiler = false;
    }

    // Param is passed by value, moved
    pub fn set_use_gpu_profiler(&mut self, v: bool) {
        self.use_gpu_profiler = v;
    }

    // bool use_sample_profiler = 6;


    pub fn get_use_sample_profiler(&self) -> bool {
        self.use_sample_profiler
    }
    pub fn clear_use_sample_profiler(&mut self) {
        self.use_sample_profiler = false;
    }

    // Param is passed by value, moved
    pub fn set_use_sample_profiler(&mut self, v: bool) {
        self.use_sample_profiler = v;
    }
}

impl ::protobuf::Message for TraceOpts {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.duration = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_step_profiler = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_kernel_profiler = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_extended_profiler = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_gpu_profiler = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_sample_profiler = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.duration != 0. {
            my_size += 9;
        }
        if self.use_step_profiler != false {
            my_size += 2;
        }
        if self.use_kernel_profiler != false {
            my_size += 2;
        }
        if self.use_extended_profiler != false {
            my_size += 2;
        }
        if self.use_gpu_profiler != false {
            my_size += 2;
        }
        if self.use_sample_profiler != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.duration != 0. {
            os.write_double(1, self.duration)?;
        }
        if self.use_step_profiler != false {
            os.write_bool(2, self.use_step_profiler)?;
        }
        if self.use_kernel_profiler != false {
            os.write_bool(3, self.use_kernel_profiler)?;
        }
        if self.use_extended_profiler != false {
            os.write_bool(4, self.use_extended_profiler)?;
        }
        if self.use_gpu_profiler != false {
            os.write_bool(5, self.use_gpu_profiler)?;
        }
        if self.use_sample_profiler != false {
            os.write_bool(6, self.use_sample_profiler)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TraceOpts {
        TraceOpts::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "duration",
                |m: &TraceOpts| { &m.duration },
                |m: &mut TraceOpts| { &mut m.duration },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_step_profiler",
                |m: &TraceOpts| { &m.use_step_profiler },
                |m: &mut TraceOpts| { &mut m.use_step_profiler },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_kernel_profiler",
                |m: &TraceOpts| { &m.use_kernel_profiler },
                |m: &mut TraceOpts| { &mut m.use_kernel_profiler },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_extended_profiler",
                |m: &TraceOpts| { &m.use_extended_profiler },
                |m: &mut TraceOpts| { &mut m.use_extended_profiler },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_gpu_profiler",
                |m: &TraceOpts| { &m.use_gpu_profiler },
                |m: &mut TraceOpts| { &mut m.use_gpu_profiler },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_sample_profiler",
                |m: &TraceOpts| { &m.use_sample_profiler },
                |m: &mut TraceOpts| { &mut m.use_sample_profiler },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TraceOpts>(
                "TraceOpts",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TraceOpts {
        static instance: ::protobuf::rt::LazyV2<TraceOpts> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TraceOpts::new)
    }
}

impl ::protobuf::Clear for TraceOpts {
    fn clear(&mut self) {
        self.duration = 0.;
        self.use_step_profiler = false;
        self.use_kernel_profiler = false;
        self.use_extended_profiler = false;
        self.use_gpu_profiler = false;
        self.use_sample_profiler = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TraceOpts {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TraceOpts {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingRequest {
    // message fields
    pub options: ::protobuf::SingularPtrField<TraceOpts>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingRequest {
    fn default() -> &'a TracingRequest {
        <TracingRequest as ::protobuf::Message>::default_instance()
    }
}

impl TracingRequest {
    pub fn new() -> TracingRequest {
        ::std::default::Default::default()
    }

    // .tensorflow.TraceOpts options = 1;


    pub fn get_options(&self) -> &TraceOpts {
        self.options.as_ref().unwrap_or_else(|| <TraceOpts as ::protobuf::Message>::default_instance())
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    pub fn has_options(&self) -> bool {
        self.options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: TraceOpts) {
        self.options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_options(&mut self) -> &mut TraceOpts {
        if self.options.is_none() {
            self.options.set_default();
        }
        self.options.as_mut().unwrap()
    }

    // Take field
    pub fn take_options(&mut self) -> TraceOpts {
        self.options.take().unwrap_or_else(|| TraceOpts::new())
    }
}

impl ::protobuf::Message for TracingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.options.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingRequest {
        TracingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TraceOpts>>(
                "options",
                |m: &TracingRequest| { &m.options },
                |m: &mut TracingRequest| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TracingRequest>(
                "TracingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TracingRequest {
        static instance: ::protobuf::rt::LazyV2<TracingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TracingRequest::new)
    }
}

impl ::protobuf::Clear for TracingRequest {
    fn clear(&mut self) {
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TracingResponse {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TracingResponse {
    fn default() -> &'a TracingResponse {
        <TracingResponse as ::protobuf::Message>::default_instance()
    }
}

impl TracingResponse {
    pub fn new() -> TracingResponse {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for TracingResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TracingResponse {
        TracingResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TracingResponse>(
                "TracingResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TracingResponse {
        static instance: ::protobuf::rt::LazyV2<TracingResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TracingResponse::new)
    }
}

impl ::protobuf::Clear for TracingResponse {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TracingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TracingResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecvBufRequest {
    // message fields
    pub step_id: i64,
    pub buf_rendezvous_key: ::std::string::String,
    pub num_bytes: i64,
    pub buf_ptr: u64,
    pub client_locality: ::protobuf::SingularPtrField<super::device_attributes::DeviceLocality>,
    pub server_locality: ::protobuf::SingularPtrField<super::device_attributes::DeviceLocality>,
    pub transport_options: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub src_device: ::std::string::String,
    pub dst_device: ::std::string::String,
    pub request_id: i64,
    pub src_incarnation: u64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecvBufRequest {
    fn default() -> &'a RecvBufRequest {
        <RecvBufRequest as ::protobuf::Message>::default_instance()
    }
}

impl RecvBufRequest {
    pub fn new() -> RecvBufRequest {
        ::std::default::Default::default()
    }

    // int64 step_id = 1;


    pub fn get_step_id(&self) -> i64 {
        self.step_id
    }
    pub fn clear_step_id(&mut self) {
        self.step_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_step_id(&mut self, v: i64) {
        self.step_id = v;
    }

    // string buf_rendezvous_key = 2;


    pub fn get_buf_rendezvous_key(&self) -> &str {
        &self.buf_rendezvous_key
    }
    pub fn clear_buf_rendezvous_key(&mut self) {
        self.buf_rendezvous_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_buf_rendezvous_key(&mut self, v: ::std::string::String) {
        self.buf_rendezvous_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buf_rendezvous_key(&mut self) -> &mut ::std::string::String {
        &mut self.buf_rendezvous_key
    }

    // Take field
    pub fn take_buf_rendezvous_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.buf_rendezvous_key, ::std::string::String::new())
    }

    // int64 num_bytes = 3;


    pub fn get_num_bytes(&self) -> i64 {
        self.num_bytes
    }
    pub fn clear_num_bytes(&mut self) {
        self.num_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_bytes(&mut self, v: i64) {
        self.num_bytes = v;
    }

    // fixed64 buf_ptr = 4;


    pub fn get_buf_ptr(&self) -> u64 {
        self.buf_ptr
    }
    pub fn clear_buf_ptr(&mut self) {
        self.buf_ptr = 0;
    }

    // Param is passed by value, moved
    pub fn set_buf_ptr(&mut self, v: u64) {
        self.buf_ptr = v;
    }

    // .tensorflow.DeviceLocality client_locality = 5;


    pub fn get_client_locality(&self) -> &super::device_attributes::DeviceLocality {
        self.client_locality.as_ref().unwrap_or_else(|| <super::device_attributes::DeviceLocality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_client_locality(&mut self) {
        self.client_locality.clear();
    }

    pub fn has_client_locality(&self) -> bool {
        self.client_locality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_locality(&mut self, v: super::device_attributes::DeviceLocality) {
        self.client_locality = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_locality(&mut self) -> &mut super::device_attributes::DeviceLocality {
        if self.client_locality.is_none() {
            self.client_locality.set_default();
        }
        self.client_locality.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_locality(&mut self) -> super::device_attributes::DeviceLocality {
        self.client_locality.take().unwrap_or_else(|| super::device_attributes::DeviceLocality::new())
    }

    // .tensorflow.DeviceLocality server_locality = 6;


    pub fn get_server_locality(&self) -> &super::device_attributes::DeviceLocality {
        self.server_locality.as_ref().unwrap_or_else(|| <super::device_attributes::DeviceLocality as ::protobuf::Message>::default_instance())
    }
    pub fn clear_server_locality(&mut self) {
        self.server_locality.clear();
    }

    pub fn has_server_locality(&self) -> bool {
        self.server_locality.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_locality(&mut self, v: super::device_attributes::DeviceLocality) {
        self.server_locality = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_locality(&mut self) -> &mut super::device_attributes::DeviceLocality {
        if self.server_locality.is_none() {
            self.server_locality.set_default();
        }
        self.server_locality.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_locality(&mut self) -> super::device_attributes::DeviceLocality {
        self.server_locality.take().unwrap_or_else(|| super::device_attributes::DeviceLocality::new())
    }

    // .google.protobuf.Any transport_options = 7;


    pub fn get_transport_options(&self) -> &::protobuf::well_known_types::Any {
        self.transport_options.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transport_options(&mut self) {
        self.transport_options.clear();
    }

    pub fn has_transport_options(&self) -> bool {
        self.transport_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_options(&mut self, v: ::protobuf::well_known_types::Any) {
        self.transport_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transport_options(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.transport_options.is_none() {
            self.transport_options.set_default();
        }
        self.transport_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_transport_options(&mut self) -> ::protobuf::well_known_types::Any {
        self.transport_options.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // string src_device = 8;


    pub fn get_src_device(&self) -> &str {
        &self.src_device
    }
    pub fn clear_src_device(&mut self) {
        self.src_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_src_device(&mut self, v: ::std::string::String) {
        self.src_device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_src_device(&mut self) -> &mut ::std::string::String {
        &mut self.src_device
    }

    // Take field
    pub fn take_src_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.src_device, ::std::string::String::new())
    }

    // string dst_device = 9;


    pub fn get_dst_device(&self) -> &str {
        &self.dst_device
    }
    pub fn clear_dst_device(&mut self) {
        self.dst_device.clear();
    }

    // Param is passed by value, moved
    pub fn set_dst_device(&mut self, v: ::std::string::String) {
        self.dst_device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dst_device(&mut self) -> &mut ::std::string::String {
        &mut self.dst_device
    }

    // Take field
    pub fn take_dst_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dst_device, ::std::string::String::new())
    }

    // int64 request_id = 10;


    pub fn get_request_id(&self) -> i64 {
        self.request_id
    }
    pub fn clear_request_id(&mut self) {
        self.request_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_request_id(&mut self, v: i64) {
        self.request_id = v;
    }

    // uint64 src_incarnation = 11;


    pub fn get_src_incarnation(&self) -> u64 {
        self.src_incarnation
    }
    pub fn clear_src_incarnation(&mut self) {
        self.src_incarnation = 0;
    }

    // Param is passed by value, moved
    pub fn set_src_incarnation(&mut self, v: u64) {
        self.src_incarnation = v;
    }
}

impl ::protobuf::Message for RecvBufRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.client_locality {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.server_locality {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.transport_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.step_id = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.buf_rendezvous_key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_bytes = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.buf_ptr = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_locality)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.server_locality)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transport_options)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.src_device)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dst_device)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.request_id = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.src_incarnation = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.step_id != 0 {
            my_size += ::protobuf::rt::value_size(1, self.step_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.buf_rendezvous_key.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.buf_rendezvous_key);
        }
        if self.num_bytes != 0 {
            my_size += ::protobuf::rt::value_size(3, self.num_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.buf_ptr != 0 {
            my_size += 9;
        }
        if let Some(ref v) = self.client_locality.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.server_locality.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.src_device.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.src_device);
        }
        if !self.dst_device.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.dst_device);
        }
        if self.request_id != 0 {
            my_size += ::protobuf::rt::value_size(10, self.request_id, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.src_incarnation != 0 {
            my_size += ::protobuf::rt::value_size(11, self.src_incarnation, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.step_id != 0 {
            os.write_int64(1, self.step_id)?;
        }
        if !self.buf_rendezvous_key.is_empty() {
            os.write_string(2, &self.buf_rendezvous_key)?;
        }
        if self.num_bytes != 0 {
            os.write_int64(3, self.num_bytes)?;
        }
        if self.buf_ptr != 0 {
            os.write_fixed64(4, self.buf_ptr)?;
        }
        if let Some(ref v) = self.client_locality.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.server_locality.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.src_device.is_empty() {
            os.write_string(8, &self.src_device)?;
        }
        if !self.dst_device.is_empty() {
            os.write_string(9, &self.dst_device)?;
        }
        if self.request_id != 0 {
            os.write_int64(10, self.request_id)?;
        }
        if self.src_incarnation != 0 {
            os.write_uint64(11, self.src_incarnation)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecvBufRequest {
        RecvBufRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "step_id",
                |m: &RecvBufRequest| { &m.step_id },
                |m: &mut RecvBufRequest| { &mut m.step_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "buf_rendezvous_key",
                |m: &RecvBufRequest| { &m.buf_rendezvous_key },
                |m: &mut RecvBufRequest| { &mut m.buf_rendezvous_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_bytes",
                |m: &RecvBufRequest| { &m.num_bytes },
                |m: &mut RecvBufRequest| { &mut m.num_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "buf_ptr",
                |m: &RecvBufRequest| { &m.buf_ptr },
                |m: &mut RecvBufRequest| { &mut m.buf_ptr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceLocality>>(
                "client_locality",
                |m: &RecvBufRequest| { &m.client_locality },
                |m: &mut RecvBufRequest| { &mut m.client_locality },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::device_attributes::DeviceLocality>>(
                "server_locality",
                |m: &RecvBufRequest| { &m.server_locality },
                |m: &mut RecvBufRequest| { &mut m.server_locality },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "transport_options",
                |m: &RecvBufRequest| { &m.transport_options },
                |m: &mut RecvBufRequest| { &mut m.transport_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "src_device",
                |m: &RecvBufRequest| { &m.src_device },
                |m: &mut RecvBufRequest| { &mut m.src_device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dst_device",
                |m: &RecvBufRequest| { &m.dst_device },
                |m: &mut RecvBufRequest| { &mut m.dst_device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "request_id",
                |m: &RecvBufRequest| { &m.request_id },
                |m: &mut RecvBufRequest| { &mut m.request_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "src_incarnation",
                |m: &RecvBufRequest| { &m.src_incarnation },
                |m: &mut RecvBufRequest| { &mut m.src_incarnation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecvBufRequest>(
                "RecvBufRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecvBufRequest {
        static instance: ::protobuf::rt::LazyV2<RecvBufRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecvBufRequest::new)
    }
}

impl ::protobuf::Clear for RecvBufRequest {
    fn clear(&mut self) {
        self.step_id = 0;
        self.buf_rendezvous_key.clear();
        self.num_bytes = 0;
        self.buf_ptr = 0;
        self.client_locality.clear();
        self.server_locality.clear();
        self.transport_options.clear();
        self.src_device.clear();
        self.dst_device.clear();
        self.request_id = 0;
        self.src_incarnation = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecvBufRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecvBufRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecvBufResponse {
    // message fields
    pub buf_ptr: u64,
    pub num_bytes: i64,
    pub is_dead: bool,
    pub transport_options: ::protobuf::SingularPtrField<::protobuf::well_known_types::Any>,
    pub send_start_micros: i64,
    pub require_ack: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecvBufResponse {
    fn default() -> &'a RecvBufResponse {
        <RecvBufResponse as ::protobuf::Message>::default_instance()
    }
}

impl RecvBufResponse {
    pub fn new() -> RecvBufResponse {
        ::std::default::Default::default()
    }

    // fixed64 buf_ptr = 1;


    pub fn get_buf_ptr(&self) -> u64 {
        self.buf_ptr
    }
    pub fn clear_buf_ptr(&mut self) {
        self.buf_ptr = 0;
    }

    // Param is passed by value, moved
    pub fn set_buf_ptr(&mut self, v: u64) {
        self.buf_ptr = v;
    }

    // int64 num_bytes = 2;


    pub fn get_num_bytes(&self) -> i64 {
        self.num_bytes
    }
    pub fn clear_num_bytes(&mut self) {
        self.num_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_bytes(&mut self, v: i64) {
        self.num_bytes = v;
    }

    // bool is_dead = 3;


    pub fn get_is_dead(&self) -> bool {
        self.is_dead
    }
    pub fn clear_is_dead(&mut self) {
        self.is_dead = false;
    }

    // Param is passed by value, moved
    pub fn set_is_dead(&mut self, v: bool) {
        self.is_dead = v;
    }

    // .google.protobuf.Any transport_options = 4;


    pub fn get_transport_options(&self) -> &::protobuf::well_known_types::Any {
        self.transport_options.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Any as ::protobuf::Message>::default_instance())
    }
    pub fn clear_transport_options(&mut self) {
        self.transport_options.clear();
    }

    pub fn has_transport_options(&self) -> bool {
        self.transport_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_options(&mut self, v: ::protobuf::well_known_types::Any) {
        self.transport_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_transport_options(&mut self) -> &mut ::protobuf::well_known_types::Any {
        if self.transport_options.is_none() {
            self.transport_options.set_default();
        }
        self.transport_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_transport_options(&mut self) -> ::protobuf::well_known_types::Any {
        self.transport_options.take().unwrap_or_else(|| ::protobuf::well_known_types::Any::new())
    }

    // int64 send_start_micros = 5;


    pub fn get_send_start_micros(&self) -> i64 {
        self.send_start_micros
    }
    pub fn clear_send_start_micros(&mut self) {
        self.send_start_micros = 0;
    }

    // Param is passed by value, moved
    pub fn set_send_start_micros(&mut self, v: i64) {
        self.send_start_micros = v;
    }

    // bool require_ack = 6;


    pub fn get_require_ack(&self) -> bool {
        self.require_ack
    }
    pub fn clear_require_ack(&mut self) {
        self.require_ack = false;
    }

    // Param is passed by value, moved
    pub fn set_require_ack(&mut self, v: bool) {
        self.require_ack = v;
    }
}

impl ::protobuf::Message for RecvBufResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.transport_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.buf_ptr = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_bytes = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_dead = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.transport_options)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.send_start_micros = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.require_ack = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.buf_ptr != 0 {
            my_size += 9;
        }
        if self.num_bytes != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.is_dead != false {
            my_size += 2;
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.send_start_micros != 0 {
            my_size += ::protobuf::rt::value_size(5, self.send_start_micros, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.require_ack != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.buf_ptr != 0 {
            os.write_fixed64(1, self.buf_ptr)?;
        }
        if self.num_bytes != 0 {
            os.write_int64(2, self.num_bytes)?;
        }
        if self.is_dead != false {
            os.write_bool(3, self.is_dead)?;
        }
        if let Some(ref v) = self.transport_options.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.send_start_micros != 0 {
            os.write_int64(5, self.send_start_micros)?;
        }
        if self.require_ack != false {
            os.write_bool(6, self.require_ack)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecvBufResponse {
        RecvBufResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFixed64>(
                "buf_ptr",
                |m: &RecvBufResponse| { &m.buf_ptr },
                |m: &mut RecvBufResponse| { &mut m.buf_ptr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_bytes",
                |m: &RecvBufResponse| { &m.num_bytes },
                |m: &mut RecvBufResponse| { &mut m.num_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_dead",
                |m: &RecvBufResponse| { &m.is_dead },
                |m: &mut RecvBufResponse| { &mut m.is_dead },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Any>>(
                "transport_options",
                |m: &RecvBufResponse| { &m.transport_options },
                |m: &mut RecvBufResponse| { &mut m.transport_options },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "send_start_micros",
                |m: &RecvBufResponse| { &m.send_start_micros },
                |m: &mut RecvBufResponse| { &mut m.send_start_micros },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "require_ack",
                |m: &RecvBufResponse| { &m.require_ack },
                |m: &mut RecvBufResponse| { &mut m.require_ack },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecvBufResponse>(
                "RecvBufResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecvBufResponse {
        static instance: ::protobuf::rt::LazyV2<RecvBufResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecvBufResponse::new)
    }
}

impl ::protobuf::Clear for RecvBufResponse {
    fn clear(&mut self) {
        self.buf_ptr = 0;
        self.num_bytes = 0;
        self.is_dead = false;
        self.transport_options.clear();
        self.send_start_micros = 0;
        self.require_ack = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecvBufResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecvBufResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteGroupRequest {
    // message fields
    pub group_key: i32,
    pub group_size: i32,
    pub device_type: ::std::string::String,
    pub device_name: ::protobuf::RepeatedField<::std::string::String>,
    pub collective_type: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteGroupRequest {
    fn default() -> &'a CompleteGroupRequest {
        <CompleteGroupRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompleteGroupRequest {
    pub fn new() -> CompleteGroupRequest {
        ::std::default::Default::default()
    }

    // int32 group_key = 1;


    pub fn get_group_key(&self) -> i32 {
        self.group_key
    }
    pub fn clear_group_key(&mut self) {
        self.group_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_key(&mut self, v: i32) {
        self.group_key = v;
    }

    // int32 group_size = 2;


    pub fn get_group_size(&self) -> i32 {
        self.group_size
    }
    pub fn clear_group_size(&mut self) {
        self.group_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_size(&mut self, v: i32) {
        self.group_size = v;
    }

    // string device_type = 3;


    pub fn get_device_type(&self) -> &str {
        &self.device_type
    }
    pub fn clear_device_type(&mut self) {
        self.device_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_type(&mut self, v: ::std::string::String) {
        self.device_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_type(&mut self) -> &mut ::std::string::String {
        &mut self.device_type
    }

    // Take field
    pub fn take_device_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_type, ::std::string::String::new())
    }

    // repeated string device_name = 4;


    pub fn get_device_name(&self) -> &[::std::string::String] {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.device_name, ::protobuf::RepeatedField::new())
    }

    // int32 collective_type = 5;


    pub fn get_collective_type(&self) -> i32 {
        self.collective_type
    }
    pub fn clear_collective_type(&mut self) {
        self.collective_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_collective_type(&mut self, v: i32) {
        self.collective_type = v;
    }
}

impl ::protobuf::Message for CompleteGroupRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_type)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.device_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.collective_type = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.group_key != 0 {
            my_size += ::protobuf::rt::value_size(1, self.group_key, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.group_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.group_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.device_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device_type);
        }
        for value in &self.device_name {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if self.collective_type != 0 {
            my_size += ::protobuf::rt::value_size(5, self.collective_type, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.group_key != 0 {
            os.write_int32(1, self.group_key)?;
        }
        if self.group_size != 0 {
            os.write_int32(2, self.group_size)?;
        }
        if !self.device_type.is_empty() {
            os.write_string(3, &self.device_type)?;
        }
        for v in &self.device_name {
            os.write_string(4, &v)?;
        };
        if self.collective_type != 0 {
            os.write_int32(5, self.collective_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteGroupRequest {
        CompleteGroupRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_key",
                |m: &CompleteGroupRequest| { &m.group_key },
                |m: &mut CompleteGroupRequest| { &mut m.group_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_size",
                |m: &CompleteGroupRequest| { &m.group_size },
                |m: &mut CompleteGroupRequest| { &mut m.group_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_type",
                |m: &CompleteGroupRequest| { &m.device_type },
                |m: &mut CompleteGroupRequest| { &mut m.device_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &CompleteGroupRequest| { &m.device_name },
                |m: &mut CompleteGroupRequest| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "collective_type",
                |m: &CompleteGroupRequest| { &m.collective_type },
                |m: &mut CompleteGroupRequest| { &mut m.collective_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompleteGroupRequest>(
                "CompleteGroupRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompleteGroupRequest {
        static instance: ::protobuf::rt::LazyV2<CompleteGroupRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompleteGroupRequest::new)
    }
}

impl ::protobuf::Clear for CompleteGroupRequest {
    fn clear(&mut self) {
        self.group_key = 0;
        self.group_size = 0;
        self.device_type.clear();
        self.device_name.clear();
        self.collective_type = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteGroupRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteGroupRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteGroupResponse {
    // message fields
    pub group_key: i32,
    pub group_size: i32,
    pub device_type: ::std::string::String,
    pub num_tasks: i32,
    pub device_name: ::protobuf::RepeatedField<::std::string::String>,
    pub task_name: ::protobuf::RepeatedField<::std::string::String>,
    pub communicator_key: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteGroupResponse {
    fn default() -> &'a CompleteGroupResponse {
        <CompleteGroupResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompleteGroupResponse {
    pub fn new() -> CompleteGroupResponse {
        ::std::default::Default::default()
    }

    // int32 group_key = 1;


    pub fn get_group_key(&self) -> i32 {
        self.group_key
    }
    pub fn clear_group_key(&mut self) {
        self.group_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_key(&mut self, v: i32) {
        self.group_key = v;
    }

    // int32 group_size = 2;


    pub fn get_group_size(&self) -> i32 {
        self.group_size
    }
    pub fn clear_group_size(&mut self) {
        self.group_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_size(&mut self, v: i32) {
        self.group_size = v;
    }

    // string device_type = 3;


    pub fn get_device_type(&self) -> &str {
        &self.device_type
    }
    pub fn clear_device_type(&mut self) {
        self.device_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_type(&mut self, v: ::std::string::String) {
        self.device_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_type(&mut self) -> &mut ::std::string::String {
        &mut self.device_type
    }

    // Take field
    pub fn take_device_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_type, ::std::string::String::new())
    }

    // int32 num_tasks = 4;


    pub fn get_num_tasks(&self) -> i32 {
        self.num_tasks
    }
    pub fn clear_num_tasks(&mut self) {
        self.num_tasks = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_tasks(&mut self, v: i32) {
        self.num_tasks = v;
    }

    // repeated string device_name = 5;


    pub fn get_device_name(&self) -> &[::std::string::String] {
        &self.device_name
    }
    pub fn clear_device_name(&mut self) {
        self.device_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.device_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_device_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.device_name
    }

    // Take field
    pub fn take_device_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.device_name, ::protobuf::RepeatedField::new())
    }

    // repeated string task_name = 6;


    pub fn get_task_name(&self) -> &[::std::string::String] {
        &self.task_name
    }
    pub fn clear_task_name(&mut self) {
        self.task_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_task_name(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.task_name = v;
    }

    // Mutable pointer to the field.
    pub fn mut_task_name(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.task_name
    }

    // Take field
    pub fn take_task_name(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.task_name, ::protobuf::RepeatedField::new())
    }

    // bytes communicator_key = 7;


    pub fn get_communicator_key(&self) -> &[u8] {
        &self.communicator_key
    }
    pub fn clear_communicator_key(&mut self) {
        self.communicator_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_communicator_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.communicator_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_communicator_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.communicator_key
    }

    // Take field
    pub fn take_communicator_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.communicator_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CompleteGroupResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_size = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_type)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.num_tasks = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.device_name)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.task_name)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.communicator_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.group_key != 0 {
            my_size += ::protobuf::rt::value_size(1, self.group_key, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.group_size != 0 {
            my_size += ::protobuf::rt::value_size(2, self.group_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.device_type.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.device_type);
        }
        if self.num_tasks != 0 {
            my_size += ::protobuf::rt::value_size(4, self.num_tasks, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.device_name {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.task_name {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if !self.communicator_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.communicator_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.group_key != 0 {
            os.write_int32(1, self.group_key)?;
        }
        if self.group_size != 0 {
            os.write_int32(2, self.group_size)?;
        }
        if !self.device_type.is_empty() {
            os.write_string(3, &self.device_type)?;
        }
        if self.num_tasks != 0 {
            os.write_int32(4, self.num_tasks)?;
        }
        for v in &self.device_name {
            os.write_string(5, &v)?;
        };
        for v in &self.task_name {
            os.write_string(6, &v)?;
        };
        if !self.communicator_key.is_empty() {
            os.write_bytes(7, &self.communicator_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteGroupResponse {
        CompleteGroupResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_key",
                |m: &CompleteGroupResponse| { &m.group_key },
                |m: &mut CompleteGroupResponse| { &mut m.group_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_size",
                |m: &CompleteGroupResponse| { &m.group_size },
                |m: &mut CompleteGroupResponse| { &mut m.group_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_type",
                |m: &CompleteGroupResponse| { &m.device_type },
                |m: &mut CompleteGroupResponse| { &mut m.device_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "num_tasks",
                |m: &CompleteGroupResponse| { &m.num_tasks },
                |m: &mut CompleteGroupResponse| { &mut m.num_tasks },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_name",
                |m: &CompleteGroupResponse| { &m.device_name },
                |m: &mut CompleteGroupResponse| { &mut m.device_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "task_name",
                |m: &CompleteGroupResponse| { &m.task_name },
                |m: &mut CompleteGroupResponse| { &mut m.task_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "communicator_key",
                |m: &CompleteGroupResponse| { &m.communicator_key },
                |m: &mut CompleteGroupResponse| { &mut m.communicator_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompleteGroupResponse>(
                "CompleteGroupResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompleteGroupResponse {
        static instance: ::protobuf::rt::LazyV2<CompleteGroupResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompleteGroupResponse::new)
    }
}

impl ::protobuf::Clear for CompleteGroupResponse {
    fn clear(&mut self) {
        self.group_key = 0;
        self.group_size = 0;
        self.device_type.clear();
        self.num_tasks = 0;
        self.device_name.clear();
        self.task_name.clear();
        self.communicator_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteGroupResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteGroupResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteInstanceRequest {
    // message fields
    pub name: ::std::string::String,
    pub field_type: i32,
    pub data_type: super::types::DataType,
    pub shape: ::protobuf::SingularPtrField<super::tensor_shape::TensorShapeProto>,
    pub group_key: i32,
    pub group_size: i32,
    pub instance_key: i32,
    pub device_type: ::std::string::String,
    pub subdiv_offset: ::std::vec::Vec<i32>,
    pub device: ::std::string::String,
    pub is_source: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteInstanceRequest {
    fn default() -> &'a CompleteInstanceRequest {
        <CompleteInstanceRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompleteInstanceRequest {
    pub fn new() -> CompleteInstanceRequest {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // int32 type = 2;


    pub fn get_field_type(&self) -> i32 {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = 0;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: i32) {
        self.field_type = v;
    }

    // .tensorflow.DataType data_type = 3;


    pub fn get_data_type(&self) -> super::types::DataType {
        self.data_type
    }
    pub fn clear_data_type(&mut self) {
        self.data_type = super::types::DataType::DT_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_data_type(&mut self, v: super::types::DataType) {
        self.data_type = v;
    }

    // .tensorflow.TensorShapeProto shape = 4;


    pub fn get_shape(&self) -> &super::tensor_shape::TensorShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <super::tensor_shape::TensorShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: super::tensor_shape::TensorShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut super::tensor_shape::TensorShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> super::tensor_shape::TensorShapeProto {
        self.shape.take().unwrap_or_else(|| super::tensor_shape::TensorShapeProto::new())
    }

    // int32 group_key = 5;


    pub fn get_group_key(&self) -> i32 {
        self.group_key
    }
    pub fn clear_group_key(&mut self) {
        self.group_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_key(&mut self, v: i32) {
        self.group_key = v;
    }

    // int32 group_size = 6;


    pub fn get_group_size(&self) -> i32 {
        self.group_size
    }
    pub fn clear_group_size(&mut self) {
        self.group_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_group_size(&mut self, v: i32) {
        self.group_size = v;
    }

    // int32 instance_key = 7;


    pub fn get_instance_key(&self) -> i32 {
        self.instance_key
    }
    pub fn clear_instance_key(&mut self) {
        self.instance_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_instance_key(&mut self, v: i32) {
        self.instance_key = v;
    }

    // string device_type = 8;


    pub fn get_device_type(&self) -> &str {
        &self.device_type
    }
    pub fn clear_device_type(&mut self) {
        self.device_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_device_type(&mut self, v: ::std::string::String) {
        self.device_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device_type(&mut self) -> &mut ::std::string::String {
        &mut self.device_type
    }

    // Take field
    pub fn take_device_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device_type, ::std::string::String::new())
    }

    // repeated int32 subdiv_offset = 9;


    pub fn get_subdiv_offset(&self) -> &[i32] {
        &self.subdiv_offset
    }
    pub fn clear_subdiv_offset(&mut self) {
        self.subdiv_offset.clear();
    }

    // Param is passed by value, moved
    pub fn set_subdiv_offset(&mut self, v: ::std::vec::Vec<i32>) {
        self.subdiv_offset = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subdiv_offset(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.subdiv_offset
    }

    // Take field
    pub fn take_subdiv_offset(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.subdiv_offset, ::std::vec::Vec::new())
    }

    // string device = 10;


    pub fn get_device(&self) -> &str {
        &self.device
    }
    pub fn clear_device(&mut self) {
        self.device.clear();
    }

    // Param is passed by value, moved
    pub fn set_device(&mut self, v: ::std::string::String) {
        self.device = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_device(&mut self) -> &mut ::std::string::String {
        &mut self.device
    }

    // Take field
    pub fn take_device(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.device, ::std::string::String::new())
    }

    // bool is_source = 11;


    pub fn get_is_source(&self) -> bool {
        self.is_source
    }
    pub fn clear_is_source(&mut self) {
        self.is_source = false;
    }

    // Param is passed by value, moved
    pub fn set_is_source(&mut self, v: bool) {
        self.is_source = v;
    }
}

impl ::protobuf::Message for CompleteInstanceRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.field_type = tmp;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.data_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_key = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.group_size = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instance_key = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device_type)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.subdiv_offset)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.device)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_source = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.field_type != 0 {
            my_size += ::protobuf::rt::value_size(2, self.field_type, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.data_type != super::types::DataType::DT_INVALID {
            my_size += ::protobuf::rt::enum_size(3, self.data_type);
        }
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.group_key != 0 {
            my_size += ::protobuf::rt::value_size(5, self.group_key, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.group_size != 0 {
            my_size += ::protobuf::rt::value_size(6, self.group_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.instance_key != 0 {
            my_size += ::protobuf::rt::value_size(7, self.instance_key, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.device_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_type);
        }
        for value in &self.subdiv_offset {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if !self.device.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.device);
        }
        if self.is_source != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.field_type != 0 {
            os.write_int32(2, self.field_type)?;
        }
        if self.data_type != super::types::DataType::DT_INVALID {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.data_type))?;
        }
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.group_key != 0 {
            os.write_int32(5, self.group_key)?;
        }
        if self.group_size != 0 {
            os.write_int32(6, self.group_size)?;
        }
        if self.instance_key != 0 {
            os.write_int32(7, self.instance_key)?;
        }
        if !self.device_type.is_empty() {
            os.write_string(8, &self.device_type)?;
        }
        for v in &self.subdiv_offset {
            os.write_int32(9, *v)?;
        };
        if !self.device.is_empty() {
            os.write_string(10, &self.device)?;
        }
        if self.is_source != false {
            os.write_bool(11, self.is_source)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteInstanceRequest {
        CompleteInstanceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CompleteInstanceRequest| { &m.name },
                |m: &mut CompleteInstanceRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "type",
                |m: &CompleteInstanceRequest| { &m.field_type },
                |m: &mut CompleteInstanceRequest| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<super::types::DataType>>(
                "data_type",
                |m: &CompleteInstanceRequest| { &m.data_type },
                |m: &mut CompleteInstanceRequest| { &mut m.data_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::tensor_shape::TensorShapeProto>>(
                "shape",
                |m: &CompleteInstanceRequest| { &m.shape },
                |m: &mut CompleteInstanceRequest| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_key",
                |m: &CompleteInstanceRequest| { &m.group_key },
                |m: &mut CompleteInstanceRequest| { &mut m.group_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "group_size",
                |m: &CompleteInstanceRequest| { &m.group_size },
                |m: &mut CompleteInstanceRequest| { &mut m.group_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "instance_key",
                |m: &CompleteInstanceRequest| { &m.instance_key },
                |m: &mut CompleteInstanceRequest| { &mut m.instance_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device_type",
                |m: &CompleteInstanceRequest| { &m.device_type },
                |m: &mut CompleteInstanceRequest| { &mut m.device_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "subdiv_offset",
                |m: &CompleteInstanceRequest| { &m.subdiv_offset },
                |m: &mut CompleteInstanceRequest| { &mut m.subdiv_offset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "device",
                |m: &CompleteInstanceRequest| { &m.device },
                |m: &mut CompleteInstanceRequest| { &mut m.device },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_source",
                |m: &CompleteInstanceRequest| { &m.is_source },
                |m: &mut CompleteInstanceRequest| { &mut m.is_source },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompleteInstanceRequest>(
                "CompleteInstanceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompleteInstanceRequest {
        static instance: ::protobuf::rt::LazyV2<CompleteInstanceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompleteInstanceRequest::new)
    }
}

impl ::protobuf::Clear for CompleteInstanceRequest {
    fn clear(&mut self) {
        self.name.clear();
        self.field_type = 0;
        self.data_type = super::types::DataType::DT_INVALID;
        self.shape.clear();
        self.group_key = 0;
        self.group_size = 0;
        self.instance_key = 0;
        self.device_type.clear();
        self.subdiv_offset.clear();
        self.device.clear();
        self.is_source = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteInstanceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteInstanceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteInstanceResponse {
    // message fields
    pub instance_key: i32,
    pub source_rank: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteInstanceResponse {
    fn default() -> &'a CompleteInstanceResponse {
        <CompleteInstanceResponse as ::protobuf::Message>::default_instance()
    }
}

impl CompleteInstanceResponse {
    pub fn new() -> CompleteInstanceResponse {
        ::std::default::Default::default()
    }

    // int32 instance_key = 1;


    pub fn get_instance_key(&self) -> i32 {
        self.instance_key
    }
    pub fn clear_instance_key(&mut self) {
        self.instance_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_instance_key(&mut self, v: i32) {
        self.instance_key = v;
    }

    // int32 source_rank = 2;


    pub fn get_source_rank(&self) -> i32 {
        self.source_rank
    }
    pub fn clear_source_rank(&mut self) {
        self.source_rank = 0;
    }

    // Param is passed by value, moved
    pub fn set_source_rank(&mut self, v: i32) {
        self.source_rank = v;
    }
}

impl ::protobuf::Message for CompleteInstanceResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.instance_key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.source_rank = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.instance_key != 0 {
            my_size += ::protobuf::rt::value_size(1, self.instance_key, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.source_rank != 0 {
            my_size += ::protobuf::rt::value_size(2, self.source_rank, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.instance_key != 0 {
            os.write_int32(1, self.instance_key)?;
        }
        if self.source_rank != 0 {
            os.write_int32(2, self.source_rank)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteInstanceResponse {
        CompleteInstanceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "instance_key",
                |m: &CompleteInstanceResponse| { &m.instance_key },
                |m: &mut CompleteInstanceResponse| { &mut m.instance_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "source_rank",
                |m: &CompleteInstanceResponse| { &m.source_rank },
                |m: &mut CompleteInstanceResponse| { &mut m.source_rank },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompleteInstanceResponse>(
                "CompleteInstanceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompleteInstanceResponse {
        static instance: ::protobuf::rt::LazyV2<CompleteInstanceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompleteInstanceResponse::new)
    }
}

impl ::protobuf::Clear for CompleteInstanceResponse {
    fn clear(&mut self) {
        self.instance_key = 0;
        self.source_rank = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteInstanceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteInstanceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStepSequenceRequest {
    // message fields
    pub graph_key: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStepSequenceRequest {
    fn default() -> &'a GetStepSequenceRequest {
        <GetStepSequenceRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetStepSequenceRequest {
    pub fn new() -> GetStepSequenceRequest {
        ::std::default::Default::default()
    }

    // repeated int64 graph_key = 1;


    pub fn get_graph_key(&self) -> &[i64] {
        &self.graph_key
    }
    pub fn clear_graph_key(&mut self) {
        self.graph_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_graph_key(&mut self, v: ::std::vec::Vec<i64>) {
        self.graph_key = v;
    }

    // Mutable pointer to the field.
    pub fn mut_graph_key(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.graph_key
    }

    // Take field
    pub fn take_graph_key(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.graph_key, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for GetStepSequenceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.graph_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.graph_key {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.graph_key {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStepSequenceRequest {
        GetStepSequenceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "graph_key",
                |m: &GetStepSequenceRequest| { &m.graph_key },
                |m: &mut GetStepSequenceRequest| { &mut m.graph_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStepSequenceRequest>(
                "GetStepSequenceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStepSequenceRequest {
        static instance: ::protobuf::rt::LazyV2<GetStepSequenceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStepSequenceRequest::new)
    }
}

impl ::protobuf::Clear for GetStepSequenceRequest {
    fn clear(&mut self) {
        self.graph_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStepSequenceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStepSequenceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StepSequence {
    // message fields
    pub graph_key: i64,
    pub next_step_id: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StepSequence {
    fn default() -> &'a StepSequence {
        <StepSequence as ::protobuf::Message>::default_instance()
    }
}

impl StepSequence {
    pub fn new() -> StepSequence {
        ::std::default::Default::default()
    }

    // int64 graph_key = 1;


    pub fn get_graph_key(&self) -> i64 {
        self.graph_key
    }
    pub fn clear_graph_key(&mut self) {
        self.graph_key = 0;
    }

    // Param is passed by value, moved
    pub fn set_graph_key(&mut self, v: i64) {
        self.graph_key = v;
    }

    // int64 next_step_id = 2;


    pub fn get_next_step_id(&self) -> i64 {
        self.next_step_id
    }
    pub fn clear_next_step_id(&mut self) {
        self.next_step_id = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_step_id(&mut self, v: i64) {
        self.next_step_id = v;
    }
}

impl ::protobuf::Message for StepSequence {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.graph_key = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_step_id = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.graph_key != 0 {
            my_size += ::protobuf::rt::value_size(1, self.graph_key, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next_step_id != 0 {
            my_size += ::protobuf::rt::value_size(2, self.next_step_id, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.graph_key != 0 {
            os.write_int64(1, self.graph_key)?;
        }
        if self.next_step_id != 0 {
            os.write_int64(2, self.next_step_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StepSequence {
        StepSequence::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "graph_key",
                |m: &StepSequence| { &m.graph_key },
                |m: &mut StepSequence| { &mut m.graph_key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "next_step_id",
                |m: &StepSequence| { &m.next_step_id },
                |m: &mut StepSequence| { &mut m.next_step_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StepSequence>(
                "StepSequence",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StepSequence {
        static instance: ::protobuf::rt::LazyV2<StepSequence> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StepSequence::new)
    }
}

impl ::protobuf::Clear for StepSequence {
    fn clear(&mut self) {
        self.graph_key = 0;
        self.next_step_id = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StepSequence {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StepSequence {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetStepSequenceResponse {
    // message fields
    pub step_sequence: ::protobuf::RepeatedField<StepSequence>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetStepSequenceResponse {
    fn default() -> &'a GetStepSequenceResponse {
        <GetStepSequenceResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetStepSequenceResponse {
    pub fn new() -> GetStepSequenceResponse {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.StepSequence step_sequence = 1;


    pub fn get_step_sequence(&self) -> &[StepSequence] {
        &self.step_sequence
    }
    pub fn clear_step_sequence(&mut self) {
        self.step_sequence.clear();
    }

    // Param is passed by value, moved
    pub fn set_step_sequence(&mut self, v: ::protobuf::RepeatedField<StepSequence>) {
        self.step_sequence = v;
    }

    // Mutable pointer to the field.
    pub fn mut_step_sequence(&mut self) -> &mut ::protobuf::RepeatedField<StepSequence> {
        &mut self.step_sequence
    }

    // Take field
    pub fn take_step_sequence(&mut self) -> ::protobuf::RepeatedField<StepSequence> {
        ::std::mem::replace(&mut self.step_sequence, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetStepSequenceResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.step_sequence {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.step_sequence)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.step_sequence {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.step_sequence {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetStepSequenceResponse {
        GetStepSequenceResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StepSequence>>(
                "step_sequence",
                |m: &GetStepSequenceResponse| { &m.step_sequence },
                |m: &mut GetStepSequenceResponse| { &mut m.step_sequence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetStepSequenceResponse>(
                "GetStepSequenceResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetStepSequenceResponse {
        static instance: ::protobuf::rt::LazyV2<GetStepSequenceResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetStepSequenceResponse::new)
    }
}

impl ::protobuf::Clear for GetStepSequenceResponse {
    fn clear(&mut self) {
        self.step_sequence.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetStepSequenceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetStepSequenceResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n%tensorflow/core/protobuf/worker.proto\x12\ntensorflow\x1a\x19google/p\
    rotobuf/any.proto\x1a*tensorflow/core/framework/cost_graph.proto\x1a1ten\
    sorflow/core/framework/device_attributes.proto\x1a%tensorflow/core/frame\
    work/graph.proto\x1a*tensorflow/core/framework/step_stats.proto\x1a&tens\
    orflow/core/framework/tensor.proto\x1a,tensorflow/core/framework/tensor_\
    shape.proto\x1a%tensorflow/core/framework/types.proto\x1a*tensorflow/cor\
    e/lib/core/error_codes.proto\x1a%tensorflow/core/protobuf/config.proto\
    \x1a$tensorflow/core/protobuf/debug.proto\x1a+tensorflow/core/protobuf/n\
    amed_tensor.proto\x1a0tensorflow/core/protobuf/tensorflow_server.proto\"\
    \x12\n\x10GetStatusRequest\"^\n\x11GetStatusResponse\x12I\n\x11device_at\
    tributes\x18\x01\x20\x03(\x0b2\x1c.tensorflow.DeviceAttributesR\x10devic\
    eAttributes\"\x87\x02\n\x1aCreateWorkerSessionRequest\x12%\n\x0esession_\
    handle\x18\x01\x20\x01(\tR\rsessionHandle\x124\n\nserver_def\x18\x02\x20\
    \x01(\x0b2\x15.tensorflow.ServerDefR\tserverDef\x122\n\x15isolate_sessio\
    n_state\x18\x03\x20\x01(\x08R\x13isolateSessionState\x12X\n\x19cluster_d\
    evice_attributes\x18\x04\x20\x03(\x0b2\x1c.tensorflow.DeviceAttributesR\
    \x17clusterDeviceAttributes\"\x1d\n\x1bCreateWorkerSessionResponse\"C\n\
    \x1aDeleteWorkerSessionRequest\x12%\n\x0esession_handle\x18\x01\x20\x01(\
    \tR\rsessionHandle\"\x1d\n\x1bDeleteWorkerSessionResponse\"\x8f\x03\n\
    \x14RegisterGraphRequest\x12%\n\x0esession_handle\x18\x01\x20\x01(\tR\rs\
    essionHandle\x12?\n\x1ccreate_worker_session_called\x18\x06\x20\x01(\x08\
    R\x19createWorkerSessionCalled\x121\n\tgraph_def\x18\x02\x20\x01(\x0b2\
    \x14.tensorflow.GraphDefR\x08graphDef\x12,\n\x10has_control_flow\x18\x03\
    \x20\x01(\x08R\x0ehasControlFlowB\x02\x18\x01\x12=\n\rgraph_options\x18\
    \x04\x20\x01(\x0b2\x18.tensorflow.GraphOptionsR\x0cgraphOptions\x12=\n\r\
    debug_options\x18\x05\x20\x01(\x0b2\x18.tensorflow.DebugOptionsR\x0cdebu\
    gOptions\x120\n\x14collective_graph_key\x18\x07\x20\x01(\x03R\x12collect\
    iveGraphKey\":\n\x15RegisterGraphResponse\x12!\n\x0cgraph_handle\x18\x01\
    \x20\x01(\tR\x0bgraphHandle\"\xa3\x01\n\x16DeregisterGraphRequest\x12%\n\
    \x0esession_handle\x18\x02\x20\x01(\tR\rsessionHandle\x12?\n\x1ccreate_w\
    orker_session_called\x18\x03\x20\x01(\x08R\x19createWorkerSessionCalled\
    \x12!\n\x0cgraph_handle\x18\x01\x20\x01(\tR\x0bgraphHandle\"\x19\n\x17De\
    registerGraphResponse\"1\n\x11CleanupAllRequest\x12\x1c\n\tcontainer\x18\
    \x01\x20\x03(\tR\tcontainer\"\x14\n\x12CleanupAllResponse\"\xde\x01\n\
    \x0cExecutorOpts\x12!\n\x0crecord_costs\x18\x01\x20\x01(\x08R\x0brecordC\
    osts\x12'\n\x0frecord_timeline\x18\x03\x20\x01(\x08R\x0erecordTimeline\
    \x126\n\x17record_partition_graphs\x18\x04\x20\x01(\x08R\x15recordPartit\
    ionGraphs\x12J\n\"report_tensor_allocations_upon_oom\x18\x05\x20\x01(\
    \x08R\x1ereportTensorAllocationsUponOom\"\xe8\x03\n\x0fRunGraphRequest\
    \x12%\n\x0esession_handle\x18\x08\x20\x01(\tR\rsessionHandle\x12?\n\x1cc\
    reate_worker_session_called\x18\n\x20\x01(\x08R\x19createWorkerSessionCa\
    lled\x12!\n\x0cgraph_handle\x18\x01\x20\x01(\tR\x0bgraphHandle\x12\x17\n\
    \x07step_id\x18\x02\x20\x01(\x03R\x06stepId\x125\n\texec_opts\x18\x05\
    \x20\x01(\x0b2\x18.tensorflow.ExecutorOptsR\x08execOpts\x120\n\x04send\
    \x18\x03\x20\x03(\x0b2\x1c.tensorflow.NamedTensorProtoR\x04send\x12\x19\
    \n\x08recv_key\x18\x04\x20\x03(\tR\x07recvKey\x12\x1d\n\nis_partial\x18\
    \x06\x20\x01(\x08R\tisPartial\x12-\n\x13is_last_partial_run\x18\x07\x20\
    \x01(\x08R\x10isLastPartialRun\x12@\n\x1dstore_errors_in_response_body\
    \x18\t\x20\x01(\x08R\x19storeErrorsInResponseBody\x12\x1d\n\nrequest_id\
    \x18\x0b\x20\x01(\x03R\trequestId\"\xdd\x02\n\x10RunGraphResponse\x120\n\
    \x04recv\x18\x01\x20\x03(\x0b2\x1c.tensorflow.NamedTensorProtoR\x04recv\
    \x124\n\nstep_stats\x18\x02\x20\x01(\x0b2\x15.tensorflow.StepStatsR\tste\
    pStats\x127\n\ncost_graph\x18\x03\x20\x01(\x0b2\x18.tensorflow.CostGraph\
    DefR\tcostGraph\x12=\n\x0fpartition_graph\x18\x04\x20\x03(\x0b2\x14.tens\
    orflow.GraphDefR\x0epartitionGraph\x127\n\x0bstatus_code\x18\x05\x20\x01\
    (\x0e2\x16.tensorflow.error.CodeR\nstatusCode\x120\n\x14status_error_mes\
    sage\x18\x06\x20\x01(\tR\x12statusErrorMessage\".\n\x13CleanupGraphReque\
    st\x12\x17\n\x07step_id\x18\x01\x20\x01(\x03R\x06stepId\"\x16\n\x14Clean\
    upGraphResponse\"\xd6\x02\n\x11RecvTensorRequest\x12\x17\n\x07step_id\
    \x18\x01\x20\x01(\x03R\x06stepId\x12%\n\x0erendezvous_key\x18\x02\x20\
    \x01(\tR\rrendezvousKey\x12\x15\n\x06dma_ok\x18\x03\x20\x01(\x08R\x05dma\
    Ok\x12C\n\x0fclient_locality\x18\x04\x20\x01(\x0b2\x1a.tensorflow.Device\
    LocalityR\x0eclientLocality\x12C\n\x0fserver_locality\x18\x05\x20\x01(\
    \x0b2\x1a.tensorflow.DeviceLocalityR\x0eserverLocality\x12A\n\x11transpo\
    rt_options\x18\x06\x20\x01(\x0b2\x14.google.protobuf.AnyR\x10transportOp\
    tions\x12\x1d\n\nrequest_id\x18\x07\x20\x01(\x03R\trequestId\"\xee\x01\n\
    \x12RecvTensorResponse\x12/\n\x06tensor\x18\x01\x20\x01(\x0b2\x17.tensor\
    flow.TensorProtoR\x06tensor\x12\x17\n\x07is_dead\x18\x02\x20\x01(\x08R\
    \x06isDead\x12*\n\x11send_start_micros\x18\x03\x20\x01(\x03R\x0fsendStar\
    tMicros\x12A\n\x11transport_options\x18\x04\x20\x01(\x0b2\x14.google.pro\
    tobuf.AnyR\x10transportOptions\x12\x1f\n\x0brequire_ack\x18\x05\x20\x01(\
    \x08R\nrequireAck\"8\n\x17MarkRecvFinishedRequest\x12\x1d\n\nrequest_id\
    \x18\x01\x20\x01(\x03R\trequestId\"\x1a\n\x18MarkRecvFinishedResponse\"\
    \xa8\x01\n\x0eLoggingRequest\x12,\n\x12enable_rpc_logging\x18\x01\x20\
    \x01(\x08R\x10enableRpcLogging\x12.\n\x13disable_rpc_logging\x18\x04\x20\
    \x01(\x08R\x11disableRpcLogging\x12\x14\n\x05clear\x18\x02\x20\x01(\x08R\
    \x05clear\x12\"\n\rfetch_step_id\x18\x03\x20\x03(\x03R\x0bfetchStepId\"a\
    \n\x10LabeledStepStats\x12\x17\n\x07step_id\x18\x01\x20\x01(\x03R\x06ste\
    pId\x124\n\nstep_stats\x18\x02\x20\x01(\x0b2\x15.tensorflow.StepStatsR\t\
    stepStats\"C\n\x0fLoggingResponse\x120\n\x04step\x18\x01\x20\x03(\x0b2\
    \x1c.tensorflow.LabeledStepStatsR\x04step\"\x91\x02\n\tTraceOpts\x12\x1a\
    \n\x08duration\x18\x01\x20\x01(\x01R\x08duration\x12*\n\x11use_step_prof\
    iler\x18\x02\x20\x01(\x08R\x0fuseStepProfiler\x12.\n\x13use_kernel_profi\
    ler\x18\x03\x20\x01(\x08R\x11useKernelProfiler\x122\n\x15use_extended_pr\
    ofiler\x18\x04\x20\x01(\x08R\x13useExtendedProfiler\x12(\n\x10use_gpu_pr\
    ofiler\x18\x05\x20\x01(\x08R\x0euseGpuProfiler\x12.\n\x13use_sample_prof\
    iler\x18\x06\x20\x01(\x08R\x11useSampleProfiler\"A\n\x0eTracingRequest\
    \x12/\n\x07options\x18\x01\x20\x01(\x0b2\x15.tensorflow.TraceOptsR\x07op\
    tions\"\x11\n\x0fTracingResponse\"\xe0\x03\n\x0eRecvBufRequest\x12\x17\n\
    \x07step_id\x18\x01\x20\x01(\x03R\x06stepId\x12,\n\x12buf_rendezvous_key\
    \x18\x02\x20\x01(\tR\x10bufRendezvousKey\x12\x1b\n\tnum_bytes\x18\x03\
    \x20\x01(\x03R\x08numBytes\x12\x17\n\x07buf_ptr\x18\x04\x20\x01(\x06R\
    \x06bufPtr\x12C\n\x0fclient_locality\x18\x05\x20\x01(\x0b2\x1a.tensorflo\
    w.DeviceLocalityR\x0eclientLocality\x12C\n\x0fserver_locality\x18\x06\
    \x20\x01(\x0b2\x1a.tensorflow.DeviceLocalityR\x0eserverLocality\x12A\n\
    \x11transport_options\x18\x07\x20\x01(\x0b2\x14.google.protobuf.AnyR\x10\
    transportOptions\x12\x1d\n\nsrc_device\x18\x08\x20\x01(\tR\tsrcDevice\
    \x12\x1d\n\ndst_device\x18\t\x20\x01(\tR\tdstDevice\x12\x1d\n\nrequest_i\
    d\x18\n\x20\x01(\x03R\trequestId\x12'\n\x0fsrc_incarnation\x18\x0b\x20\
    \x01(\x04R\x0esrcIncarnation\"\xf0\x01\n\x0fRecvBufResponse\x12\x17\n\
    \x07buf_ptr\x18\x01\x20\x01(\x06R\x06bufPtr\x12\x1b\n\tnum_bytes\x18\x02\
    \x20\x01(\x03R\x08numBytes\x12\x17\n\x07is_dead\x18\x03\x20\x01(\x08R\
    \x06isDead\x12A\n\x11transport_options\x18\x04\x20\x01(\x0b2\x14.google.\
    protobuf.AnyR\x10transportOptions\x12*\n\x11send_start_micros\x18\x05\
    \x20\x01(\x03R\x0fsendStartMicros\x12\x1f\n\x0brequire_ack\x18\x06\x20\
    \x01(\x08R\nrequireAck\"\xbd\x01\n\x14CompleteGroupRequest\x12\x1b\n\tgr\
    oup_key\x18\x01\x20\x01(\x05R\x08groupKey\x12\x1d\n\ngroup_size\x18\x02\
    \x20\x01(\x05R\tgroupSize\x12\x1f\n\x0bdevice_type\x18\x03\x20\x01(\tR\n\
    deviceType\x12\x1f\n\x0bdevice_name\x18\x04\x20\x03(\tR\ndeviceName\x12'\
    \n\x0fcollective_type\x18\x05\x20\x01(\x05R\x0ecollectiveType\"\xfa\x01\
    \n\x15CompleteGroupResponse\x12\x1b\n\tgroup_key\x18\x01\x20\x01(\x05R\
    \x08groupKey\x12\x1d\n\ngroup_size\x18\x02\x20\x01(\x05R\tgroupSize\x12\
    \x1f\n\x0bdevice_type\x18\x03\x20\x01(\tR\ndeviceType\x12\x1b\n\tnum_tas\
    ks\x18\x04\x20\x01(\x05R\x08numTasks\x12\x1f\n\x0bdevice_name\x18\x05\
    \x20\x03(\tR\ndeviceName\x12\x1b\n\ttask_name\x18\x06\x20\x03(\tR\x08tas\
    kName\x12)\n\x10communicator_key\x18\x07\x20\x01(\x0cR\x0fcommunicatorKe\
    y\"\x82\x03\n\x17CompleteInstanceRequest\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x12\n\x04type\x18\x02\x20\x01(\x05R\x04type\x121\n\
    \tdata_type\x18\x03\x20\x01(\x0e2\x14.tensorflow.DataTypeR\x08dataType\
    \x122\n\x05shape\x18\x04\x20\x01(\x0b2\x1c.tensorflow.TensorShapeProtoR\
    \x05shape\x12\x1b\n\tgroup_key\x18\x05\x20\x01(\x05R\x08groupKey\x12\x1d\
    \n\ngroup_size\x18\x06\x20\x01(\x05R\tgroupSize\x12!\n\x0cinstance_key\
    \x18\x07\x20\x01(\x05R\x0binstanceKey\x12\x1f\n\x0bdevice_type\x18\x08\
    \x20\x01(\tR\ndeviceType\x12#\n\rsubdiv_offset\x18\t\x20\x03(\x05R\x0csu\
    bdivOffset\x12\x16\n\x06device\x18\n\x20\x01(\tR\x06device\x12\x1b\n\tis\
    _source\x18\x0b\x20\x01(\x08R\x08isSource\"d\n\x18CompleteInstanceRespon\
    se\x12!\n\x0cinstance_key\x18\x01\x20\x01(\x05R\x0binstanceKey\x12\x1f\n\
    \x0bsource_rank\x18\x02\x20\x01(\x05R\nsourceRankJ\x04\x08\x03\x10\x04\"\
    5\n\x16GetStepSequenceRequest\x12\x1b\n\tgraph_key\x18\x01\x20\x03(\x03R\
    \x08graphKey\"M\n\x0cStepSequence\x12\x1b\n\tgraph_key\x18\x01\x20\x01(\
    \x03R\x08graphKey\x12\x20\n\x0cnext_step_id\x18\x02\x20\x01(\x03R\nnextS\
    tepId\"X\n\x17GetStepSequenceResponse\x12=\n\rstep_sequence\x18\x01\x20\
    \x03(\x0b2\x18.tensorflow.StepSequenceR\x0cstepSequenceBm\n\x1aorg.tenso\
    rflow.distruntimeB\x0cWorkerProtosP\x01Z<github.com/tensorflow/tensorflo\
    w/tensorflow/go/core/protobuf\xf8\x01\x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
