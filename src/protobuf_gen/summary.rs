// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/core/framework/summary.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct SummaryDescription {
    // message fields
    pub type_hint: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SummaryDescription {
    fn default() -> &'a SummaryDescription {
        <SummaryDescription as ::protobuf::Message>::default_instance()
    }
}

impl SummaryDescription {
    pub fn new() -> SummaryDescription {
        ::std::default::Default::default()
    }

    // string type_hint = 1;


    pub fn get_type_hint(&self) -> &str {
        &self.type_hint
    }
    pub fn clear_type_hint(&mut self) {
        self.type_hint.clear();
    }

    // Param is passed by value, moved
    pub fn set_type_hint(&mut self, v: ::std::string::String) {
        self.type_hint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_type_hint(&mut self) -> &mut ::std::string::String {
        &mut self.type_hint
    }

    // Take field
    pub fn take_type_hint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.type_hint, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SummaryDescription {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.type_hint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.type_hint.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.type_hint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.type_hint.is_empty() {
            os.write_string(1, &self.type_hint)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SummaryDescription {
        SummaryDescription::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type_hint",
                |m: &SummaryDescription| { &m.type_hint },
                |m: &mut SummaryDescription| { &mut m.type_hint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SummaryDescription>(
                "SummaryDescription",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SummaryDescription {
        static instance: ::protobuf::rt::LazyV2<SummaryDescription> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SummaryDescription::new)
    }
}

impl ::protobuf::Clear for SummaryDescription {
    fn clear(&mut self) {
        self.type_hint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SummaryDescription {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SummaryDescription {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HistogramProto {
    // message fields
    pub min: f64,
    pub max: f64,
    pub num: f64,
    pub sum: f64,
    pub sum_squares: f64,
    pub bucket_limit: ::std::vec::Vec<f64>,
    pub bucket: ::std::vec::Vec<f64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HistogramProto {
    fn default() -> &'a HistogramProto {
        <HistogramProto as ::protobuf::Message>::default_instance()
    }
}

impl HistogramProto {
    pub fn new() -> HistogramProto {
        ::std::default::Default::default()
    }

    // double min = 1;


    pub fn get_min(&self) -> f64 {
        self.min
    }
    pub fn clear_min(&mut self) {
        self.min = 0.;
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: f64) {
        self.min = v;
    }

    // double max = 2;


    pub fn get_max(&self) -> f64 {
        self.max
    }
    pub fn clear_max(&mut self) {
        self.max = 0.;
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: f64) {
        self.max = v;
    }

    // double num = 3;


    pub fn get_num(&self) -> f64 {
        self.num
    }
    pub fn clear_num(&mut self) {
        self.num = 0.;
    }

    // Param is passed by value, moved
    pub fn set_num(&mut self, v: f64) {
        self.num = v;
    }

    // double sum = 4;


    pub fn get_sum(&self) -> f64 {
        self.sum
    }
    pub fn clear_sum(&mut self) {
        self.sum = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sum(&mut self, v: f64) {
        self.sum = v;
    }

    // double sum_squares = 5;


    pub fn get_sum_squares(&self) -> f64 {
        self.sum_squares
    }
    pub fn clear_sum_squares(&mut self) {
        self.sum_squares = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sum_squares(&mut self, v: f64) {
        self.sum_squares = v;
    }

    // repeated double bucket_limit = 6;


    pub fn get_bucket_limit(&self) -> &[f64] {
        &self.bucket_limit
    }
    pub fn clear_bucket_limit(&mut self) {
        self.bucket_limit.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket_limit(&mut self, v: ::std::vec::Vec<f64>) {
        self.bucket_limit = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bucket_limit(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.bucket_limit
    }

    // Take field
    pub fn take_bucket_limit(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.bucket_limit, ::std::vec::Vec::new())
    }

    // repeated double bucket = 7;


    pub fn get_bucket(&self) -> &[f64] {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::vec::Vec<f64>) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bucket(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.bucket, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HistogramProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.min = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.max = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.num = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.sum = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.sum_squares = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.bucket_limit)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.bucket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.min != 0. {
            my_size += 9;
        }
        if self.max != 0. {
            my_size += 9;
        }
        if self.num != 0. {
            my_size += 9;
        }
        if self.sum != 0. {
            my_size += 9;
        }
        if self.sum_squares != 0. {
            my_size += 9;
        }
        if !self.bucket_limit.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.bucket_limit.len() * 8) as u32) + (self.bucket_limit.len() * 8) as u32;
        }
        if !self.bucket.is_empty() {
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size((self.bucket.len() * 8) as u32) + (self.bucket.len() * 8) as u32;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.min != 0. {
            os.write_double(1, self.min)?;
        }
        if self.max != 0. {
            os.write_double(2, self.max)?;
        }
        if self.num != 0. {
            os.write_double(3, self.num)?;
        }
        if self.sum != 0. {
            os.write_double(4, self.sum)?;
        }
        if self.sum_squares != 0. {
            os.write_double(5, self.sum_squares)?;
        }
        if !self.bucket_limit.is_empty() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.bucket_limit.len() * 8) as u32)?;
            for v in &self.bucket_limit {
                os.write_double_no_tag(*v)?;
            };
        }
        if !self.bucket.is_empty() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            // TODO: Data size is computed again, it should be cached
            os.write_raw_varint32((self.bucket.len() * 8) as u32)?;
            for v in &self.bucket {
                os.write_double_no_tag(*v)?;
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HistogramProto {
        HistogramProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "min",
                |m: &HistogramProto| { &m.min },
                |m: &mut HistogramProto| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "max",
                |m: &HistogramProto| { &m.max },
                |m: &mut HistogramProto| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "num",
                |m: &HistogramProto| { &m.num },
                |m: &mut HistogramProto| { &mut m.num },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "sum",
                |m: &HistogramProto| { &m.sum },
                |m: &mut HistogramProto| { &mut m.sum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "sum_squares",
                |m: &HistogramProto| { &m.sum_squares },
                |m: &mut HistogramProto| { &mut m.sum_squares },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bucket_limit",
                |m: &HistogramProto| { &m.bucket_limit },
                |m: &mut HistogramProto| { &mut m.bucket_limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bucket",
                |m: &HistogramProto| { &m.bucket },
                |m: &mut HistogramProto| { &mut m.bucket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HistogramProto>(
                "HistogramProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HistogramProto {
        static instance: ::protobuf::rt::LazyV2<HistogramProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HistogramProto::new)
    }
}

impl ::protobuf::Clear for HistogramProto {
    fn clear(&mut self) {
        self.min = 0.;
        self.max = 0.;
        self.num = 0.;
        self.sum = 0.;
        self.sum_squares = 0.;
        self.bucket_limit.clear();
        self.bucket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HistogramProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HistogramProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SummaryMetadata {
    // message fields
    pub plugin_data: ::protobuf::SingularPtrField<SummaryMetadata_PluginData>,
    pub display_name: ::std::string::String,
    pub summary_description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SummaryMetadata {
    fn default() -> &'a SummaryMetadata {
        <SummaryMetadata as ::protobuf::Message>::default_instance()
    }
}

impl SummaryMetadata {
    pub fn new() -> SummaryMetadata {
        ::std::default::Default::default()
    }

    // .tensorflow.SummaryMetadata.PluginData plugin_data = 1;


    pub fn get_plugin_data(&self) -> &SummaryMetadata_PluginData {
        self.plugin_data.as_ref().unwrap_or_else(|| <SummaryMetadata_PluginData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_plugin_data(&mut self) {
        self.plugin_data.clear();
    }

    pub fn has_plugin_data(&self) -> bool {
        self.plugin_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_plugin_data(&mut self, v: SummaryMetadata_PluginData) {
        self.plugin_data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_data(&mut self) -> &mut SummaryMetadata_PluginData {
        if self.plugin_data.is_none() {
            self.plugin_data.set_default();
        }
        self.plugin_data.as_mut().unwrap()
    }

    // Take field
    pub fn take_plugin_data(&mut self) -> SummaryMetadata_PluginData {
        self.plugin_data.take().unwrap_or_else(|| SummaryMetadata_PluginData::new())
    }

    // string display_name = 2;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string summary_description = 3;


    pub fn get_summary_description(&self) -> &str {
        &self.summary_description
    }
    pub fn clear_summary_description(&mut self) {
        self.summary_description.clear();
    }

    // Param is passed by value, moved
    pub fn set_summary_description(&mut self, v: ::std::string::String) {
        self.summary_description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_summary_description(&mut self) -> &mut ::std::string::String {
        &mut self.summary_description
    }

    // Take field
    pub fn take_summary_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.summary_description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SummaryMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.plugin_data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.plugin_data)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.summary_description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.plugin_data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.display_name);
        }
        if !self.summary_description.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.summary_description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.plugin_data.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.display_name.is_empty() {
            os.write_string(2, &self.display_name)?;
        }
        if !self.summary_description.is_empty() {
            os.write_string(3, &self.summary_description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SummaryMetadata {
        SummaryMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SummaryMetadata_PluginData>>(
                "plugin_data",
                |m: &SummaryMetadata| { &m.plugin_data },
                |m: &mut SummaryMetadata| { &mut m.plugin_data },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &SummaryMetadata| { &m.display_name },
                |m: &mut SummaryMetadata| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "summary_description",
                |m: &SummaryMetadata| { &m.summary_description },
                |m: &mut SummaryMetadata| { &mut m.summary_description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SummaryMetadata>(
                "SummaryMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SummaryMetadata {
        static instance: ::protobuf::rt::LazyV2<SummaryMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SummaryMetadata::new)
    }
}

impl ::protobuf::Clear for SummaryMetadata {
    fn clear(&mut self) {
        self.plugin_data.clear();
        self.display_name.clear();
        self.summary_description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SummaryMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SummaryMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SummaryMetadata_PluginData {
    // message fields
    pub plugin_name: ::std::string::String,
    pub content: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SummaryMetadata_PluginData {
    fn default() -> &'a SummaryMetadata_PluginData {
        <SummaryMetadata_PluginData as ::protobuf::Message>::default_instance()
    }
}

impl SummaryMetadata_PluginData {
    pub fn new() -> SummaryMetadata_PluginData {
        ::std::default::Default::default()
    }

    // string plugin_name = 1;


    pub fn get_plugin_name(&self) -> &str {
        &self.plugin_name
    }
    pub fn clear_plugin_name(&mut self) {
        self.plugin_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_plugin_name(&mut self, v: ::std::string::String) {
        self.plugin_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_plugin_name(&mut self) -> &mut ::std::string::String {
        &mut self.plugin_name
    }

    // Take field
    pub fn take_plugin_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.plugin_name, ::std::string::String::new())
    }

    // bytes content = 2;


    pub fn get_content(&self) -> &[u8] {
        &self.content
    }
    pub fn clear_content(&mut self) {
        self.content.clear();
    }

    // Param is passed by value, moved
    pub fn set_content(&mut self, v: ::std::vec::Vec<u8>) {
        self.content = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.content
    }

    // Take field
    pub fn take_content(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.content, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SummaryMetadata_PluginData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.plugin_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.content)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.plugin_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.plugin_name);
        }
        if !self.content.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.content);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.plugin_name.is_empty() {
            os.write_string(1, &self.plugin_name)?;
        }
        if !self.content.is_empty() {
            os.write_bytes(2, &self.content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SummaryMetadata_PluginData {
        SummaryMetadata_PluginData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "plugin_name",
                |m: &SummaryMetadata_PluginData| { &m.plugin_name },
                |m: &mut SummaryMetadata_PluginData| { &mut m.plugin_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "content",
                |m: &SummaryMetadata_PluginData| { &m.content },
                |m: &mut SummaryMetadata_PluginData| { &mut m.content },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SummaryMetadata_PluginData>(
                "SummaryMetadata.PluginData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SummaryMetadata_PluginData {
        static instance: ::protobuf::rt::LazyV2<SummaryMetadata_PluginData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SummaryMetadata_PluginData::new)
    }
}

impl ::protobuf::Clear for SummaryMetadata_PluginData {
    fn clear(&mut self) {
        self.plugin_name.clear();
        self.content.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SummaryMetadata_PluginData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SummaryMetadata_PluginData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Summary {
    // message fields
    pub value: ::protobuf::RepeatedField<Summary_Value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Summary {
    fn default() -> &'a Summary {
        <Summary as ::protobuf::Message>::default_instance()
    }
}

impl Summary {
    pub fn new() -> Summary {
        ::std::default::Default::default()
    }

    // repeated .tensorflow.Summary.Value value = 1;


    pub fn get_value(&self) -> &[Summary_Value] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::protobuf::RepeatedField<Summary_Value>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    pub fn mut_value(&mut self) -> &mut ::protobuf::RepeatedField<Summary_Value> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::protobuf::RepeatedField<Summary_Value> {
        ::std::mem::replace(&mut self.value, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Summary {
    fn is_initialized(&self) -> bool {
        for v in &self.value {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.value {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.value {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Summary {
        Summary::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Summary_Value>>(
                "value",
                |m: &Summary| { &m.value },
                |m: &mut Summary| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Summary>(
                "Summary",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Summary {
        static instance: ::protobuf::rt::LazyV2<Summary> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Summary::new)
    }
}

impl ::protobuf::Clear for Summary {
    fn clear(&mut self) {
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Summary {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Summary {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Summary_Image {
    // message fields
    pub height: i32,
    pub width: i32,
    pub colorspace: i32,
    pub encoded_image_string: ::std::vec::Vec<u8>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Summary_Image {
    fn default() -> &'a Summary_Image {
        <Summary_Image as ::protobuf::Message>::default_instance()
    }
}

impl Summary_Image {
    pub fn new() -> Summary_Image {
        ::std::default::Default::default()
    }

    // int32 height = 1;


    pub fn get_height(&self) -> i32 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i32) {
        self.height = v;
    }

    // int32 width = 2;


    pub fn get_width(&self) -> i32 {
        self.width
    }
    pub fn clear_width(&mut self) {
        self.width = 0;
    }

    // Param is passed by value, moved
    pub fn set_width(&mut self, v: i32) {
        self.width = v;
    }

    // int32 colorspace = 3;


    pub fn get_colorspace(&self) -> i32 {
        self.colorspace
    }
    pub fn clear_colorspace(&mut self) {
        self.colorspace = 0;
    }

    // Param is passed by value, moved
    pub fn set_colorspace(&mut self, v: i32) {
        self.colorspace = v;
    }

    // bytes encoded_image_string = 4;


    pub fn get_encoded_image_string(&self) -> &[u8] {
        &self.encoded_image_string
    }
    pub fn clear_encoded_image_string(&mut self) {
        self.encoded_image_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_encoded_image_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.encoded_image_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_image_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encoded_image_string
    }

    // Take field
    pub fn take_encoded_image_string(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encoded_image_string, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for Summary_Image {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.height = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.width = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.colorspace = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encoded_image_string)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(1, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.width != 0 {
            my_size += ::protobuf::rt::value_size(2, self.width, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.colorspace != 0 {
            my_size += ::protobuf::rt::value_size(3, self.colorspace, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.encoded_image_string.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.encoded_image_string);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.height != 0 {
            os.write_int32(1, self.height)?;
        }
        if self.width != 0 {
            os.write_int32(2, self.width)?;
        }
        if self.colorspace != 0 {
            os.write_int32(3, self.colorspace)?;
        }
        if !self.encoded_image_string.is_empty() {
            os.write_bytes(4, &self.encoded_image_string)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Summary_Image {
        Summary_Image::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "height",
                |m: &Summary_Image| { &m.height },
                |m: &mut Summary_Image| { &mut m.height },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "width",
                |m: &Summary_Image| { &m.width },
                |m: &mut Summary_Image| { &mut m.width },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "colorspace",
                |m: &Summary_Image| { &m.colorspace },
                |m: &mut Summary_Image| { &mut m.colorspace },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encoded_image_string",
                |m: &Summary_Image| { &m.encoded_image_string },
                |m: &mut Summary_Image| { &mut m.encoded_image_string },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Summary_Image>(
                "Summary.Image",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Summary_Image {
        static instance: ::protobuf::rt::LazyV2<Summary_Image> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Summary_Image::new)
    }
}

impl ::protobuf::Clear for Summary_Image {
    fn clear(&mut self) {
        self.height = 0;
        self.width = 0;
        self.colorspace = 0;
        self.encoded_image_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Summary_Image {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Summary_Image {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Summary_Audio {
    // message fields
    pub sample_rate: f32,
    pub num_channels: i64,
    pub length_frames: i64,
    pub encoded_audio_string: ::std::vec::Vec<u8>,
    pub content_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Summary_Audio {
    fn default() -> &'a Summary_Audio {
        <Summary_Audio as ::protobuf::Message>::default_instance()
    }
}

impl Summary_Audio {
    pub fn new() -> Summary_Audio {
        ::std::default::Default::default()
    }

    // float sample_rate = 1;


    pub fn get_sample_rate(&self) -> f32 {
        self.sample_rate
    }
    pub fn clear_sample_rate(&mut self) {
        self.sample_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sample_rate(&mut self, v: f32) {
        self.sample_rate = v;
    }

    // int64 num_channels = 2;


    pub fn get_num_channels(&self) -> i64 {
        self.num_channels
    }
    pub fn clear_num_channels(&mut self) {
        self.num_channels = 0;
    }

    // Param is passed by value, moved
    pub fn set_num_channels(&mut self, v: i64) {
        self.num_channels = v;
    }

    // int64 length_frames = 3;


    pub fn get_length_frames(&self) -> i64 {
        self.length_frames
    }
    pub fn clear_length_frames(&mut self) {
        self.length_frames = 0;
    }

    // Param is passed by value, moved
    pub fn set_length_frames(&mut self, v: i64) {
        self.length_frames = v;
    }

    // bytes encoded_audio_string = 4;


    pub fn get_encoded_audio_string(&self) -> &[u8] {
        &self.encoded_audio_string
    }
    pub fn clear_encoded_audio_string(&mut self) {
        self.encoded_audio_string.clear();
    }

    // Param is passed by value, moved
    pub fn set_encoded_audio_string(&mut self, v: ::std::vec::Vec<u8>) {
        self.encoded_audio_string = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encoded_audio_string(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.encoded_audio_string
    }

    // Take field
    pub fn take_encoded_audio_string(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.encoded_audio_string, ::std::vec::Vec::new())
    }

    // string content_type = 5;


    pub fn get_content_type(&self) -> &str {
        &self.content_type
    }
    pub fn clear_content_type(&mut self) {
        self.content_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_content_type(&mut self, v: ::std::string::String) {
        self.content_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_content_type(&mut self) -> &mut ::std::string::String {
        &mut self.content_type
    }

    // Take field
    pub fn take_content_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.content_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for Summary_Audio {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_float()?;
                    self.sample_rate = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.num_channels = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.length_frames = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.encoded_audio_string)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.content_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.sample_rate != 0. {
            my_size += 5;
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::value_size(2, self.num_channels, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.length_frames != 0 {
            my_size += ::protobuf::rt::value_size(3, self.length_frames, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.encoded_audio_string.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.encoded_audio_string);
        }
        if !self.content_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.content_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.sample_rate != 0. {
            os.write_float(1, self.sample_rate)?;
        }
        if self.num_channels != 0 {
            os.write_int64(2, self.num_channels)?;
        }
        if self.length_frames != 0 {
            os.write_int64(3, self.length_frames)?;
        }
        if !self.encoded_audio_string.is_empty() {
            os.write_bytes(4, &self.encoded_audio_string)?;
        }
        if !self.content_type.is_empty() {
            os.write_string(5, &self.content_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Summary_Audio {
        Summary_Audio::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "sample_rate",
                |m: &Summary_Audio| { &m.sample_rate },
                |m: &mut Summary_Audio| { &mut m.sample_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "num_channels",
                |m: &Summary_Audio| { &m.num_channels },
                |m: &mut Summary_Audio| { &mut m.num_channels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "length_frames",
                |m: &Summary_Audio| { &m.length_frames },
                |m: &mut Summary_Audio| { &mut m.length_frames },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "encoded_audio_string",
                |m: &Summary_Audio| { &m.encoded_audio_string },
                |m: &mut Summary_Audio| { &mut m.encoded_audio_string },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "content_type",
                |m: &Summary_Audio| { &m.content_type },
                |m: &mut Summary_Audio| { &mut m.content_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Summary_Audio>(
                "Summary.Audio",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Summary_Audio {
        static instance: ::protobuf::rt::LazyV2<Summary_Audio> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Summary_Audio::new)
    }
}

impl ::protobuf::Clear for Summary_Audio {
    fn clear(&mut self) {
        self.sample_rate = 0.;
        self.num_channels = 0;
        self.length_frames = 0;
        self.encoded_audio_string.clear();
        self.content_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Summary_Audio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Summary_Audio {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Summary_Value {
    // message fields
    pub node_name: ::std::string::String,
    pub tag: ::std::string::String,
    pub metadata: ::protobuf::SingularPtrField<SummaryMetadata>,
    // message oneof groups
    pub value: ::std::option::Option<Summary_Value_oneof_value>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Summary_Value {
    fn default() -> &'a Summary_Value {
        <Summary_Value as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum Summary_Value_oneof_value {
    simple_value(f32),
    obsolete_old_style_histogram(::std::vec::Vec<u8>),
    image(Summary_Image),
    histo(HistogramProto),
    audio(Summary_Audio),
    tensor(super::tensor::TensorProto),
}

impl Summary_Value {
    pub fn new() -> Summary_Value {
        ::std::default::Default::default()
    }

    // string node_name = 7;


    pub fn get_node_name(&self) -> &str {
        &self.node_name
    }
    pub fn clear_node_name(&mut self) {
        self.node_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_name(&mut self, v: ::std::string::String) {
        self.node_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_name(&mut self) -> &mut ::std::string::String {
        &mut self.node_name
    }

    // Take field
    pub fn take_node_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_name, ::std::string::String::new())
    }

    // string tag = 1;


    pub fn get_tag(&self) -> &str {
        &self.tag
    }
    pub fn clear_tag(&mut self) {
        self.tag.clear();
    }

    // Param is passed by value, moved
    pub fn set_tag(&mut self, v: ::std::string::String) {
        self.tag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tag(&mut self) -> &mut ::std::string::String {
        &mut self.tag
    }

    // Take field
    pub fn take_tag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tag, ::std::string::String::new())
    }

    // .tensorflow.SummaryMetadata metadata = 9;


    pub fn get_metadata(&self) -> &SummaryMetadata {
        self.metadata.as_ref().unwrap_or_else(|| <SummaryMetadata as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: SummaryMetadata) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut SummaryMetadata {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> SummaryMetadata {
        self.metadata.take().unwrap_or_else(|| SummaryMetadata::new())
    }

    // float simple_value = 2;


    pub fn get_simple_value(&self) -> f32 {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::simple_value(v)) => v,
            _ => 0.,
        }
    }
    pub fn clear_simple_value(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_simple_value(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::simple_value(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_simple_value(&mut self, v: f32) {
        self.value = ::std::option::Option::Some(Summary_Value_oneof_value::simple_value(v))
    }

    // bytes obsolete_old_style_histogram = 3;


    pub fn get_obsolete_old_style_histogram(&self) -> &[u8] {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_obsolete_old_style_histogram(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_obsolete_old_style_histogram(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_obsolete_old_style_histogram(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(v))
    }

    // Mutable pointer to the field.
    pub fn mut_obsolete_old_style_histogram(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(::std::vec::Vec::new()));
        }
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_obsolete_old_style_histogram(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_obsolete_old_style_histogram() {
            match self.value.take() {
                ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }

    // .tensorflow.Summary.Image image = 4;


    pub fn get_image(&self) -> &Summary_Image {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::image(ref v)) => v,
            _ => <Summary_Image as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_image(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_image(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::image(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: Summary_Image) {
        self.value = ::std::option::Option::Some(Summary_Value_oneof_value::image(v))
    }

    // Mutable pointer to the field.
    pub fn mut_image(&mut self) -> &mut Summary_Image {
        if let ::std::option::Option::Some(Summary_Value_oneof_value::image(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Summary_Value_oneof_value::image(Summary_Image::new()));
        }
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::image(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_image(&mut self) -> Summary_Image {
        if self.has_image() {
            match self.value.take() {
                ::std::option::Option::Some(Summary_Value_oneof_value::image(v)) => v,
                _ => panic!(),
            }
        } else {
            Summary_Image::new()
        }
    }

    // .tensorflow.HistogramProto histo = 5;


    pub fn get_histo(&self) -> &HistogramProto {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::histo(ref v)) => v,
            _ => <HistogramProto as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_histo(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_histo(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::histo(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_histo(&mut self, v: HistogramProto) {
        self.value = ::std::option::Option::Some(Summary_Value_oneof_value::histo(v))
    }

    // Mutable pointer to the field.
    pub fn mut_histo(&mut self) -> &mut HistogramProto {
        if let ::std::option::Option::Some(Summary_Value_oneof_value::histo(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Summary_Value_oneof_value::histo(HistogramProto::new()));
        }
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::histo(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_histo(&mut self) -> HistogramProto {
        if self.has_histo() {
            match self.value.take() {
                ::std::option::Option::Some(Summary_Value_oneof_value::histo(v)) => v,
                _ => panic!(),
            }
        } else {
            HistogramProto::new()
        }
    }

    // .tensorflow.Summary.Audio audio = 6;


    pub fn get_audio(&self) -> &Summary_Audio {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::audio(ref v)) => v,
            _ => <Summary_Audio as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_audio(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_audio(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::audio(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_audio(&mut self, v: Summary_Audio) {
        self.value = ::std::option::Option::Some(Summary_Value_oneof_value::audio(v))
    }

    // Mutable pointer to the field.
    pub fn mut_audio(&mut self) -> &mut Summary_Audio {
        if let ::std::option::Option::Some(Summary_Value_oneof_value::audio(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Summary_Value_oneof_value::audio(Summary_Audio::new()));
        }
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::audio(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_audio(&mut self) -> Summary_Audio {
        if self.has_audio() {
            match self.value.take() {
                ::std::option::Option::Some(Summary_Value_oneof_value::audio(v)) => v,
                _ => panic!(),
            }
        } else {
            Summary_Audio::new()
        }
    }

    // .tensorflow.TensorProto tensor = 8;


    pub fn get_tensor(&self) -> &super::tensor::TensorProto {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::tensor(ref v)) => v,
            _ => <super::tensor::TensorProto as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_tensor(&mut self) {
        self.value = ::std::option::Option::None;
    }

    pub fn has_tensor(&self) -> bool {
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::tensor(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_tensor(&mut self, v: super::tensor::TensorProto) {
        self.value = ::std::option::Option::Some(Summary_Value_oneof_value::tensor(v))
    }

    // Mutable pointer to the field.
    pub fn mut_tensor(&mut self) -> &mut super::tensor::TensorProto {
        if let ::std::option::Option::Some(Summary_Value_oneof_value::tensor(_)) = self.value {
        } else {
            self.value = ::std::option::Option::Some(Summary_Value_oneof_value::tensor(super::tensor::TensorProto::new()));
        }
        match self.value {
            ::std::option::Option::Some(Summary_Value_oneof_value::tensor(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_tensor(&mut self) -> super::tensor::TensorProto {
        if self.has_tensor() {
            match self.value.take() {
                ::std::option::Option::Some(Summary_Value_oneof_value::tensor(v)) => v,
                _ => panic!(),
            }
        } else {
            super::tensor::TensorProto::new()
        }
    }
}

impl ::protobuf::Message for Summary_Value {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        if let Some(Summary_Value_oneof_value::image(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Summary_Value_oneof_value::histo(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Summary_Value_oneof_value::audio(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(Summary_Value_oneof_value::tensor(ref v)) = self.value {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_name)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tag)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Summary_Value_oneof_value::simple_value(is.read_float()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Summary_Value_oneof_value::obsolete_old_style_histogram(is.read_bytes()?));
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Summary_Value_oneof_value::image(is.read_message()?));
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Summary_Value_oneof_value::histo(is.read_message()?));
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Summary_Value_oneof_value::audio(is.read_message()?));
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.value = ::std::option::Option::Some(Summary_Value_oneof_value::tensor(is.read_message()?));
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.node_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.node_name);
        }
        if !self.tag.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.tag);
        }
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Summary_Value_oneof_value::simple_value(v) => {
                    my_size += 5;
                },
                &Summary_Value_oneof_value::obsolete_old_style_histogram(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(3, &v);
                },
                &Summary_Value_oneof_value::image(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Summary_Value_oneof_value::histo(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Summary_Value_oneof_value::audio(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &Summary_Value_oneof_value::tensor(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.node_name.is_empty() {
            os.write_string(7, &self.node_name)?;
        }
        if !self.tag.is_empty() {
            os.write_string(1, &self.tag)?;
        }
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let ::std::option::Option::Some(ref v) = self.value {
            match v {
                &Summary_Value_oneof_value::simple_value(v) => {
                    os.write_float(2, v)?;
                },
                &Summary_Value_oneof_value::obsolete_old_style_histogram(ref v) => {
                    os.write_bytes(3, v)?;
                },
                &Summary_Value_oneof_value::image(ref v) => {
                    os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Summary_Value_oneof_value::histo(ref v) => {
                    os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Summary_Value_oneof_value::audio(ref v) => {
                    os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &Summary_Value_oneof_value::tensor(ref v) => {
                    os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Summary_Value {
        Summary_Value::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_name",
                |m: &Summary_Value| { &m.node_name },
                |m: &mut Summary_Value| { &mut m.node_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tag",
                |m: &Summary_Value| { &m.tag },
                |m: &mut Summary_Value| { &mut m.tag },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SummaryMetadata>>(
                "metadata",
                |m: &Summary_Value| { &m.metadata },
                |m: &mut Summary_Value| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_f32_accessor::<_>(
                "simple_value",
                Summary_Value::has_simple_value,
                Summary_Value::get_simple_value,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "obsolete_old_style_histogram",
                Summary_Value::has_obsolete_old_style_histogram,
                Summary_Value::get_obsolete_old_style_histogram,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Summary_Image>(
                "image",
                Summary_Value::has_image,
                Summary_Value::get_image,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, HistogramProto>(
                "histo",
                Summary_Value::has_histo,
                Summary_Value::get_histo,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, Summary_Audio>(
                "audio",
                Summary_Value::has_audio,
                Summary_Value::get_audio,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, super::tensor::TensorProto>(
                "tensor",
                Summary_Value::has_tensor,
                Summary_Value::get_tensor,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Summary_Value>(
                "Summary.Value",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Summary_Value {
        static instance: ::protobuf::rt::LazyV2<Summary_Value> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Summary_Value::new)
    }
}

impl ::protobuf::Clear for Summary_Value {
    fn clear(&mut self) {
        self.node_name.clear();
        self.tag.clear();
        self.metadata.clear();
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.value = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Summary_Value {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Summary_Value {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n'tensorflow/core/framework/summary.proto\x12\ntensorflow\x1a&tensorflo\
    w/core/framework/tensor.proto\"1\n\x12SummaryDescription\x12\x1b\n\ttype\
    _hint\x18\x01\x20\x01(\tR\x08typeHint\"\xbc\x01\n\x0eHistogramProto\x12\
    \x10\n\x03min\x18\x01\x20\x01(\x01R\x03min\x12\x10\n\x03max\x18\x02\x20\
    \x01(\x01R\x03max\x12\x10\n\x03num\x18\x03\x20\x01(\x01R\x03num\x12\x10\
    \n\x03sum\x18\x04\x20\x01(\x01R\x03sum\x12\x1f\n\x0bsum_squares\x18\x05\
    \x20\x01(\x01R\nsumSquares\x12%\n\x0cbucket_limit\x18\x06\x20\x03(\x01R\
    \x0bbucketLimitB\x02\x10\x01\x12\x1a\n\x06bucket\x18\x07\x20\x03(\x01R\
    \x06bucketB\x02\x10\x01\"\xf7\x01\n\x0fSummaryMetadata\x12G\n\x0bplugin_\
    data\x18\x01\x20\x01(\x0b2&.tensorflow.SummaryMetadata.PluginDataR\nplug\
    inData\x12!\n\x0cdisplay_name\x18\x02\x20\x01(\tR\x0bdisplayName\x12/\n\
    \x13summary_description\x18\x03\x20\x01(\tR\x12summaryDescription\x1aG\n\
    \nPluginData\x12\x1f\n\x0bplugin_name\x18\x01\x20\x01(\tR\npluginName\
    \x12\x18\n\x07content\x18\x02\x20\x01(\x0cR\x07content\"\xbc\x06\n\x07Su\
    mmary\x12/\n\x05value\x18\x01\x20\x03(\x0b2\x19.tensorflow.Summary.Value\
    R\x05value\x1a\x87\x01\n\x05Image\x12\x16\n\x06height\x18\x01\x20\x01(\
    \x05R\x06height\x12\x14\n\x05width\x18\x02\x20\x01(\x05R\x05width\x12\
    \x1e\n\ncolorspace\x18\x03\x20\x01(\x05R\ncolorspace\x120\n\x14encoded_i\
    mage_string\x18\x04\x20\x01(\x0cR\x12encodedImageString\x1a\xc5\x01\n\
    \x05Audio\x12\x1f\n\x0bsample_rate\x18\x01\x20\x01(\x02R\nsampleRate\x12\
    !\n\x0cnum_channels\x18\x02\x20\x01(\x03R\x0bnumChannels\x12#\n\rlength_\
    frames\x18\x03\x20\x01(\x03R\x0clengthFrames\x120\n\x14encoded_audio_str\
    ing\x18\x04\x20\x01(\x0cR\x12encodedAudioString\x12!\n\x0ccontent_type\
    \x18\x05\x20\x01(\tR\x0bcontentType\x1a\xad\x03\n\x05Value\x12\x1b\n\tno\
    de_name\x18\x07\x20\x01(\tR\x08nodeName\x12\x10\n\x03tag\x18\x01\x20\x01\
    (\tR\x03tag\x127\n\x08metadata\x18\t\x20\x01(\x0b2\x1b.tensorflow.Summar\
    yMetadataR\x08metadata\x12#\n\x0csimple_value\x18\x02\x20\x01(\x02H\0R\
    \x0bsimpleValue\x12A\n\x1cobsolete_old_style_histogram\x18\x03\x20\x01(\
    \x0cH\0R\x19obsoleteOldStyleHistogram\x121\n\x05image\x18\x04\x20\x01(\
    \x0b2\x19.tensorflow.Summary.ImageH\0R\x05image\x122\n\x05histo\x18\x05\
    \x20\x01(\x0b2\x1a.tensorflow.HistogramProtoH\0R\x05histo\x121\n\x05audi\
    o\x18\x06\x20\x01(\x0b2\x19.tensorflow.Summary.AudioH\0R\x05audio\x121\n\
    \x06tensor\x18\x08\x20\x01(\x0b2\x17.tensorflow.TensorProtoH\0R\x06tenso\
    rB\x07\n\x05valueBm\n\x18org.tensorflow.frameworkB\rSummaryProtosP\x01Z=\
    github.com/tensorflow/tensorflow/tensorflow/go/core/framework\xf8\x01\
    \x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
