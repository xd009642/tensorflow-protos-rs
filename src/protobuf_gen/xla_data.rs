// This file is generated by rust-protobuf 2.17.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![rustfmt::skip]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `tensorflow/compiler/xla/xla_data.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_17_0;

#[derive(PartialEq,Clone,Default)]
pub struct PaddingConfig {
    // message fields
    pub dimensions: ::protobuf::RepeatedField<PaddingConfig_PaddingConfigDimension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaddingConfig {
    fn default() -> &'a PaddingConfig {
        <PaddingConfig as ::protobuf::Message>::default_instance()
    }
}

impl PaddingConfig {
    pub fn new() -> PaddingConfig {
        ::std::default::Default::default()
    }

    // repeated .xla.PaddingConfig.PaddingConfigDimension dimensions = 1;


    pub fn get_dimensions(&self) -> &[PaddingConfig_PaddingConfigDimension] {
        &self.dimensions
    }
    pub fn clear_dimensions(&mut self) {
        self.dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_dimensions(&mut self, v: ::protobuf::RepeatedField<PaddingConfig_PaddingConfigDimension>) {
        self.dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dimensions(&mut self) -> &mut ::protobuf::RepeatedField<PaddingConfig_PaddingConfigDimension> {
        &mut self.dimensions
    }

    // Take field
    pub fn take_dimensions(&mut self) -> ::protobuf::RepeatedField<PaddingConfig_PaddingConfigDimension> {
        ::std::mem::replace(&mut self.dimensions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PaddingConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.dimensions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dimensions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dimensions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dimensions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaddingConfig {
        PaddingConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PaddingConfig_PaddingConfigDimension>>(
                "dimensions",
                |m: &PaddingConfig| { &m.dimensions },
                |m: &mut PaddingConfig| { &mut m.dimensions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaddingConfig>(
                "PaddingConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaddingConfig {
        static instance: ::protobuf::rt::LazyV2<PaddingConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaddingConfig::new)
    }
}

impl ::protobuf::Clear for PaddingConfig {
    fn clear(&mut self) {
        self.dimensions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaddingConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaddingConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PaddingConfig_PaddingConfigDimension {
    // message fields
    pub edge_padding_low: i64,
    pub edge_padding_high: i64,
    pub interior_padding: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PaddingConfig_PaddingConfigDimension {
    fn default() -> &'a PaddingConfig_PaddingConfigDimension {
        <PaddingConfig_PaddingConfigDimension as ::protobuf::Message>::default_instance()
    }
}

impl PaddingConfig_PaddingConfigDimension {
    pub fn new() -> PaddingConfig_PaddingConfigDimension {
        ::std::default::Default::default()
    }

    // int64 edge_padding_low = 1;


    pub fn get_edge_padding_low(&self) -> i64 {
        self.edge_padding_low
    }
    pub fn clear_edge_padding_low(&mut self) {
        self.edge_padding_low = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_padding_low(&mut self, v: i64) {
        self.edge_padding_low = v;
    }

    // int64 edge_padding_high = 2;


    pub fn get_edge_padding_high(&self) -> i64 {
        self.edge_padding_high
    }
    pub fn clear_edge_padding_high(&mut self) {
        self.edge_padding_high = 0;
    }

    // Param is passed by value, moved
    pub fn set_edge_padding_high(&mut self, v: i64) {
        self.edge_padding_high = v;
    }

    // int64 interior_padding = 3;


    pub fn get_interior_padding(&self) -> i64 {
        self.interior_padding
    }
    pub fn clear_interior_padding(&mut self) {
        self.interior_padding = 0;
    }

    // Param is passed by value, moved
    pub fn set_interior_padding(&mut self, v: i64) {
        self.interior_padding = v;
    }
}

impl ::protobuf::Message for PaddingConfig_PaddingConfigDimension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.edge_padding_low = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.edge_padding_high = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.interior_padding = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.edge_padding_low != 0 {
            my_size += ::protobuf::rt::value_size(1, self.edge_padding_low, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.edge_padding_high != 0 {
            my_size += ::protobuf::rt::value_size(2, self.edge_padding_high, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.interior_padding != 0 {
            my_size += ::protobuf::rt::value_size(3, self.interior_padding, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.edge_padding_low != 0 {
            os.write_int64(1, self.edge_padding_low)?;
        }
        if self.edge_padding_high != 0 {
            os.write_int64(2, self.edge_padding_high)?;
        }
        if self.interior_padding != 0 {
            os.write_int64(3, self.interior_padding)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PaddingConfig_PaddingConfigDimension {
        PaddingConfig_PaddingConfigDimension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "edge_padding_low",
                |m: &PaddingConfig_PaddingConfigDimension| { &m.edge_padding_low },
                |m: &mut PaddingConfig_PaddingConfigDimension| { &mut m.edge_padding_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "edge_padding_high",
                |m: &PaddingConfig_PaddingConfigDimension| { &m.edge_padding_high },
                |m: &mut PaddingConfig_PaddingConfigDimension| { &mut m.edge_padding_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "interior_padding",
                |m: &PaddingConfig_PaddingConfigDimension| { &m.interior_padding },
                |m: &mut PaddingConfig_PaddingConfigDimension| { &mut m.interior_padding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PaddingConfig_PaddingConfigDimension>(
                "PaddingConfig.PaddingConfigDimension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PaddingConfig_PaddingConfigDimension {
        static instance: ::protobuf::rt::LazyV2<PaddingConfig_PaddingConfigDimension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PaddingConfig_PaddingConfigDimension::new)
    }
}

impl ::protobuf::Clear for PaddingConfig_PaddingConfigDimension {
    fn clear(&mut self) {
        self.edge_padding_low = 0;
        self.edge_padding_high = 0;
        self.interior_padding = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PaddingConfig_PaddingConfigDimension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PaddingConfig_PaddingConfigDimension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TileProto {
    // message fields
    pub dimensions: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TileProto {
    fn default() -> &'a TileProto {
        <TileProto as ::protobuf::Message>::default_instance()
    }
}

impl TileProto {
    pub fn new() -> TileProto {
        ::std::default::Default::default()
    }

    // repeated int64 dimensions = 1;


    pub fn get_dimensions(&self) -> &[i64] {
        &self.dimensions
    }
    pub fn clear_dimensions(&mut self) {
        self.dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dimensions
    }

    // Take field
    pub fn take_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dimensions, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TileProto {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dimensions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dimensions {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dimensions {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TileProto {
        TileProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dimensions",
                |m: &TileProto| { &m.dimensions },
                |m: &mut TileProto| { &mut m.dimensions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TileProto>(
                "TileProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TileProto {
        static instance: ::protobuf::rt::LazyV2<TileProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TileProto::new)
    }
}

impl ::protobuf::Clear for TileProto {
    fn clear(&mut self) {
        self.dimensions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TileProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TileProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LayoutProto {
    // message fields
    pub format: Format,
    pub minor_to_major: ::std::vec::Vec<i64>,
    pub max_sparse_elements: i64,
    pub tiles: ::protobuf::RepeatedField<TileProto>,
    pub element_size_in_bits: i64,
    pub memory_space: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LayoutProto {
    fn default() -> &'a LayoutProto {
        <LayoutProto as ::protobuf::Message>::default_instance()
    }
}

impl LayoutProto {
    pub fn new() -> LayoutProto {
        ::std::default::Default::default()
    }

    // .xla.Format format = 4;


    pub fn get_format(&self) -> Format {
        self.format
    }
    pub fn clear_format(&mut self) {
        self.format = Format::INVALID_FORMAT;
    }

    // Param is passed by value, moved
    pub fn set_format(&mut self, v: Format) {
        self.format = v;
    }

    // repeated int64 minor_to_major = 1;


    pub fn get_minor_to_major(&self) -> &[i64] {
        &self.minor_to_major
    }
    pub fn clear_minor_to_major(&mut self) {
        self.minor_to_major.clear();
    }

    // Param is passed by value, moved
    pub fn set_minor_to_major(&mut self, v: ::std::vec::Vec<i64>) {
        self.minor_to_major = v;
    }

    // Mutable pointer to the field.
    pub fn mut_minor_to_major(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.minor_to_major
    }

    // Take field
    pub fn take_minor_to_major(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.minor_to_major, ::std::vec::Vec::new())
    }

    // int64 max_sparse_elements = 5;


    pub fn get_max_sparse_elements(&self) -> i64 {
        self.max_sparse_elements
    }
    pub fn clear_max_sparse_elements(&mut self) {
        self.max_sparse_elements = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_sparse_elements(&mut self, v: i64) {
        self.max_sparse_elements = v;
    }

    // repeated .xla.TileProto tiles = 6;


    pub fn get_tiles(&self) -> &[TileProto] {
        &self.tiles
    }
    pub fn clear_tiles(&mut self) {
        self.tiles.clear();
    }

    // Param is passed by value, moved
    pub fn set_tiles(&mut self, v: ::protobuf::RepeatedField<TileProto>) {
        self.tiles = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tiles(&mut self) -> &mut ::protobuf::RepeatedField<TileProto> {
        &mut self.tiles
    }

    // Take field
    pub fn take_tiles(&mut self) -> ::protobuf::RepeatedField<TileProto> {
        ::std::mem::replace(&mut self.tiles, ::protobuf::RepeatedField::new())
    }

    // int64 element_size_in_bits = 7;


    pub fn get_element_size_in_bits(&self) -> i64 {
        self.element_size_in_bits
    }
    pub fn clear_element_size_in_bits(&mut self) {
        self.element_size_in_bits = 0;
    }

    // Param is passed by value, moved
    pub fn set_element_size_in_bits(&mut self, v: i64) {
        self.element_size_in_bits = v;
    }

    // int64 memory_space = 8;


    pub fn get_memory_space(&self) -> i64 {
        self.memory_space
    }
    pub fn clear_memory_space(&mut self) {
        self.memory_space = 0;
    }

    // Param is passed by value, moved
    pub fn set_memory_space(&mut self, v: i64) {
        self.memory_space = v;
    }
}

impl ::protobuf::Message for LayoutProto {
    fn is_initialized(&self) -> bool {
        for v in &self.tiles {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.format, 4, &mut self.unknown_fields)?
                },
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.minor_to_major)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_sparse_elements = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tiles)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.element_size_in_bits = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.memory_space = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.format != Format::INVALID_FORMAT {
            my_size += ::protobuf::rt::enum_size(4, self.format);
        }
        for value in &self.minor_to_major {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.max_sparse_elements != 0 {
            my_size += ::protobuf::rt::value_size(5, self.max_sparse_elements, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tiles {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.element_size_in_bits != 0 {
            my_size += ::protobuf::rt::value_size(7, self.element_size_in_bits, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.memory_space != 0 {
            my_size += ::protobuf::rt::value_size(8, self.memory_space, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.format != Format::INVALID_FORMAT {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.format))?;
        }
        for v in &self.minor_to_major {
            os.write_int64(1, *v)?;
        };
        if self.max_sparse_elements != 0 {
            os.write_int64(5, self.max_sparse_elements)?;
        }
        for v in &self.tiles {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.element_size_in_bits != 0 {
            os.write_int64(7, self.element_size_in_bits)?;
        }
        if self.memory_space != 0 {
            os.write_int64(8, self.memory_space)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LayoutProto {
        LayoutProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Format>>(
                "format",
                |m: &LayoutProto| { &m.format },
                |m: &mut LayoutProto| { &mut m.format },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "minor_to_major",
                |m: &LayoutProto| { &m.minor_to_major },
                |m: &mut LayoutProto| { &mut m.minor_to_major },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_sparse_elements",
                |m: &LayoutProto| { &m.max_sparse_elements },
                |m: &mut LayoutProto| { &mut m.max_sparse_elements },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TileProto>>(
                "tiles",
                |m: &LayoutProto| { &m.tiles },
                |m: &mut LayoutProto| { &mut m.tiles },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "element_size_in_bits",
                |m: &LayoutProto| { &m.element_size_in_bits },
                |m: &mut LayoutProto| { &mut m.element_size_in_bits },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "memory_space",
                |m: &LayoutProto| { &m.memory_space },
                |m: &mut LayoutProto| { &mut m.memory_space },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LayoutProto>(
                "LayoutProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LayoutProto {
        static instance: ::protobuf::rt::LazyV2<LayoutProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LayoutProto::new)
    }
}

impl ::protobuf::Clear for LayoutProto {
    fn clear(&mut self) {
        self.format = Format::INVALID_FORMAT;
        self.minor_to_major.clear();
        self.max_sparse_elements = 0;
        self.tiles.clear();
        self.element_size_in_bits = 0;
        self.memory_space = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LayoutProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LayoutProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShapeProto {
    // message fields
    pub element_type: PrimitiveType,
    pub dimensions: ::std::vec::Vec<i64>,
    pub tuple_shapes: ::protobuf::RepeatedField<ShapeProto>,
    pub layout: ::protobuf::SingularPtrField<LayoutProto>,
    pub is_dynamic_dimension: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShapeProto {
    fn default() -> &'a ShapeProto {
        <ShapeProto as ::protobuf::Message>::default_instance()
    }
}

impl ShapeProto {
    pub fn new() -> ShapeProto {
        ::std::default::Default::default()
    }

    // .xla.PrimitiveType element_type = 2;


    pub fn get_element_type(&self) -> PrimitiveType {
        self.element_type
    }
    pub fn clear_element_type(&mut self) {
        self.element_type = PrimitiveType::PRIMITIVE_TYPE_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_element_type(&mut self, v: PrimitiveType) {
        self.element_type = v;
    }

    // repeated int64 dimensions = 3;


    pub fn get_dimensions(&self) -> &[i64] {
        &self.dimensions
    }
    pub fn clear_dimensions(&mut self) {
        self.dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.dimensions
    }

    // Take field
    pub fn take_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.dimensions, ::std::vec::Vec::new())
    }

    // repeated .xla.ShapeProto tuple_shapes = 4;


    pub fn get_tuple_shapes(&self) -> &[ShapeProto] {
        &self.tuple_shapes
    }
    pub fn clear_tuple_shapes(&mut self) {
        self.tuple_shapes.clear();
    }

    // Param is passed by value, moved
    pub fn set_tuple_shapes(&mut self, v: ::protobuf::RepeatedField<ShapeProto>) {
        self.tuple_shapes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tuple_shapes(&mut self) -> &mut ::protobuf::RepeatedField<ShapeProto> {
        &mut self.tuple_shapes
    }

    // Take field
    pub fn take_tuple_shapes(&mut self) -> ::protobuf::RepeatedField<ShapeProto> {
        ::std::mem::replace(&mut self.tuple_shapes, ::protobuf::RepeatedField::new())
    }

    // .xla.LayoutProto layout = 5;


    pub fn get_layout(&self) -> &LayoutProto {
        self.layout.as_ref().unwrap_or_else(|| <LayoutProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_layout(&mut self) {
        self.layout.clear();
    }

    pub fn has_layout(&self) -> bool {
        self.layout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_layout(&mut self, v: LayoutProto) {
        self.layout = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_layout(&mut self) -> &mut LayoutProto {
        if self.layout.is_none() {
            self.layout.set_default();
        }
        self.layout.as_mut().unwrap()
    }

    // Take field
    pub fn take_layout(&mut self) -> LayoutProto {
        self.layout.take().unwrap_or_else(|| LayoutProto::new())
    }

    // repeated bool is_dynamic_dimension = 6;


    pub fn get_is_dynamic_dimension(&self) -> &[bool] {
        &self.is_dynamic_dimension
    }
    pub fn clear_is_dynamic_dimension(&mut self) {
        self.is_dynamic_dimension.clear();
    }

    // Param is passed by value, moved
    pub fn set_is_dynamic_dimension(&mut self, v: ::std::vec::Vec<bool>) {
        self.is_dynamic_dimension = v;
    }

    // Mutable pointer to the field.
    pub fn mut_is_dynamic_dimension(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.is_dynamic_dimension
    }

    // Take field
    pub fn take_is_dynamic_dimension(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.is_dynamic_dimension, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ShapeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.tuple_shapes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.layout {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.element_type, 2, &mut self.unknown_fields)?
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.dimensions)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tuple_shapes)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.layout)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.is_dynamic_dimension)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.element_type != PrimitiveType::PRIMITIVE_TYPE_INVALID {
            my_size += ::protobuf::rt::enum_size(2, self.element_type);
        }
        for value in &self.dimensions {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tuple_shapes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.layout.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 2 * self.is_dynamic_dimension.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.element_type != PrimitiveType::PRIMITIVE_TYPE_INVALID {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.element_type))?;
        }
        for v in &self.dimensions {
            os.write_int64(3, *v)?;
        };
        for v in &self.tuple_shapes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.layout.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.is_dynamic_dimension {
            os.write_bool(6, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShapeProto {
        ShapeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PrimitiveType>>(
                "element_type",
                |m: &ShapeProto| { &m.element_type },
                |m: &mut ShapeProto| { &mut m.element_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dimensions",
                |m: &ShapeProto| { &m.dimensions },
                |m: &mut ShapeProto| { &mut m.dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShapeProto>>(
                "tuple_shapes",
                |m: &ShapeProto| { &m.tuple_shapes },
                |m: &mut ShapeProto| { &mut m.tuple_shapes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LayoutProto>>(
                "layout",
                |m: &ShapeProto| { &m.layout },
                |m: &mut ShapeProto| { &mut m.layout },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "is_dynamic_dimension",
                |m: &ShapeProto| { &m.is_dynamic_dimension },
                |m: &mut ShapeProto| { &mut m.is_dynamic_dimension },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShapeProto>(
                "ShapeProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShapeProto {
        static instance: ::protobuf::rt::LazyV2<ShapeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShapeProto::new)
    }
}

impl ::protobuf::Clear for ShapeProto {
    fn clear(&mut self) {
        self.element_type = PrimitiveType::PRIMITIVE_TYPE_INVALID;
        self.dimensions.clear();
        self.tuple_shapes.clear();
        self.layout.clear();
        self.is_dynamic_dimension.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShapeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShapeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProgramShapeProto {
    // message fields
    pub parameters: ::protobuf::RepeatedField<ShapeProto>,
    pub result: ::protobuf::SingularPtrField<ShapeProto>,
    pub parameter_names: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProgramShapeProto {
    fn default() -> &'a ProgramShapeProto {
        <ProgramShapeProto as ::protobuf::Message>::default_instance()
    }
}

impl ProgramShapeProto {
    pub fn new() -> ProgramShapeProto {
        ::std::default::Default::default()
    }

    // repeated .xla.ShapeProto parameters = 1;


    pub fn get_parameters(&self) -> &[ShapeProto] {
        &self.parameters
    }
    pub fn clear_parameters(&mut self) {
        self.parameters.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameters(&mut self, v: ::protobuf::RepeatedField<ShapeProto>) {
        self.parameters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameters(&mut self) -> &mut ::protobuf::RepeatedField<ShapeProto> {
        &mut self.parameters
    }

    // Take field
    pub fn take_parameters(&mut self) -> ::protobuf::RepeatedField<ShapeProto> {
        ::std::mem::replace(&mut self.parameters, ::protobuf::RepeatedField::new())
    }

    // .xla.ShapeProto result = 2;


    pub fn get_result(&self) -> &ShapeProto {
        self.result.as_ref().unwrap_or_else(|| <ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_result(&mut self) {
        self.result.clear();
    }

    pub fn has_result(&self) -> bool {
        self.result.is_some()
    }

    // Param is passed by value, moved
    pub fn set_result(&mut self, v: ShapeProto) {
        self.result = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_result(&mut self) -> &mut ShapeProto {
        if self.result.is_none() {
            self.result.set_default();
        }
        self.result.as_mut().unwrap()
    }

    // Take field
    pub fn take_result(&mut self) -> ShapeProto {
        self.result.take().unwrap_or_else(|| ShapeProto::new())
    }

    // repeated string parameter_names = 3;


    pub fn get_parameter_names(&self) -> &[::std::string::String] {
        &self.parameter_names
    }
    pub fn clear_parameter_names(&mut self) {
        self.parameter_names.clear();
    }

    // Param is passed by value, moved
    pub fn set_parameter_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.parameter_names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_parameter_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.parameter_names
    }

    // Take field
    pub fn take_parameter_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.parameter_names, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ProgramShapeProto {
    fn is_initialized(&self) -> bool {
        for v in &self.parameters {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.result {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.parameters)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.result)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.parameter_names)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.parameters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.result.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.parameter_names {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.parameters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.result.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.parameter_names {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProgramShapeProto {
        ProgramShapeProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShapeProto>>(
                "parameters",
                |m: &ProgramShapeProto| { &m.parameters },
                |m: &mut ProgramShapeProto| { &mut m.parameters },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShapeProto>>(
                "result",
                |m: &ProgramShapeProto| { &m.result },
                |m: &mut ProgramShapeProto| { &mut m.result },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parameter_names",
                |m: &ProgramShapeProto| { &m.parameter_names },
                |m: &mut ProgramShapeProto| { &mut m.parameter_names },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProgramShapeProto>(
                "ProgramShapeProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProgramShapeProto {
        static instance: ::protobuf::rt::LazyV2<ProgramShapeProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProgramShapeProto::new)
    }
}

impl ::protobuf::Clear for ProgramShapeProto {
    fn clear(&mut self) {
        self.parameters.clear();
        self.result.clear();
        self.parameter_names.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProgramShapeProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProgramShapeProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComputationStats {
    // message fields
    pub flop_count: f64,
    pub transcendental_count: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComputationStats {
    fn default() -> &'a ComputationStats {
        <ComputationStats as ::protobuf::Message>::default_instance()
    }
}

impl ComputationStats {
    pub fn new() -> ComputationStats {
        ::std::default::Default::default()
    }

    // double flop_count = 1;


    pub fn get_flop_count(&self) -> f64 {
        self.flop_count
    }
    pub fn clear_flop_count(&mut self) {
        self.flop_count = 0.;
    }

    // Param is passed by value, moved
    pub fn set_flop_count(&mut self, v: f64) {
        self.flop_count = v;
    }

    // double transcendental_count = 2;


    pub fn get_transcendental_count(&self) -> f64 {
        self.transcendental_count
    }
    pub fn clear_transcendental_count(&mut self) {
        self.transcendental_count = 0.;
    }

    // Param is passed by value, moved
    pub fn set_transcendental_count(&mut self, v: f64) {
        self.transcendental_count = v;
    }
}

impl ::protobuf::Message for ComputationStats {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.flop_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.transcendental_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.flop_count != 0. {
            my_size += 9;
        }
        if self.transcendental_count != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.flop_count != 0. {
            os.write_double(1, self.flop_count)?;
        }
        if self.transcendental_count != 0. {
            os.write_double(2, self.transcendental_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComputationStats {
        ComputationStats::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "flop_count",
                |m: &ComputationStats| { &m.flop_count },
                |m: &mut ComputationStats| { &mut m.flop_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "transcendental_count",
                |m: &ComputationStats| { &m.transcendental_count },
                |m: &mut ComputationStats| { &mut m.transcendental_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComputationStats>(
                "ComputationStats",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComputationStats {
        static instance: ::protobuf::rt::LazyV2<ComputationStats> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComputationStats::new)
    }
}

impl ::protobuf::Clear for ComputationStats {
    fn clear(&mut self) {
        self.flop_count = 0.;
        self.transcendental_count = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComputationStats {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComputationStats {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpMetadata {
    // message fields
    pub op_type: ::std::string::String,
    pub op_name: ::std::string::String,
    pub source_file: ::std::string::String,
    pub source_line: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpMetadata {
    fn default() -> &'a OpMetadata {
        <OpMetadata as ::protobuf::Message>::default_instance()
    }
}

impl OpMetadata {
    pub fn new() -> OpMetadata {
        ::std::default::Default::default()
    }

    // string op_type = 1;


    pub fn get_op_type(&self) -> &str {
        &self.op_type
    }
    pub fn clear_op_type(&mut self) {
        self.op_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_type(&mut self, v: ::std::string::String) {
        self.op_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_type(&mut self) -> &mut ::std::string::String {
        &mut self.op_type
    }

    // Take field
    pub fn take_op_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op_type, ::std::string::String::new())
    }

    // string op_name = 2;


    pub fn get_op_name(&self) -> &str {
        &self.op_name
    }
    pub fn clear_op_name(&mut self) {
        self.op_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_op_name(&mut self, v: ::std::string::String) {
        self.op_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_op_name(&mut self) -> &mut ::std::string::String {
        &mut self.op_name
    }

    // Take field
    pub fn take_op_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.op_name, ::std::string::String::new())
    }

    // string source_file = 3;


    pub fn get_source_file(&self) -> &str {
        &self.source_file
    }
    pub fn clear_source_file(&mut self) {
        self.source_file.clear();
    }

    // Param is passed by value, moved
    pub fn set_source_file(&mut self, v: ::std::string::String) {
        self.source_file = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source_file(&mut self) -> &mut ::std::string::String {
        &mut self.source_file
    }

    // Take field
    pub fn take_source_file(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.source_file, ::std::string::String::new())
    }

    // int32 source_line = 4;


    pub fn get_source_line(&self) -> i32 {
        self.source_line
    }
    pub fn clear_source_line(&mut self) {
        self.source_line = 0;
    }

    // Param is passed by value, moved
    pub fn set_source_line(&mut self, v: i32) {
        self.source_line = v;
    }
}

impl ::protobuf::Message for OpMetadata {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.op_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.source_file)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.source_line = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.op_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.op_type);
        }
        if !self.op_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.op_name);
        }
        if !self.source_file.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.source_file);
        }
        if self.source_line != 0 {
            my_size += ::protobuf::rt::value_size(4, self.source_line, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.op_type.is_empty() {
            os.write_string(1, &self.op_type)?;
        }
        if !self.op_name.is_empty() {
            os.write_string(2, &self.op_name)?;
        }
        if !self.source_file.is_empty() {
            os.write_string(3, &self.source_file)?;
        }
        if self.source_line != 0 {
            os.write_int32(4, self.source_line)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpMetadata {
        OpMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op_type",
                |m: &OpMetadata| { &m.op_type },
                |m: &mut OpMetadata| { &mut m.op_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "op_name",
                |m: &OpMetadata| { &m.op_name },
                |m: &mut OpMetadata| { &mut m.op_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "source_file",
                |m: &OpMetadata| { &m.source_file },
                |m: &mut OpMetadata| { &mut m.source_file },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "source_line",
                |m: &OpMetadata| { &m.source_line },
                |m: &mut OpMetadata| { &mut m.source_line },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpMetadata>(
                "OpMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpMetadata {
        static instance: ::protobuf::rt::LazyV2<OpMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpMetadata::new)
    }
}

impl ::protobuf::Clear for OpMetadata {
    fn clear(&mut self) {
        self.op_type.clear();
        self.op_name.clear();
        self.source_file.clear();
        self.source_line = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutionProfile {
    // message fields
    pub compilation_cache_hit: bool,
    pub compile_time_ms: i64,
    pub compute_cycle_count: i64,
    pub compute_time_ns: i64,
    pub compute_and_transfer_time_ns: i64,
    pub executable_size_in_bytes: i64,
    pub profile_cache_hit: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionProfile {
    fn default() -> &'a ExecutionProfile {
        <ExecutionProfile as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionProfile {
    pub fn new() -> ExecutionProfile {
        ::std::default::Default::default()
    }

    // bool compilation_cache_hit = 1;


    pub fn get_compilation_cache_hit(&self) -> bool {
        self.compilation_cache_hit
    }
    pub fn clear_compilation_cache_hit(&mut self) {
        self.compilation_cache_hit = false;
    }

    // Param is passed by value, moved
    pub fn set_compilation_cache_hit(&mut self, v: bool) {
        self.compilation_cache_hit = v;
    }

    // int64 compile_time_ms = 2;


    pub fn get_compile_time_ms(&self) -> i64 {
        self.compile_time_ms
    }
    pub fn clear_compile_time_ms(&mut self) {
        self.compile_time_ms = 0;
    }

    // Param is passed by value, moved
    pub fn set_compile_time_ms(&mut self, v: i64) {
        self.compile_time_ms = v;
    }

    // int64 compute_cycle_count = 3;


    pub fn get_compute_cycle_count(&self) -> i64 {
        self.compute_cycle_count
    }
    pub fn clear_compute_cycle_count(&mut self) {
        self.compute_cycle_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_compute_cycle_count(&mut self, v: i64) {
        self.compute_cycle_count = v;
    }

    // int64 compute_time_ns = 4;


    pub fn get_compute_time_ns(&self) -> i64 {
        self.compute_time_ns
    }
    pub fn clear_compute_time_ns(&mut self) {
        self.compute_time_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_compute_time_ns(&mut self, v: i64) {
        self.compute_time_ns = v;
    }

    // int64 compute_and_transfer_time_ns = 5;


    pub fn get_compute_and_transfer_time_ns(&self) -> i64 {
        self.compute_and_transfer_time_ns
    }
    pub fn clear_compute_and_transfer_time_ns(&mut self) {
        self.compute_and_transfer_time_ns = 0;
    }

    // Param is passed by value, moved
    pub fn set_compute_and_transfer_time_ns(&mut self, v: i64) {
        self.compute_and_transfer_time_ns = v;
    }

    // int64 executable_size_in_bytes = 6;


    pub fn get_executable_size_in_bytes(&self) -> i64 {
        self.executable_size_in_bytes
    }
    pub fn clear_executable_size_in_bytes(&mut self) {
        self.executable_size_in_bytes = 0;
    }

    // Param is passed by value, moved
    pub fn set_executable_size_in_bytes(&mut self, v: i64) {
        self.executable_size_in_bytes = v;
    }

    // bool profile_cache_hit = 7;


    pub fn get_profile_cache_hit(&self) -> bool {
        self.profile_cache_hit
    }
    pub fn clear_profile_cache_hit(&mut self) {
        self.profile_cache_hit = false;
    }

    // Param is passed by value, moved
    pub fn set_profile_cache_hit(&mut self, v: bool) {
        self.profile_cache_hit = v;
    }
}

impl ::protobuf::Message for ExecutionProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.compilation_cache_hit = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compile_time_ms = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compute_cycle_count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compute_time_ns = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.compute_and_transfer_time_ns = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.executable_size_in_bytes = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.profile_cache_hit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.compilation_cache_hit != false {
            my_size += 2;
        }
        if self.compile_time_ms != 0 {
            my_size += ::protobuf::rt::value_size(2, self.compile_time_ms, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compute_cycle_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.compute_cycle_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compute_time_ns != 0 {
            my_size += ::protobuf::rt::value_size(4, self.compute_time_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.compute_and_transfer_time_ns != 0 {
            my_size += ::protobuf::rt::value_size(5, self.compute_and_transfer_time_ns, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.executable_size_in_bytes != 0 {
            my_size += ::protobuf::rt::value_size(6, self.executable_size_in_bytes, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.profile_cache_hit != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.compilation_cache_hit != false {
            os.write_bool(1, self.compilation_cache_hit)?;
        }
        if self.compile_time_ms != 0 {
            os.write_int64(2, self.compile_time_ms)?;
        }
        if self.compute_cycle_count != 0 {
            os.write_int64(3, self.compute_cycle_count)?;
        }
        if self.compute_time_ns != 0 {
            os.write_int64(4, self.compute_time_ns)?;
        }
        if self.compute_and_transfer_time_ns != 0 {
            os.write_int64(5, self.compute_and_transfer_time_ns)?;
        }
        if self.executable_size_in_bytes != 0 {
            os.write_int64(6, self.executable_size_in_bytes)?;
        }
        if self.profile_cache_hit != false {
            os.write_bool(7, self.profile_cache_hit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutionProfile {
        ExecutionProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "compilation_cache_hit",
                |m: &ExecutionProfile| { &m.compilation_cache_hit },
                |m: &mut ExecutionProfile| { &mut m.compilation_cache_hit },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compile_time_ms",
                |m: &ExecutionProfile| { &m.compile_time_ms },
                |m: &mut ExecutionProfile| { &mut m.compile_time_ms },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compute_cycle_count",
                |m: &ExecutionProfile| { &m.compute_cycle_count },
                |m: &mut ExecutionProfile| { &mut m.compute_cycle_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compute_time_ns",
                |m: &ExecutionProfile| { &m.compute_time_ns },
                |m: &mut ExecutionProfile| { &mut m.compute_time_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "compute_and_transfer_time_ns",
                |m: &ExecutionProfile| { &m.compute_and_transfer_time_ns },
                |m: &mut ExecutionProfile| { &mut m.compute_and_transfer_time_ns },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "executable_size_in_bytes",
                |m: &ExecutionProfile| { &m.executable_size_in_bytes },
                |m: &mut ExecutionProfile| { &mut m.executable_size_in_bytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "profile_cache_hit",
                |m: &ExecutionProfile| { &m.profile_cache_hit },
                |m: &mut ExecutionProfile| { &mut m.profile_cache_hit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecutionProfile>(
                "ExecutionProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecutionProfile {
        static instance: ::protobuf::rt::LazyV2<ExecutionProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecutionProfile::new)
    }
}

impl ::protobuf::Clear for ExecutionProfile {
    fn clear(&mut self) {
        self.compilation_cache_hit = false;
        self.compile_time_ms = 0;
        self.compute_cycle_count = 0;
        self.compute_time_ns = 0;
        self.compute_and_transfer_time_ns = 0;
        self.executable_size_in_bytes = 0;
        self.profile_cache_hit = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecutionHandle {
    // message fields
    pub handle: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecutionHandle {
    fn default() -> &'a ExecutionHandle {
        <ExecutionHandle as ::protobuf::Message>::default_instance()
    }
}

impl ExecutionHandle {
    pub fn new() -> ExecutionHandle {
        ::std::default::Default::default()
    }

    // int64 handle = 1;


    pub fn get_handle(&self) -> i64 {
        self.handle
    }
    pub fn clear_handle(&mut self) {
        self.handle = 0;
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i64) {
        self.handle = v;
    }
}

impl ::protobuf::Message for ExecutionHandle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.handle = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.handle != 0 {
            my_size += ::protobuf::rt::value_size(1, self.handle, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.handle != 0 {
            os.write_int64(1, self.handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecutionHandle {
        ExecutionHandle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "handle",
                |m: &ExecutionHandle| { &m.handle },
                |m: &mut ExecutionHandle| { &mut m.handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecutionHandle>(
                "ExecutionHandle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecutionHandle {
        static instance: ::protobuf::rt::LazyV2<ExecutionHandle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecutionHandle::new)
    }
}

impl ::protobuf::Clear for ExecutionHandle {
    fn clear(&mut self) {
        self.handle = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecutionHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecutionHandle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalDataHandle {
    // message fields
    pub handle: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalDataHandle {
    fn default() -> &'a GlobalDataHandle {
        <GlobalDataHandle as ::protobuf::Message>::default_instance()
    }
}

impl GlobalDataHandle {
    pub fn new() -> GlobalDataHandle {
        ::std::default::Default::default()
    }

    // int64 handle = 1;


    pub fn get_handle(&self) -> i64 {
        self.handle
    }
    pub fn clear_handle(&mut self) {
        self.handle = 0;
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i64) {
        self.handle = v;
    }
}

impl ::protobuf::Message for GlobalDataHandle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.handle = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.handle != 0 {
            my_size += ::protobuf::rt::value_size(1, self.handle, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.handle != 0 {
            os.write_int64(1, self.handle)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalDataHandle {
        GlobalDataHandle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "handle",
                |m: &GlobalDataHandle| { &m.handle },
                |m: &mut GlobalDataHandle| { &mut m.handle },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalDataHandle>(
                "GlobalDataHandle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalDataHandle {
        static instance: ::protobuf::rt::LazyV2<GlobalDataHandle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalDataHandle::new)
    }
}

impl ::protobuf::Clear for GlobalDataHandle {
    fn clear(&mut self) {
        self.handle = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalDataHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalDataHandle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceHandle {
    // message fields
    pub handle: i64,
    pub device_count: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceHandle {
    fn default() -> &'a DeviceHandle {
        <DeviceHandle as ::protobuf::Message>::default_instance()
    }
}

impl DeviceHandle {
    pub fn new() -> DeviceHandle {
        ::std::default::Default::default()
    }

    // int64 handle = 1;


    pub fn get_handle(&self) -> i64 {
        self.handle
    }
    pub fn clear_handle(&mut self) {
        self.handle = 0;
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i64) {
        self.handle = v;
    }

    // int64 device_count = 2;


    pub fn get_device_count(&self) -> i64 {
        self.device_count
    }
    pub fn clear_device_count(&mut self) {
        self.device_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_device_count(&mut self, v: i64) {
        self.device_count = v;
    }
}

impl ::protobuf::Message for DeviceHandle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.handle = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.device_count = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.handle != 0 {
            my_size += ::protobuf::rt::value_size(1, self.handle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.device_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.device_count, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.handle != 0 {
            os.write_int64(1, self.handle)?;
        }
        if self.device_count != 0 {
            os.write_int64(2, self.device_count)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceHandle {
        DeviceHandle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "handle",
                |m: &DeviceHandle| { &m.handle },
                |m: &mut DeviceHandle| { &mut m.handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "device_count",
                |m: &DeviceHandle| { &m.device_count },
                |m: &mut DeviceHandle| { &mut m.device_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceHandle>(
                "DeviceHandle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceHandle {
        static instance: ::protobuf::rt::LazyV2<DeviceHandle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceHandle::new)
    }
}

impl ::protobuf::Clear for DeviceHandle {
    fn clear(&mut self) {
        self.handle = 0;
        self.device_count = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceHandle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ChannelHandle {
    // message fields
    pub handle: i64,
    pub field_type: ChannelHandle_ChannelType,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ChannelHandle {
    fn default() -> &'a ChannelHandle {
        <ChannelHandle as ::protobuf::Message>::default_instance()
    }
}

impl ChannelHandle {
    pub fn new() -> ChannelHandle {
        ::std::default::Default::default()
    }

    // int64 handle = 1;


    pub fn get_handle(&self) -> i64 {
        self.handle
    }
    pub fn clear_handle(&mut self) {
        self.handle = 0;
    }

    // Param is passed by value, moved
    pub fn set_handle(&mut self, v: i64) {
        self.handle = v;
    }

    // .xla.ChannelHandle.ChannelType type = 2;


    pub fn get_field_type(&self) -> ChannelHandle_ChannelType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ChannelHandle_ChannelType) {
        self.field_type = v;
    }
}

impl ::protobuf::Message for ChannelHandle {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.handle = tmp;
                },
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 2, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.handle != 0 {
            my_size += ::protobuf::rt::value_size(1, self.handle, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.field_type != ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID {
            my_size += ::protobuf::rt::enum_size(2, self.field_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.handle != 0 {
            os.write_int64(1, self.handle)?;
        }
        if self.field_type != ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ChannelHandle {
        ChannelHandle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "handle",
                |m: &ChannelHandle| { &m.handle },
                |m: &mut ChannelHandle| { &mut m.handle },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ChannelHandle_ChannelType>>(
                "type",
                |m: &ChannelHandle| { &m.field_type },
                |m: &mut ChannelHandle| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ChannelHandle>(
                "ChannelHandle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ChannelHandle {
        static instance: ::protobuf::rt::LazyV2<ChannelHandle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ChannelHandle::new)
    }
}

impl ::protobuf::Clear for ChannelHandle {
    fn clear(&mut self) {
        self.handle = 0;
        self.field_type = ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ChannelHandle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelHandle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum ChannelHandle_ChannelType {
    CHANNEL_TYPE_INVALID = 0,
    DEVICE_TO_DEVICE = 1,
    DEVICE_TO_HOST = 2,
    HOST_TO_DEVICE = 3,
}

impl ::protobuf::ProtobufEnum for ChannelHandle_ChannelType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ChannelHandle_ChannelType> {
        match value {
            0 => ::std::option::Option::Some(ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID),
            1 => ::std::option::Option::Some(ChannelHandle_ChannelType::DEVICE_TO_DEVICE),
            2 => ::std::option::Option::Some(ChannelHandle_ChannelType::DEVICE_TO_HOST),
            3 => ::std::option::Option::Some(ChannelHandle_ChannelType::HOST_TO_DEVICE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ChannelHandle_ChannelType] = &[
            ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID,
            ChannelHandle_ChannelType::DEVICE_TO_DEVICE,
            ChannelHandle_ChannelType::DEVICE_TO_HOST,
            ChannelHandle_ChannelType::HOST_TO_DEVICE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<ChannelHandle_ChannelType>("ChannelHandle.ChannelType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for ChannelHandle_ChannelType {
}

impl ::std::default::Default for ChannelHandle_ChannelType {
    fn default() -> Self {
        ChannelHandle_ChannelType::CHANNEL_TYPE_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for ChannelHandle_ChannelType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceAssignmentProto {
    // message fields
    pub replica_count: i32,
    pub computation_count: i32,
    pub computation_devices: ::protobuf::RepeatedField<DeviceAssignmentProto_ComputationDevice>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceAssignmentProto {
    fn default() -> &'a DeviceAssignmentProto {
        <DeviceAssignmentProto as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAssignmentProto {
    pub fn new() -> DeviceAssignmentProto {
        ::std::default::Default::default()
    }

    // int32 replica_count = 1;


    pub fn get_replica_count(&self) -> i32 {
        self.replica_count
    }
    pub fn clear_replica_count(&mut self) {
        self.replica_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_replica_count(&mut self, v: i32) {
        self.replica_count = v;
    }

    // int32 computation_count = 2;


    pub fn get_computation_count(&self) -> i32 {
        self.computation_count
    }
    pub fn clear_computation_count(&mut self) {
        self.computation_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_computation_count(&mut self, v: i32) {
        self.computation_count = v;
    }

    // repeated .xla.DeviceAssignmentProto.ComputationDevice computation_devices = 3;


    pub fn get_computation_devices(&self) -> &[DeviceAssignmentProto_ComputationDevice] {
        &self.computation_devices
    }
    pub fn clear_computation_devices(&mut self) {
        self.computation_devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_computation_devices(&mut self, v: ::protobuf::RepeatedField<DeviceAssignmentProto_ComputationDevice>) {
        self.computation_devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_computation_devices(&mut self) -> &mut ::protobuf::RepeatedField<DeviceAssignmentProto_ComputationDevice> {
        &mut self.computation_devices
    }

    // Take field
    pub fn take_computation_devices(&mut self) -> ::protobuf::RepeatedField<DeviceAssignmentProto_ComputationDevice> {
        ::std::mem::replace(&mut self.computation_devices, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeviceAssignmentProto {
    fn is_initialized(&self) -> bool {
        for v in &self.computation_devices {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.replica_count = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.computation_count = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.computation_devices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.replica_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.replica_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.computation_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.computation_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.computation_devices {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.replica_count != 0 {
            os.write_int32(1, self.replica_count)?;
        }
        if self.computation_count != 0 {
            os.write_int32(2, self.computation_count)?;
        }
        for v in &self.computation_devices {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceAssignmentProto {
        DeviceAssignmentProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "replica_count",
                |m: &DeviceAssignmentProto| { &m.replica_count },
                |m: &mut DeviceAssignmentProto| { &mut m.replica_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "computation_count",
                |m: &DeviceAssignmentProto| { &m.computation_count },
                |m: &mut DeviceAssignmentProto| { &mut m.computation_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DeviceAssignmentProto_ComputationDevice>>(
                "computation_devices",
                |m: &DeviceAssignmentProto| { &m.computation_devices },
                |m: &mut DeviceAssignmentProto| { &mut m.computation_devices },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceAssignmentProto>(
                "DeviceAssignmentProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceAssignmentProto {
        static instance: ::protobuf::rt::LazyV2<DeviceAssignmentProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceAssignmentProto::new)
    }
}

impl ::protobuf::Clear for DeviceAssignmentProto {
    fn clear(&mut self) {
        self.replica_count = 0;
        self.computation_count = 0;
        self.computation_devices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceAssignmentProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAssignmentProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeviceAssignmentProto_ComputationDevice {
    // message fields
    pub replica_device_ids: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeviceAssignmentProto_ComputationDevice {
    fn default() -> &'a DeviceAssignmentProto_ComputationDevice {
        <DeviceAssignmentProto_ComputationDevice as ::protobuf::Message>::default_instance()
    }
}

impl DeviceAssignmentProto_ComputationDevice {
    pub fn new() -> DeviceAssignmentProto_ComputationDevice {
        ::std::default::Default::default()
    }

    // repeated int32 replica_device_ids = 1;


    pub fn get_replica_device_ids(&self) -> &[i32] {
        &self.replica_device_ids
    }
    pub fn clear_replica_device_ids(&mut self) {
        self.replica_device_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_replica_device_ids(&mut self, v: ::std::vec::Vec<i32>) {
        self.replica_device_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replica_device_ids(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.replica_device_ids
    }

    // Take field
    pub fn take_replica_device_ids(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.replica_device_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DeviceAssignmentProto_ComputationDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.replica_device_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.replica_device_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.replica_device_ids {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeviceAssignmentProto_ComputationDevice {
        DeviceAssignmentProto_ComputationDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "replica_device_ids",
                |m: &DeviceAssignmentProto_ComputationDevice| { &m.replica_device_ids },
                |m: &mut DeviceAssignmentProto_ComputationDevice| { &mut m.replica_device_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeviceAssignmentProto_ComputationDevice>(
                "DeviceAssignmentProto.ComputationDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeviceAssignmentProto_ComputationDevice {
        static instance: ::protobuf::rt::LazyV2<DeviceAssignmentProto_ComputationDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeviceAssignmentProto_ComputationDevice::new)
    }
}

impl ::protobuf::Clear for DeviceAssignmentProto_ComputationDevice {
    fn clear(&mut self) {
        self.replica_device_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeviceAssignmentProto_ComputationDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceAssignmentProto_ComputationDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LiteralProto {
    // message fields
    pub shape: ::protobuf::SingularPtrField<ShapeProto>,
    pub preds: ::std::vec::Vec<bool>,
    pub s8s: ::std::vec::Vec<u8>,
    pub u8s: ::std::vec::Vec<u8>,
    pub s32s: ::std::vec::Vec<i32>,
    pub s64s: ::std::vec::Vec<i64>,
    pub u32s: ::std::vec::Vec<u32>,
    pub u64s: ::std::vec::Vec<u64>,
    pub f32s: ::std::vec::Vec<f32>,
    pub f64s: ::std::vec::Vec<f64>,
    pub c64s: ::std::vec::Vec<f32>,
    pub c128s: ::std::vec::Vec<f64>,
    pub tuple_literals: ::protobuf::RepeatedField<LiteralProto>,
    pub f16s: ::std::vec::Vec<u8>,
    pub bf16s: ::std::vec::Vec<u8>,
    pub u16s: ::std::vec::Vec<u8>,
    pub s16s: ::std::vec::Vec<u8>,
    pub sparse_indices: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LiteralProto {
    fn default() -> &'a LiteralProto {
        <LiteralProto as ::protobuf::Message>::default_instance()
    }
}

impl LiteralProto {
    pub fn new() -> LiteralProto {
        ::std::default::Default::default()
    }

    // .xla.ShapeProto shape = 1;


    pub fn get_shape(&self) -> &ShapeProto {
        self.shape.as_ref().unwrap_or_else(|| <ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shape(&mut self) {
        self.shape.clear();
    }

    pub fn has_shape(&self) -> bool {
        self.shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shape(&mut self, v: ShapeProto) {
        self.shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shape(&mut self) -> &mut ShapeProto {
        if self.shape.is_none() {
            self.shape.set_default();
        }
        self.shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_shape(&mut self) -> ShapeProto {
        self.shape.take().unwrap_or_else(|| ShapeProto::new())
    }

    // repeated bool preds = 2;


    pub fn get_preds(&self) -> &[bool] {
        &self.preds
    }
    pub fn clear_preds(&mut self) {
        self.preds.clear();
    }

    // Param is passed by value, moved
    pub fn set_preds(&mut self, v: ::std::vec::Vec<bool>) {
        self.preds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preds(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.preds
    }

    // Take field
    pub fn take_preds(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.preds, ::std::vec::Vec::new())
    }

    // bytes s8s = 15;


    pub fn get_s8s(&self) -> &[u8] {
        &self.s8s
    }
    pub fn clear_s8s(&mut self) {
        self.s8s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s8s(&mut self, v: ::std::vec::Vec<u8>) {
        self.s8s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s8s(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.s8s
    }

    // Take field
    pub fn take_s8s(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.s8s, ::std::vec::Vec::new())
    }

    // bytes u8s = 3;


    pub fn get_u8s(&self) -> &[u8] {
        &self.u8s
    }
    pub fn clear_u8s(&mut self) {
        self.u8s.clear();
    }

    // Param is passed by value, moved
    pub fn set_u8s(&mut self, v: ::std::vec::Vec<u8>) {
        self.u8s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_u8s(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.u8s
    }

    // Take field
    pub fn take_u8s(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.u8s, ::std::vec::Vec::new())
    }

    // repeated int32 s32s = 4;


    pub fn get_s32s(&self) -> &[i32] {
        &self.s32s
    }
    pub fn clear_s32s(&mut self) {
        self.s32s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s32s(&mut self, v: ::std::vec::Vec<i32>) {
        self.s32s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_s32s(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.s32s
    }

    // Take field
    pub fn take_s32s(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.s32s, ::std::vec::Vec::new())
    }

    // repeated int64 s64s = 5;


    pub fn get_s64s(&self) -> &[i64] {
        &self.s64s
    }
    pub fn clear_s64s(&mut self) {
        self.s64s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s64s(&mut self, v: ::std::vec::Vec<i64>) {
        self.s64s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_s64s(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.s64s
    }

    // Take field
    pub fn take_s64s(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.s64s, ::std::vec::Vec::new())
    }

    // repeated uint32 u32s = 6;


    pub fn get_u32s(&self) -> &[u32] {
        &self.u32s
    }
    pub fn clear_u32s(&mut self) {
        self.u32s.clear();
    }

    // Param is passed by value, moved
    pub fn set_u32s(&mut self, v: ::std::vec::Vec<u32>) {
        self.u32s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_u32s(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.u32s
    }

    // Take field
    pub fn take_u32s(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.u32s, ::std::vec::Vec::new())
    }

    // repeated uint64 u64s = 7;


    pub fn get_u64s(&self) -> &[u64] {
        &self.u64s
    }
    pub fn clear_u64s(&mut self) {
        self.u64s.clear();
    }

    // Param is passed by value, moved
    pub fn set_u64s(&mut self, v: ::std::vec::Vec<u64>) {
        self.u64s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_u64s(&mut self) -> &mut ::std::vec::Vec<u64> {
        &mut self.u64s
    }

    // Take field
    pub fn take_u64s(&mut self) -> ::std::vec::Vec<u64> {
        ::std::mem::replace(&mut self.u64s, ::std::vec::Vec::new())
    }

    // repeated float f32s = 8;


    pub fn get_f32s(&self) -> &[f32] {
        &self.f32s
    }
    pub fn clear_f32s(&mut self) {
        self.f32s.clear();
    }

    // Param is passed by value, moved
    pub fn set_f32s(&mut self, v: ::std::vec::Vec<f32>) {
        self.f32s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_f32s(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.f32s
    }

    // Take field
    pub fn take_f32s(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.f32s, ::std::vec::Vec::new())
    }

    // repeated double f64s = 9;


    pub fn get_f64s(&self) -> &[f64] {
        &self.f64s
    }
    pub fn clear_f64s(&mut self) {
        self.f64s.clear();
    }

    // Param is passed by value, moved
    pub fn set_f64s(&mut self, v: ::std::vec::Vec<f64>) {
        self.f64s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_f64s(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.f64s
    }

    // Take field
    pub fn take_f64s(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.f64s, ::std::vec::Vec::new())
    }

    // repeated float c64s = 12;


    pub fn get_c64s(&self) -> &[f32] {
        &self.c64s
    }
    pub fn clear_c64s(&mut self) {
        self.c64s.clear();
    }

    // Param is passed by value, moved
    pub fn set_c64s(&mut self, v: ::std::vec::Vec<f32>) {
        self.c64s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_c64s(&mut self) -> &mut ::std::vec::Vec<f32> {
        &mut self.c64s
    }

    // Take field
    pub fn take_c64s(&mut self) -> ::std::vec::Vec<f32> {
        ::std::mem::replace(&mut self.c64s, ::std::vec::Vec::new())
    }

    // repeated double c128s = 18;


    pub fn get_c128s(&self) -> &[f64] {
        &self.c128s
    }
    pub fn clear_c128s(&mut self) {
        self.c128s.clear();
    }

    // Param is passed by value, moved
    pub fn set_c128s(&mut self, v: ::std::vec::Vec<f64>) {
        self.c128s = v;
    }

    // Mutable pointer to the field.
    pub fn mut_c128s(&mut self) -> &mut ::std::vec::Vec<f64> {
        &mut self.c128s
    }

    // Take field
    pub fn take_c128s(&mut self) -> ::std::vec::Vec<f64> {
        ::std::mem::replace(&mut self.c128s, ::std::vec::Vec::new())
    }

    // repeated .xla.LiteralProto tuple_literals = 10;


    pub fn get_tuple_literals(&self) -> &[LiteralProto] {
        &self.tuple_literals
    }
    pub fn clear_tuple_literals(&mut self) {
        self.tuple_literals.clear();
    }

    // Param is passed by value, moved
    pub fn set_tuple_literals(&mut self, v: ::protobuf::RepeatedField<LiteralProto>) {
        self.tuple_literals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tuple_literals(&mut self) -> &mut ::protobuf::RepeatedField<LiteralProto> {
        &mut self.tuple_literals
    }

    // Take field
    pub fn take_tuple_literals(&mut self) -> ::protobuf::RepeatedField<LiteralProto> {
        ::std::mem::replace(&mut self.tuple_literals, ::protobuf::RepeatedField::new())
    }

    // bytes f16s = 11;


    pub fn get_f16s(&self) -> &[u8] {
        &self.f16s
    }
    pub fn clear_f16s(&mut self) {
        self.f16s.clear();
    }

    // Param is passed by value, moved
    pub fn set_f16s(&mut self, v: ::std::vec::Vec<u8>) {
        self.f16s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_f16s(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.f16s
    }

    // Take field
    pub fn take_f16s(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.f16s, ::std::vec::Vec::new())
    }

    // bytes bf16s = 13;


    pub fn get_bf16s(&self) -> &[u8] {
        &self.bf16s
    }
    pub fn clear_bf16s(&mut self) {
        self.bf16s.clear();
    }

    // Param is passed by value, moved
    pub fn set_bf16s(&mut self, v: ::std::vec::Vec<u8>) {
        self.bf16s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bf16s(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.bf16s
    }

    // Take field
    pub fn take_bf16s(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.bf16s, ::std::vec::Vec::new())
    }

    // bytes u16s = 16;


    pub fn get_u16s(&self) -> &[u8] {
        &self.u16s
    }
    pub fn clear_u16s(&mut self) {
        self.u16s.clear();
    }

    // Param is passed by value, moved
    pub fn set_u16s(&mut self, v: ::std::vec::Vec<u8>) {
        self.u16s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_u16s(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.u16s
    }

    // Take field
    pub fn take_u16s(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.u16s, ::std::vec::Vec::new())
    }

    // bytes s16s = 17;


    pub fn get_s16s(&self) -> &[u8] {
        &self.s16s
    }
    pub fn clear_s16s(&mut self) {
        self.s16s.clear();
    }

    // Param is passed by value, moved
    pub fn set_s16s(&mut self, v: ::std::vec::Vec<u8>) {
        self.s16s = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_s16s(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.s16s
    }

    // Take field
    pub fn take_s16s(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.s16s, ::std::vec::Vec::new())
    }

    // repeated int64 sparse_indices = 14;


    pub fn get_sparse_indices(&self) -> &[i64] {
        &self.sparse_indices
    }
    pub fn clear_sparse_indices(&mut self) {
        self.sparse_indices.clear();
    }

    // Param is passed by value, moved
    pub fn set_sparse_indices(&mut self, v: ::std::vec::Vec<i64>) {
        self.sparse_indices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sparse_indices(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.sparse_indices
    }

    // Take field
    pub fn take_sparse_indices(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.sparse_indices, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for LiteralProto {
    fn is_initialized(&self) -> bool {
        for v in &self.shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tuple_literals {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shape)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.preds)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.s8s)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.u8s)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.s32s)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.s64s)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.u32s)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_uint64_into(wire_type, is, &mut self.u64s)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.f32s)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.f64s)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_float_into(wire_type, is, &mut self.c64s)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_double_into(wire_type, is, &mut self.c128s)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tuple_literals)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.f16s)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.bf16s)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.u16s)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.s16s)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.sparse_indices)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += 2 * self.preds.len() as u32;
        if !self.s8s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.s8s);
        }
        if !self.u8s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.u8s);
        }
        for value in &self.s32s {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.s64s {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.u32s {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.u64s {
            my_size += ::protobuf::rt::value_size(7, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += 5 * self.f32s.len() as u32;
        my_size += 9 * self.f64s.len() as u32;
        my_size += 5 * self.c64s.len() as u32;
        my_size += 10 * self.c128s.len() as u32;
        for value in &self.tuple_literals {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.f16s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(11, &self.f16s);
        }
        if !self.bf16s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(13, &self.bf16s);
        }
        if !self.u16s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(16, &self.u16s);
        }
        if !self.s16s.is_empty() {
            my_size += ::protobuf::rt::bytes_size(17, &self.s16s);
        }
        for value in &self.sparse_indices {
            my_size += ::protobuf::rt::value_size(14, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.shape.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.preds {
            os.write_bool(2, *v)?;
        };
        if !self.s8s.is_empty() {
            os.write_bytes(15, &self.s8s)?;
        }
        if !self.u8s.is_empty() {
            os.write_bytes(3, &self.u8s)?;
        }
        for v in &self.s32s {
            os.write_int32(4, *v)?;
        };
        for v in &self.s64s {
            os.write_int64(5, *v)?;
        };
        for v in &self.u32s {
            os.write_uint32(6, *v)?;
        };
        for v in &self.u64s {
            os.write_uint64(7, *v)?;
        };
        for v in &self.f32s {
            os.write_float(8, *v)?;
        };
        for v in &self.f64s {
            os.write_double(9, *v)?;
        };
        for v in &self.c64s {
            os.write_float(12, *v)?;
        };
        for v in &self.c128s {
            os.write_double(18, *v)?;
        };
        for v in &self.tuple_literals {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.f16s.is_empty() {
            os.write_bytes(11, &self.f16s)?;
        }
        if !self.bf16s.is_empty() {
            os.write_bytes(13, &self.bf16s)?;
        }
        if !self.u16s.is_empty() {
            os.write_bytes(16, &self.u16s)?;
        }
        if !self.s16s.is_empty() {
            os.write_bytes(17, &self.s16s)?;
        }
        for v in &self.sparse_indices {
            os.write_int64(14, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LiteralProto {
        LiteralProto::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShapeProto>>(
                "shape",
                |m: &LiteralProto| { &m.shape },
                |m: &mut LiteralProto| { &mut m.shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "preds",
                |m: &LiteralProto| { &m.preds },
                |m: &mut LiteralProto| { &mut m.preds },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "s8s",
                |m: &LiteralProto| { &m.s8s },
                |m: &mut LiteralProto| { &mut m.s8s },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "u8s",
                |m: &LiteralProto| { &m.u8s },
                |m: &mut LiteralProto| { &mut m.u8s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "s32s",
                |m: &LiteralProto| { &m.s32s },
                |m: &mut LiteralProto| { &mut m.s32s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "s64s",
                |m: &LiteralProto| { &m.s64s },
                |m: &mut LiteralProto| { &mut m.s64s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "u32s",
                |m: &LiteralProto| { &m.u32s },
                |m: &mut LiteralProto| { &mut m.u32s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeUint64>(
                "u64s",
                |m: &LiteralProto| { &m.u64s },
                |m: &mut LiteralProto| { &mut m.u64s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "f32s",
                |m: &LiteralProto| { &m.f32s },
                |m: &mut LiteralProto| { &mut m.f32s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "f64s",
                |m: &LiteralProto| { &m.f64s },
                |m: &mut LiteralProto| { &mut m.f64s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeFloat>(
                "c64s",
                |m: &LiteralProto| { &m.c64s },
                |m: &mut LiteralProto| { &mut m.c64s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "c128s",
                |m: &LiteralProto| { &m.c128s },
                |m: &mut LiteralProto| { &mut m.c128s },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LiteralProto>>(
                "tuple_literals",
                |m: &LiteralProto| { &m.tuple_literals },
                |m: &mut LiteralProto| { &mut m.tuple_literals },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "f16s",
                |m: &LiteralProto| { &m.f16s },
                |m: &mut LiteralProto| { &mut m.f16s },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "bf16s",
                |m: &LiteralProto| { &m.bf16s },
                |m: &mut LiteralProto| { &mut m.bf16s },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "u16s",
                |m: &LiteralProto| { &m.u16s },
                |m: &mut LiteralProto| { &mut m.u16s },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "s16s",
                |m: &LiteralProto| { &m.s16s },
                |m: &mut LiteralProto| { &mut m.s16s },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sparse_indices",
                |m: &LiteralProto| { &m.sparse_indices },
                |m: &mut LiteralProto| { &mut m.sparse_indices },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LiteralProto>(
                "LiteralProto",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LiteralProto {
        static instance: ::protobuf::rt::LazyV2<LiteralProto> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LiteralProto::new)
    }
}

impl ::protobuf::Clear for LiteralProto {
    fn clear(&mut self) {
        self.shape.clear();
        self.preds.clear();
        self.s8s.clear();
        self.u8s.clear();
        self.s32s.clear();
        self.s64s.clear();
        self.u32s.clear();
        self.u64s.clear();
        self.f32s.clear();
        self.f64s.clear();
        self.c64s.clear();
        self.c128s.clear();
        self.tuple_literals.clear();
        self.f16s.clear();
        self.bf16s.clear();
        self.u16s.clear();
        self.s16s.clear();
        self.sparse_indices.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LiteralProto {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LiteralProto {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowDimension {
    // message fields
    pub size: i64,
    pub stride: i64,
    pub padding_low: i64,
    pub padding_high: i64,
    pub window_dilation: i64,
    pub base_dilation: i64,
    pub window_reversal: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowDimension {
    fn default() -> &'a WindowDimension {
        <WindowDimension as ::protobuf::Message>::default_instance()
    }
}

impl WindowDimension {
    pub fn new() -> WindowDimension {
        ::std::default::Default::default()
    }

    // int64 size = 1;


    pub fn get_size(&self) -> i64 {
        self.size
    }
    pub fn clear_size(&mut self) {
        self.size = 0;
    }

    // Param is passed by value, moved
    pub fn set_size(&mut self, v: i64) {
        self.size = v;
    }

    // int64 stride = 2;


    pub fn get_stride(&self) -> i64 {
        self.stride
    }
    pub fn clear_stride(&mut self) {
        self.stride = 0;
    }

    // Param is passed by value, moved
    pub fn set_stride(&mut self, v: i64) {
        self.stride = v;
    }

    // int64 padding_low = 3;


    pub fn get_padding_low(&self) -> i64 {
        self.padding_low
    }
    pub fn clear_padding_low(&mut self) {
        self.padding_low = 0;
    }

    // Param is passed by value, moved
    pub fn set_padding_low(&mut self, v: i64) {
        self.padding_low = v;
    }

    // int64 padding_high = 4;


    pub fn get_padding_high(&self) -> i64 {
        self.padding_high
    }
    pub fn clear_padding_high(&mut self) {
        self.padding_high = 0;
    }

    // Param is passed by value, moved
    pub fn set_padding_high(&mut self, v: i64) {
        self.padding_high = v;
    }

    // int64 window_dilation = 5;


    pub fn get_window_dilation(&self) -> i64 {
        self.window_dilation
    }
    pub fn clear_window_dilation(&mut self) {
        self.window_dilation = 0;
    }

    // Param is passed by value, moved
    pub fn set_window_dilation(&mut self, v: i64) {
        self.window_dilation = v;
    }

    // int64 base_dilation = 6;


    pub fn get_base_dilation(&self) -> i64 {
        self.base_dilation
    }
    pub fn clear_base_dilation(&mut self) {
        self.base_dilation = 0;
    }

    // Param is passed by value, moved
    pub fn set_base_dilation(&mut self, v: i64) {
        self.base_dilation = v;
    }

    // bool window_reversal = 7;


    pub fn get_window_reversal(&self) -> bool {
        self.window_reversal
    }
    pub fn clear_window_reversal(&mut self) {
        self.window_reversal = false;
    }

    // Param is passed by value, moved
    pub fn set_window_reversal(&mut self, v: bool) {
        self.window_reversal = v;
    }
}

impl ::protobuf::Message for WindowDimension {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.size = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.stride = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.padding_low = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.padding_high = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.window_dilation = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.base_dilation = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.window_reversal = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.size != 0 {
            my_size += ::protobuf::rt::value_size(1, self.size, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.stride != 0 {
            my_size += ::protobuf::rt::value_size(2, self.stride, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.padding_low != 0 {
            my_size += ::protobuf::rt::value_size(3, self.padding_low, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.padding_high != 0 {
            my_size += ::protobuf::rt::value_size(4, self.padding_high, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.window_dilation != 0 {
            my_size += ::protobuf::rt::value_size(5, self.window_dilation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.base_dilation != 0 {
            my_size += ::protobuf::rt::value_size(6, self.base_dilation, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.window_reversal != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.size != 0 {
            os.write_int64(1, self.size)?;
        }
        if self.stride != 0 {
            os.write_int64(2, self.stride)?;
        }
        if self.padding_low != 0 {
            os.write_int64(3, self.padding_low)?;
        }
        if self.padding_high != 0 {
            os.write_int64(4, self.padding_high)?;
        }
        if self.window_dilation != 0 {
            os.write_int64(5, self.window_dilation)?;
        }
        if self.base_dilation != 0 {
            os.write_int64(6, self.base_dilation)?;
        }
        if self.window_reversal != false {
            os.write_bool(7, self.window_reversal)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowDimension {
        WindowDimension::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "size",
                |m: &WindowDimension| { &m.size },
                |m: &mut WindowDimension| { &mut m.size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "stride",
                |m: &WindowDimension| { &m.stride },
                |m: &mut WindowDimension| { &mut m.stride },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "padding_low",
                |m: &WindowDimension| { &m.padding_low },
                |m: &mut WindowDimension| { &mut m.padding_low },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "padding_high",
                |m: &WindowDimension| { &m.padding_high },
                |m: &mut WindowDimension| { &mut m.padding_high },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "window_dilation",
                |m: &WindowDimension| { &m.window_dilation },
                |m: &mut WindowDimension| { &mut m.window_dilation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "base_dilation",
                |m: &WindowDimension| { &m.base_dilation },
                |m: &mut WindowDimension| { &mut m.base_dilation },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "window_reversal",
                |m: &WindowDimension| { &m.window_reversal },
                |m: &mut WindowDimension| { &mut m.window_reversal },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowDimension>(
                "WindowDimension",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowDimension {
        static instance: ::protobuf::rt::LazyV2<WindowDimension> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowDimension::new)
    }
}

impl ::protobuf::Clear for WindowDimension {
    fn clear(&mut self) {
        self.size = 0;
        self.stride = 0;
        self.padding_low = 0;
        self.padding_high = 0;
        self.window_dilation = 0;
        self.base_dilation = 0;
        self.window_reversal = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowDimension {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowDimension {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Window {
    // message fields
    pub dimensions: ::protobuf::RepeatedField<WindowDimension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Window {
    fn default() -> &'a Window {
        <Window as ::protobuf::Message>::default_instance()
    }
}

impl Window {
    pub fn new() -> Window {
        ::std::default::Default::default()
    }

    // repeated .xla.WindowDimension dimensions = 1;


    pub fn get_dimensions(&self) -> &[WindowDimension] {
        &self.dimensions
    }
    pub fn clear_dimensions(&mut self) {
        self.dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_dimensions(&mut self, v: ::protobuf::RepeatedField<WindowDimension>) {
        self.dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dimensions(&mut self) -> &mut ::protobuf::RepeatedField<WindowDimension> {
        &mut self.dimensions
    }

    // Take field
    pub fn take_dimensions(&mut self) -> ::protobuf::RepeatedField<WindowDimension> {
        ::std::mem::replace(&mut self.dimensions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Window {
    fn is_initialized(&self) -> bool {
        for v in &self.dimensions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.dimensions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dimensions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dimensions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Window {
        Window::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowDimension>>(
                "dimensions",
                |m: &Window| { &m.dimensions },
                |m: &mut Window| { &mut m.dimensions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Window>(
                "Window",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Window {
        static instance: ::protobuf::rt::LazyV2<Window> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Window::new)
    }
}

impl ::protobuf::Clear for Window {
    fn clear(&mut self) {
        self.dimensions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Window {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Window {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GatherDimensionNumbers {
    // message fields
    pub offset_dims: ::std::vec::Vec<i64>,
    pub collapsed_slice_dims: ::std::vec::Vec<i64>,
    pub start_index_map: ::std::vec::Vec<i64>,
    pub index_vector_dim: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GatherDimensionNumbers {
    fn default() -> &'a GatherDimensionNumbers {
        <GatherDimensionNumbers as ::protobuf::Message>::default_instance()
    }
}

impl GatherDimensionNumbers {
    pub fn new() -> GatherDimensionNumbers {
        ::std::default::Default::default()
    }

    // repeated int64 offset_dims = 1;


    pub fn get_offset_dims(&self) -> &[i64] {
        &self.offset_dims
    }
    pub fn clear_offset_dims(&mut self) {
        self.offset_dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_offset_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.offset_dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_offset_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.offset_dims
    }

    // Take field
    pub fn take_offset_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.offset_dims, ::std::vec::Vec::new())
    }

    // repeated int64 collapsed_slice_dims = 2;


    pub fn get_collapsed_slice_dims(&self) -> &[i64] {
        &self.collapsed_slice_dims
    }
    pub fn clear_collapsed_slice_dims(&mut self) {
        self.collapsed_slice_dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_collapsed_slice_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.collapsed_slice_dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_collapsed_slice_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.collapsed_slice_dims
    }

    // Take field
    pub fn take_collapsed_slice_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.collapsed_slice_dims, ::std::vec::Vec::new())
    }

    // repeated int64 start_index_map = 3;


    pub fn get_start_index_map(&self) -> &[i64] {
        &self.start_index_map
    }
    pub fn clear_start_index_map(&mut self) {
        self.start_index_map.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_index_map(&mut self, v: ::std::vec::Vec<i64>) {
        self.start_index_map = v;
    }

    // Mutable pointer to the field.
    pub fn mut_start_index_map(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.start_index_map
    }

    // Take field
    pub fn take_start_index_map(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.start_index_map, ::std::vec::Vec::new())
    }

    // int64 index_vector_dim = 4;


    pub fn get_index_vector_dim(&self) -> i64 {
        self.index_vector_dim
    }
    pub fn clear_index_vector_dim(&mut self) {
        self.index_vector_dim = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_vector_dim(&mut self, v: i64) {
        self.index_vector_dim = v;
    }
}

impl ::protobuf::Message for GatherDimensionNumbers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.offset_dims)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.collapsed_slice_dims)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.start_index_map)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index_vector_dim = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.offset_dims {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.collapsed_slice_dims {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.start_index_map {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.index_vector_dim != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index_vector_dim, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.offset_dims {
            os.write_int64(1, *v)?;
        };
        for v in &self.collapsed_slice_dims {
            os.write_int64(2, *v)?;
        };
        for v in &self.start_index_map {
            os.write_int64(3, *v)?;
        };
        if self.index_vector_dim != 0 {
            os.write_int64(4, self.index_vector_dim)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GatherDimensionNumbers {
        GatherDimensionNumbers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "offset_dims",
                |m: &GatherDimensionNumbers| { &m.offset_dims },
                |m: &mut GatherDimensionNumbers| { &mut m.offset_dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "collapsed_slice_dims",
                |m: &GatherDimensionNumbers| { &m.collapsed_slice_dims },
                |m: &mut GatherDimensionNumbers| { &mut m.collapsed_slice_dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "start_index_map",
                |m: &GatherDimensionNumbers| { &m.start_index_map },
                |m: &mut GatherDimensionNumbers| { &mut m.start_index_map },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index_vector_dim",
                |m: &GatherDimensionNumbers| { &m.index_vector_dim },
                |m: &mut GatherDimensionNumbers| { &mut m.index_vector_dim },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GatherDimensionNumbers>(
                "GatherDimensionNumbers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GatherDimensionNumbers {
        static instance: ::protobuf::rt::LazyV2<GatherDimensionNumbers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GatherDimensionNumbers::new)
    }
}

impl ::protobuf::Clear for GatherDimensionNumbers {
    fn clear(&mut self) {
        self.offset_dims.clear();
        self.collapsed_slice_dims.clear();
        self.start_index_map.clear();
        self.index_vector_dim = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GatherDimensionNumbers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GatherDimensionNumbers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScatterDimensionNumbers {
    // message fields
    pub update_window_dims: ::std::vec::Vec<i64>,
    pub inserted_window_dims: ::std::vec::Vec<i64>,
    pub scatter_dims_to_operand_dims: ::std::vec::Vec<i64>,
    pub index_vector_dim: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScatterDimensionNumbers {
    fn default() -> &'a ScatterDimensionNumbers {
        <ScatterDimensionNumbers as ::protobuf::Message>::default_instance()
    }
}

impl ScatterDimensionNumbers {
    pub fn new() -> ScatterDimensionNumbers {
        ::std::default::Default::default()
    }

    // repeated int64 update_window_dims = 1;


    pub fn get_update_window_dims(&self) -> &[i64] {
        &self.update_window_dims
    }
    pub fn clear_update_window_dims(&mut self) {
        self.update_window_dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_update_window_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.update_window_dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_update_window_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.update_window_dims
    }

    // Take field
    pub fn take_update_window_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.update_window_dims, ::std::vec::Vec::new())
    }

    // repeated int64 inserted_window_dims = 2;


    pub fn get_inserted_window_dims(&self) -> &[i64] {
        &self.inserted_window_dims
    }
    pub fn clear_inserted_window_dims(&mut self) {
        self.inserted_window_dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_inserted_window_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.inserted_window_dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inserted_window_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.inserted_window_dims
    }

    // Take field
    pub fn take_inserted_window_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.inserted_window_dims, ::std::vec::Vec::new())
    }

    // repeated int64 scatter_dims_to_operand_dims = 3;


    pub fn get_scatter_dims_to_operand_dims(&self) -> &[i64] {
        &self.scatter_dims_to_operand_dims
    }
    pub fn clear_scatter_dims_to_operand_dims(&mut self) {
        self.scatter_dims_to_operand_dims.clear();
    }

    // Param is passed by value, moved
    pub fn set_scatter_dims_to_operand_dims(&mut self, v: ::std::vec::Vec<i64>) {
        self.scatter_dims_to_operand_dims = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scatter_dims_to_operand_dims(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.scatter_dims_to_operand_dims
    }

    // Take field
    pub fn take_scatter_dims_to_operand_dims(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.scatter_dims_to_operand_dims, ::std::vec::Vec::new())
    }

    // int64 index_vector_dim = 4;


    pub fn get_index_vector_dim(&self) -> i64 {
        self.index_vector_dim
    }
    pub fn clear_index_vector_dim(&mut self) {
        self.index_vector_dim = 0;
    }

    // Param is passed by value, moved
    pub fn set_index_vector_dim(&mut self, v: i64) {
        self.index_vector_dim = v;
    }
}

impl ::protobuf::Message for ScatterDimensionNumbers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.update_window_dims)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.inserted_window_dims)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.scatter_dims_to_operand_dims)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.index_vector_dim = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.update_window_dims {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.inserted_window_dims {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.scatter_dims_to_operand_dims {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.index_vector_dim != 0 {
            my_size += ::protobuf::rt::value_size(4, self.index_vector_dim, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.update_window_dims {
            os.write_int64(1, *v)?;
        };
        for v in &self.inserted_window_dims {
            os.write_int64(2, *v)?;
        };
        for v in &self.scatter_dims_to_operand_dims {
            os.write_int64(3, *v)?;
        };
        if self.index_vector_dim != 0 {
            os.write_int64(4, self.index_vector_dim)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScatterDimensionNumbers {
        ScatterDimensionNumbers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "update_window_dims",
                |m: &ScatterDimensionNumbers| { &m.update_window_dims },
                |m: &mut ScatterDimensionNumbers| { &mut m.update_window_dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "inserted_window_dims",
                |m: &ScatterDimensionNumbers| { &m.inserted_window_dims },
                |m: &mut ScatterDimensionNumbers| { &mut m.inserted_window_dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "scatter_dims_to_operand_dims",
                |m: &ScatterDimensionNumbers| { &m.scatter_dims_to_operand_dims },
                |m: &mut ScatterDimensionNumbers| { &mut m.scatter_dims_to_operand_dims },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "index_vector_dim",
                |m: &ScatterDimensionNumbers| { &m.index_vector_dim },
                |m: &mut ScatterDimensionNumbers| { &mut m.index_vector_dim },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScatterDimensionNumbers>(
                "ScatterDimensionNumbers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScatterDimensionNumbers {
        static instance: ::protobuf::rt::LazyV2<ScatterDimensionNumbers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScatterDimensionNumbers::new)
    }
}

impl ::protobuf::Clear for ScatterDimensionNumbers {
    fn clear(&mut self) {
        self.update_window_dims.clear();
        self.inserted_window_dims.clear();
        self.scatter_dims_to_operand_dims.clear();
        self.index_vector_dim = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScatterDimensionNumbers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScatterDimensionNumbers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConvolutionDimensionNumbers {
    // message fields
    pub input_batch_dimension: i64,
    pub input_feature_dimension: i64,
    pub input_spatial_dimensions: ::std::vec::Vec<i64>,
    pub kernel_input_feature_dimension: i64,
    pub kernel_output_feature_dimension: i64,
    pub kernel_spatial_dimensions: ::std::vec::Vec<i64>,
    pub output_batch_dimension: i64,
    pub output_feature_dimension: i64,
    pub output_spatial_dimensions: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConvolutionDimensionNumbers {
    fn default() -> &'a ConvolutionDimensionNumbers {
        <ConvolutionDimensionNumbers as ::protobuf::Message>::default_instance()
    }
}

impl ConvolutionDimensionNumbers {
    pub fn new() -> ConvolutionDimensionNumbers {
        ::std::default::Default::default()
    }

    // int64 input_batch_dimension = 7;


    pub fn get_input_batch_dimension(&self) -> i64 {
        self.input_batch_dimension
    }
    pub fn clear_input_batch_dimension(&mut self) {
        self.input_batch_dimension = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_batch_dimension(&mut self, v: i64) {
        self.input_batch_dimension = v;
    }

    // int64 input_feature_dimension = 8;


    pub fn get_input_feature_dimension(&self) -> i64 {
        self.input_feature_dimension
    }
    pub fn clear_input_feature_dimension(&mut self) {
        self.input_feature_dimension = 0;
    }

    // Param is passed by value, moved
    pub fn set_input_feature_dimension(&mut self, v: i64) {
        self.input_feature_dimension = v;
    }

    // repeated int64 input_spatial_dimensions = 11;


    pub fn get_input_spatial_dimensions(&self) -> &[i64] {
        &self.input_spatial_dimensions
    }
    pub fn clear_input_spatial_dimensions(&mut self) {
        self.input_spatial_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_input_spatial_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.input_spatial_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_input_spatial_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.input_spatial_dimensions
    }

    // Take field
    pub fn take_input_spatial_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.input_spatial_dimensions, ::std::vec::Vec::new())
    }

    // int64 kernel_input_feature_dimension = 3;


    pub fn get_kernel_input_feature_dimension(&self) -> i64 {
        self.kernel_input_feature_dimension
    }
    pub fn clear_kernel_input_feature_dimension(&mut self) {
        self.kernel_input_feature_dimension = 0;
    }

    // Param is passed by value, moved
    pub fn set_kernel_input_feature_dimension(&mut self, v: i64) {
        self.kernel_input_feature_dimension = v;
    }

    // int64 kernel_output_feature_dimension = 4;


    pub fn get_kernel_output_feature_dimension(&self) -> i64 {
        self.kernel_output_feature_dimension
    }
    pub fn clear_kernel_output_feature_dimension(&mut self) {
        self.kernel_output_feature_dimension = 0;
    }

    // Param is passed by value, moved
    pub fn set_kernel_output_feature_dimension(&mut self, v: i64) {
        self.kernel_output_feature_dimension = v;
    }

    // repeated int64 kernel_spatial_dimensions = 6;


    pub fn get_kernel_spatial_dimensions(&self) -> &[i64] {
        &self.kernel_spatial_dimensions
    }
    pub fn clear_kernel_spatial_dimensions(&mut self) {
        self.kernel_spatial_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_kernel_spatial_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.kernel_spatial_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_kernel_spatial_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.kernel_spatial_dimensions
    }

    // Take field
    pub fn take_kernel_spatial_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.kernel_spatial_dimensions, ::std::vec::Vec::new())
    }

    // int64 output_batch_dimension = 9;


    pub fn get_output_batch_dimension(&self) -> i64 {
        self.output_batch_dimension
    }
    pub fn clear_output_batch_dimension(&mut self) {
        self.output_batch_dimension = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_batch_dimension(&mut self, v: i64) {
        self.output_batch_dimension = v;
    }

    // int64 output_feature_dimension = 10;


    pub fn get_output_feature_dimension(&self) -> i64 {
        self.output_feature_dimension
    }
    pub fn clear_output_feature_dimension(&mut self) {
        self.output_feature_dimension = 0;
    }

    // Param is passed by value, moved
    pub fn set_output_feature_dimension(&mut self, v: i64) {
        self.output_feature_dimension = v;
    }

    // repeated int64 output_spatial_dimensions = 12;


    pub fn get_output_spatial_dimensions(&self) -> &[i64] {
        &self.output_spatial_dimensions
    }
    pub fn clear_output_spatial_dimensions(&mut self) {
        self.output_spatial_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_output_spatial_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.output_spatial_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_output_spatial_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.output_spatial_dimensions
    }

    // Take field
    pub fn take_output_spatial_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.output_spatial_dimensions, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ConvolutionDimensionNumbers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.input_batch_dimension = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.input_feature_dimension = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.input_spatial_dimensions)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.kernel_input_feature_dimension = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.kernel_output_feature_dimension = tmp;
                },
                6 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.kernel_spatial_dimensions)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.output_batch_dimension = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.output_feature_dimension = tmp;
                },
                12 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.output_spatial_dimensions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.input_batch_dimension != 0 {
            my_size += ::protobuf::rt::value_size(7, self.input_batch_dimension, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.input_feature_dimension != 0 {
            my_size += ::protobuf::rt::value_size(8, self.input_feature_dimension, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.input_spatial_dimensions {
            my_size += ::protobuf::rt::value_size(11, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.kernel_input_feature_dimension != 0 {
            my_size += ::protobuf::rt::value_size(3, self.kernel_input_feature_dimension, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.kernel_output_feature_dimension != 0 {
            my_size += ::protobuf::rt::value_size(4, self.kernel_output_feature_dimension, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.kernel_spatial_dimensions {
            my_size += ::protobuf::rt::value_size(6, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if self.output_batch_dimension != 0 {
            my_size += ::protobuf::rt::value_size(9, self.output_batch_dimension, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.output_feature_dimension != 0 {
            my_size += ::protobuf::rt::value_size(10, self.output_feature_dimension, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.output_spatial_dimensions {
            my_size += ::protobuf::rt::value_size(12, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.input_batch_dimension != 0 {
            os.write_int64(7, self.input_batch_dimension)?;
        }
        if self.input_feature_dimension != 0 {
            os.write_int64(8, self.input_feature_dimension)?;
        }
        for v in &self.input_spatial_dimensions {
            os.write_int64(11, *v)?;
        };
        if self.kernel_input_feature_dimension != 0 {
            os.write_int64(3, self.kernel_input_feature_dimension)?;
        }
        if self.kernel_output_feature_dimension != 0 {
            os.write_int64(4, self.kernel_output_feature_dimension)?;
        }
        for v in &self.kernel_spatial_dimensions {
            os.write_int64(6, *v)?;
        };
        if self.output_batch_dimension != 0 {
            os.write_int64(9, self.output_batch_dimension)?;
        }
        if self.output_feature_dimension != 0 {
            os.write_int64(10, self.output_feature_dimension)?;
        }
        for v in &self.output_spatial_dimensions {
            os.write_int64(12, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConvolutionDimensionNumbers {
        ConvolutionDimensionNumbers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "input_batch_dimension",
                |m: &ConvolutionDimensionNumbers| { &m.input_batch_dimension },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.input_batch_dimension },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "input_feature_dimension",
                |m: &ConvolutionDimensionNumbers| { &m.input_feature_dimension },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.input_feature_dimension },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "input_spatial_dimensions",
                |m: &ConvolutionDimensionNumbers| { &m.input_spatial_dimensions },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.input_spatial_dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "kernel_input_feature_dimension",
                |m: &ConvolutionDimensionNumbers| { &m.kernel_input_feature_dimension },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.kernel_input_feature_dimension },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "kernel_output_feature_dimension",
                |m: &ConvolutionDimensionNumbers| { &m.kernel_output_feature_dimension },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.kernel_output_feature_dimension },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "kernel_spatial_dimensions",
                |m: &ConvolutionDimensionNumbers| { &m.kernel_spatial_dimensions },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.kernel_spatial_dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "output_batch_dimension",
                |m: &ConvolutionDimensionNumbers| { &m.output_batch_dimension },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.output_batch_dimension },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "output_feature_dimension",
                |m: &ConvolutionDimensionNumbers| { &m.output_feature_dimension },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.output_feature_dimension },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "output_spatial_dimensions",
                |m: &ConvolutionDimensionNumbers| { &m.output_spatial_dimensions },
                |m: &mut ConvolutionDimensionNumbers| { &mut m.output_spatial_dimensions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConvolutionDimensionNumbers>(
                "ConvolutionDimensionNumbers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConvolutionDimensionNumbers {
        static instance: ::protobuf::rt::LazyV2<ConvolutionDimensionNumbers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConvolutionDimensionNumbers::new)
    }
}

impl ::protobuf::Clear for ConvolutionDimensionNumbers {
    fn clear(&mut self) {
        self.input_batch_dimension = 0;
        self.input_feature_dimension = 0;
        self.input_spatial_dimensions.clear();
        self.kernel_input_feature_dimension = 0;
        self.kernel_output_feature_dimension = 0;
        self.kernel_spatial_dimensions.clear();
        self.output_batch_dimension = 0;
        self.output_feature_dimension = 0;
        self.output_spatial_dimensions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConvolutionDimensionNumbers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConvolutionDimensionNumbers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DotDimensionNumbers {
    // message fields
    pub lhs_contracting_dimensions: ::std::vec::Vec<i64>,
    pub rhs_contracting_dimensions: ::std::vec::Vec<i64>,
    pub lhs_batch_dimensions: ::std::vec::Vec<i64>,
    pub rhs_batch_dimensions: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DotDimensionNumbers {
    fn default() -> &'a DotDimensionNumbers {
        <DotDimensionNumbers as ::protobuf::Message>::default_instance()
    }
}

impl DotDimensionNumbers {
    pub fn new() -> DotDimensionNumbers {
        ::std::default::Default::default()
    }

    // repeated int64 lhs_contracting_dimensions = 1;


    pub fn get_lhs_contracting_dimensions(&self) -> &[i64] {
        &self.lhs_contracting_dimensions
    }
    pub fn clear_lhs_contracting_dimensions(&mut self) {
        self.lhs_contracting_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_lhs_contracting_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.lhs_contracting_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lhs_contracting_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.lhs_contracting_dimensions
    }

    // Take field
    pub fn take_lhs_contracting_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.lhs_contracting_dimensions, ::std::vec::Vec::new())
    }

    // repeated int64 rhs_contracting_dimensions = 2;


    pub fn get_rhs_contracting_dimensions(&self) -> &[i64] {
        &self.rhs_contracting_dimensions
    }
    pub fn clear_rhs_contracting_dimensions(&mut self) {
        self.rhs_contracting_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_rhs_contracting_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.rhs_contracting_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rhs_contracting_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.rhs_contracting_dimensions
    }

    // Take field
    pub fn take_rhs_contracting_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.rhs_contracting_dimensions, ::std::vec::Vec::new())
    }

    // repeated int64 lhs_batch_dimensions = 3;


    pub fn get_lhs_batch_dimensions(&self) -> &[i64] {
        &self.lhs_batch_dimensions
    }
    pub fn clear_lhs_batch_dimensions(&mut self) {
        self.lhs_batch_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_lhs_batch_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.lhs_batch_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lhs_batch_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.lhs_batch_dimensions
    }

    // Take field
    pub fn take_lhs_batch_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.lhs_batch_dimensions, ::std::vec::Vec::new())
    }

    // repeated int64 rhs_batch_dimensions = 4;


    pub fn get_rhs_batch_dimensions(&self) -> &[i64] {
        &self.rhs_batch_dimensions
    }
    pub fn clear_rhs_batch_dimensions(&mut self) {
        self.rhs_batch_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_rhs_batch_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.rhs_batch_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_rhs_batch_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.rhs_batch_dimensions
    }

    // Take field
    pub fn take_rhs_batch_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.rhs_batch_dimensions, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DotDimensionNumbers {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.lhs_contracting_dimensions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.rhs_contracting_dimensions)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.lhs_batch_dimensions)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.rhs_batch_dimensions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.lhs_contracting_dimensions {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.rhs_contracting_dimensions {
            my_size += ::protobuf::rt::value_size(2, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.lhs_batch_dimensions {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.rhs_batch_dimensions {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.lhs_contracting_dimensions {
            os.write_int64(1, *v)?;
        };
        for v in &self.rhs_contracting_dimensions {
            os.write_int64(2, *v)?;
        };
        for v in &self.lhs_batch_dimensions {
            os.write_int64(3, *v)?;
        };
        for v in &self.rhs_batch_dimensions {
            os.write_int64(4, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DotDimensionNumbers {
        DotDimensionNumbers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lhs_contracting_dimensions",
                |m: &DotDimensionNumbers| { &m.lhs_contracting_dimensions },
                |m: &mut DotDimensionNumbers| { &mut m.lhs_contracting_dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "rhs_contracting_dimensions",
                |m: &DotDimensionNumbers| { &m.rhs_contracting_dimensions },
                |m: &mut DotDimensionNumbers| { &mut m.rhs_contracting_dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lhs_batch_dimensions",
                |m: &DotDimensionNumbers| { &m.lhs_batch_dimensions },
                |m: &mut DotDimensionNumbers| { &mut m.lhs_batch_dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "rhs_batch_dimensions",
                |m: &DotDimensionNumbers| { &m.rhs_batch_dimensions },
                |m: &mut DotDimensionNumbers| { &mut m.rhs_batch_dimensions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DotDimensionNumbers>(
                "DotDimensionNumbers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DotDimensionNumbers {
        static instance: ::protobuf::rt::LazyV2<DotDimensionNumbers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DotDimensionNumbers::new)
    }
}

impl ::protobuf::Clear for DotDimensionNumbers {
    fn clear(&mut self) {
        self.lhs_contracting_dimensions.clear();
        self.rhs_contracting_dimensions.clear();
        self.lhs_batch_dimensions.clear();
        self.rhs_batch_dimensions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DotDimensionNumbers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DotDimensionNumbers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TriangularSolveOptions {
    // message fields
    pub left_side: bool,
    pub lower: bool,
    pub unit_diagonal: bool,
    pub transpose_a: TriangularSolveOptions_Transpose,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TriangularSolveOptions {
    fn default() -> &'a TriangularSolveOptions {
        <TriangularSolveOptions as ::protobuf::Message>::default_instance()
    }
}

impl TriangularSolveOptions {
    pub fn new() -> TriangularSolveOptions {
        ::std::default::Default::default()
    }

    // bool left_side = 1;


    pub fn get_left_side(&self) -> bool {
        self.left_side
    }
    pub fn clear_left_side(&mut self) {
        self.left_side = false;
    }

    // Param is passed by value, moved
    pub fn set_left_side(&mut self, v: bool) {
        self.left_side = v;
    }

    // bool lower = 2;


    pub fn get_lower(&self) -> bool {
        self.lower
    }
    pub fn clear_lower(&mut self) {
        self.lower = false;
    }

    // Param is passed by value, moved
    pub fn set_lower(&mut self, v: bool) {
        self.lower = v;
    }

    // bool unit_diagonal = 3;


    pub fn get_unit_diagonal(&self) -> bool {
        self.unit_diagonal
    }
    pub fn clear_unit_diagonal(&mut self) {
        self.unit_diagonal = false;
    }

    // Param is passed by value, moved
    pub fn set_unit_diagonal(&mut self, v: bool) {
        self.unit_diagonal = v;
    }

    // .xla.TriangularSolveOptions.Transpose transpose_a = 4;


    pub fn get_transpose_a(&self) -> TriangularSolveOptions_Transpose {
        self.transpose_a
    }
    pub fn clear_transpose_a(&mut self) {
        self.transpose_a = TriangularSolveOptions_Transpose::TRANSPOSE_INVALID;
    }

    // Param is passed by value, moved
    pub fn set_transpose_a(&mut self, v: TriangularSolveOptions_Transpose) {
        self.transpose_a = v;
    }
}

impl ::protobuf::Message for TriangularSolveOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.left_side = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lower = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unit_diagonal = tmp;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.transpose_a, 4, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.left_side != false {
            my_size += 2;
        }
        if self.lower != false {
            my_size += 2;
        }
        if self.unit_diagonal != false {
            my_size += 2;
        }
        if self.transpose_a != TriangularSolveOptions_Transpose::TRANSPOSE_INVALID {
            my_size += ::protobuf::rt::enum_size(4, self.transpose_a);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.left_side != false {
            os.write_bool(1, self.left_side)?;
        }
        if self.lower != false {
            os.write_bool(2, self.lower)?;
        }
        if self.unit_diagonal != false {
            os.write_bool(3, self.unit_diagonal)?;
        }
        if self.transpose_a != TriangularSolveOptions_Transpose::TRANSPOSE_INVALID {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.transpose_a))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TriangularSolveOptions {
        TriangularSolveOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "left_side",
                |m: &TriangularSolveOptions| { &m.left_side },
                |m: &mut TriangularSolveOptions| { &mut m.left_side },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lower",
                |m: &TriangularSolveOptions| { &m.lower },
                |m: &mut TriangularSolveOptions| { &mut m.lower },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unit_diagonal",
                |m: &TriangularSolveOptions| { &m.unit_diagonal },
                |m: &mut TriangularSolveOptions| { &mut m.unit_diagonal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TriangularSolveOptions_Transpose>>(
                "transpose_a",
                |m: &TriangularSolveOptions| { &m.transpose_a },
                |m: &mut TriangularSolveOptions| { &mut m.transpose_a },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TriangularSolveOptions>(
                "TriangularSolveOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TriangularSolveOptions {
        static instance: ::protobuf::rt::LazyV2<TriangularSolveOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TriangularSolveOptions::new)
    }
}

impl ::protobuf::Clear for TriangularSolveOptions {
    fn clear(&mut self) {
        self.left_side = false;
        self.lower = false;
        self.unit_diagonal = false;
        self.transpose_a = TriangularSolveOptions_Transpose::TRANSPOSE_INVALID;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TriangularSolveOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TriangularSolveOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum TriangularSolveOptions_Transpose {
    TRANSPOSE_INVALID = 0,
    NO_TRANSPOSE = 1,
    TRANSPOSE = 2,
    ADJOINT = 3,
}

impl ::protobuf::ProtobufEnum for TriangularSolveOptions_Transpose {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TriangularSolveOptions_Transpose> {
        match value {
            0 => ::std::option::Option::Some(TriangularSolveOptions_Transpose::TRANSPOSE_INVALID),
            1 => ::std::option::Option::Some(TriangularSolveOptions_Transpose::NO_TRANSPOSE),
            2 => ::std::option::Option::Some(TriangularSolveOptions_Transpose::TRANSPOSE),
            3 => ::std::option::Option::Some(TriangularSolveOptions_Transpose::ADJOINT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TriangularSolveOptions_Transpose] = &[
            TriangularSolveOptions_Transpose::TRANSPOSE_INVALID,
            TriangularSolveOptions_Transpose::NO_TRANSPOSE,
            TriangularSolveOptions_Transpose::TRANSPOSE,
            TriangularSolveOptions_Transpose::ADJOINT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<TriangularSolveOptions_Transpose>("TriangularSolveOptions.Transpose", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for TriangularSolveOptions_Transpose {
}

impl ::std::default::Default for TriangularSolveOptions_Transpose {
    fn default() -> Self {
        TriangularSolveOptions_Transpose::TRANSPOSE_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for TriangularSolveOptions_Transpose {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CholeskyOptions {
    // message fields
    pub lower: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CholeskyOptions {
    fn default() -> &'a CholeskyOptions {
        <CholeskyOptions as ::protobuf::Message>::default_instance()
    }
}

impl CholeskyOptions {
    pub fn new() -> CholeskyOptions {
        ::std::default::Default::default()
    }

    // bool lower = 1;


    pub fn get_lower(&self) -> bool {
        self.lower
    }
    pub fn clear_lower(&mut self) {
        self.lower = false;
    }

    // Param is passed by value, moved
    pub fn set_lower(&mut self, v: bool) {
        self.lower = v;
    }
}

impl ::protobuf::Message for CholeskyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.lower = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.lower != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.lower != false {
            os.write_bool(1, self.lower)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CholeskyOptions {
        CholeskyOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "lower",
                |m: &CholeskyOptions| { &m.lower },
                |m: &mut CholeskyOptions| { &mut m.lower },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CholeskyOptions>(
                "CholeskyOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CholeskyOptions {
        static instance: ::protobuf::rt::LazyV2<CholeskyOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CholeskyOptions::new)
    }
}

impl ::protobuf::Clear for CholeskyOptions {
    fn clear(&mut self) {
        self.lower = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CholeskyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CholeskyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OpSharding {
    // message fields
    pub field_type: OpSharding_Type,
    pub tile_shape: ::protobuf::SingularPtrField<ShapeProto>,
    pub tile_assignment_dimensions: ::std::vec::Vec<i64>,
    pub tile_assignment_devices: ::std::vec::Vec<i64>,
    pub tuple_shardings: ::protobuf::RepeatedField<OpSharding>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OpSharding {
    fn default() -> &'a OpSharding {
        <OpSharding as ::protobuf::Message>::default_instance()
    }
}

impl OpSharding {
    pub fn new() -> OpSharding {
        ::std::default::Default::default()
    }

    // .xla.OpSharding.Type type = 1;


    pub fn get_field_type(&self) -> OpSharding_Type {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = OpSharding_Type::REPLICATED;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: OpSharding_Type) {
        self.field_type = v;
    }

    // .xla.ShapeProto tile_shape = 2;


    pub fn get_tile_shape(&self) -> &ShapeProto {
        self.tile_shape.as_ref().unwrap_or_else(|| <ShapeProto as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tile_shape(&mut self) {
        self.tile_shape.clear();
    }

    pub fn has_tile_shape(&self) -> bool {
        self.tile_shape.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tile_shape(&mut self, v: ShapeProto) {
        self.tile_shape = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tile_shape(&mut self) -> &mut ShapeProto {
        if self.tile_shape.is_none() {
            self.tile_shape.set_default();
        }
        self.tile_shape.as_mut().unwrap()
    }

    // Take field
    pub fn take_tile_shape(&mut self) -> ShapeProto {
        self.tile_shape.take().unwrap_or_else(|| ShapeProto::new())
    }

    // repeated int64 tile_assignment_dimensions = 3;


    pub fn get_tile_assignment_dimensions(&self) -> &[i64] {
        &self.tile_assignment_dimensions
    }
    pub fn clear_tile_assignment_dimensions(&mut self) {
        self.tile_assignment_dimensions.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_assignment_dimensions(&mut self, v: ::std::vec::Vec<i64>) {
        self.tile_assignment_dimensions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_assignment_dimensions(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.tile_assignment_dimensions
    }

    // Take field
    pub fn take_tile_assignment_dimensions(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.tile_assignment_dimensions, ::std::vec::Vec::new())
    }

    // repeated int64 tile_assignment_devices = 4;


    pub fn get_tile_assignment_devices(&self) -> &[i64] {
        &self.tile_assignment_devices
    }
    pub fn clear_tile_assignment_devices(&mut self) {
        self.tile_assignment_devices.clear();
    }

    // Param is passed by value, moved
    pub fn set_tile_assignment_devices(&mut self, v: ::std::vec::Vec<i64>) {
        self.tile_assignment_devices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tile_assignment_devices(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.tile_assignment_devices
    }

    // Take field
    pub fn take_tile_assignment_devices(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.tile_assignment_devices, ::std::vec::Vec::new())
    }

    // repeated .xla.OpSharding tuple_shardings = 5;


    pub fn get_tuple_shardings(&self) -> &[OpSharding] {
        &self.tuple_shardings
    }
    pub fn clear_tuple_shardings(&mut self) {
        self.tuple_shardings.clear();
    }

    // Param is passed by value, moved
    pub fn set_tuple_shardings(&mut self, v: ::protobuf::RepeatedField<OpSharding>) {
        self.tuple_shardings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tuple_shardings(&mut self) -> &mut ::protobuf::RepeatedField<OpSharding> {
        &mut self.tuple_shardings
    }

    // Take field
    pub fn take_tuple_shardings(&mut self) -> ::protobuf::RepeatedField<OpSharding> {
        ::std::mem::replace(&mut self.tuple_shardings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OpSharding {
    fn is_initialized(&self) -> bool {
        for v in &self.tile_shape {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tuple_shardings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tile_shape)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.tile_assignment_dimensions)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.tile_assignment_devices)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tuple_shardings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != OpSharding_Type::REPLICATED {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if let Some(ref v) = self.tile_shape.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tile_assignment_dimensions {
            my_size += ::protobuf::rt::value_size(3, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tile_assignment_devices {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        for value in &self.tuple_shardings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != OpSharding_Type::REPLICATED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.field_type))?;
        }
        if let Some(ref v) = self.tile_shape.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tile_assignment_dimensions {
            os.write_int64(3, *v)?;
        };
        for v in &self.tile_assignment_devices {
            os.write_int64(4, *v)?;
        };
        for v in &self.tuple_shardings {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OpSharding {
        OpSharding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<OpSharding_Type>>(
                "type",
                |m: &OpSharding| { &m.field_type },
                |m: &mut OpSharding| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShapeProto>>(
                "tile_shape",
                |m: &OpSharding| { &m.tile_shape },
                |m: &mut OpSharding| { &mut m.tile_shape },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tile_assignment_dimensions",
                |m: &OpSharding| { &m.tile_assignment_dimensions },
                |m: &mut OpSharding| { &mut m.tile_assignment_dimensions },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tile_assignment_devices",
                |m: &OpSharding| { &m.tile_assignment_devices },
                |m: &mut OpSharding| { &mut m.tile_assignment_devices },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OpSharding>>(
                "tuple_shardings",
                |m: &OpSharding| { &m.tuple_shardings },
                |m: &mut OpSharding| { &mut m.tuple_shardings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OpSharding>(
                "OpSharding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OpSharding {
        static instance: ::protobuf::rt::LazyV2<OpSharding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OpSharding::new)
    }
}

impl ::protobuf::Clear for OpSharding {
    fn clear(&mut self) {
        self.field_type = OpSharding_Type::REPLICATED;
        self.tile_shape.clear();
        self.tile_assignment_dimensions.clear();
        self.tile_assignment_devices.clear();
        self.tuple_shardings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OpSharding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OpSharding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum OpSharding_Type {
    REPLICATED = 0,
    MAXIMAL = 1,
    TUPLE = 2,
    OTHER = 3,
}

impl ::protobuf::ProtobufEnum for OpSharding_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<OpSharding_Type> {
        match value {
            0 => ::std::option::Option::Some(OpSharding_Type::REPLICATED),
            1 => ::std::option::Option::Some(OpSharding_Type::MAXIMAL),
            2 => ::std::option::Option::Some(OpSharding_Type::TUPLE),
            3 => ::std::option::Option::Some(OpSharding_Type::OTHER),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [OpSharding_Type] = &[
            OpSharding_Type::REPLICATED,
            OpSharding_Type::MAXIMAL,
            OpSharding_Type::TUPLE,
            OpSharding_Type::OTHER,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<OpSharding_Type>("OpSharding.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for OpSharding_Type {
}

impl ::std::default::Default for OpSharding_Type {
    fn default() -> Self {
        OpSharding_Type::REPLICATED
    }
}

impl ::protobuf::reflect::ProtobufValue for OpSharding_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicaGroup {
    // message fields
    pub replica_ids: ::std::vec::Vec<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicaGroup {
    fn default() -> &'a ReplicaGroup {
        <ReplicaGroup as ::protobuf::Message>::default_instance()
    }
}

impl ReplicaGroup {
    pub fn new() -> ReplicaGroup {
        ::std::default::Default::default()
    }

    // repeated int64 replica_ids = 1;


    pub fn get_replica_ids(&self) -> &[i64] {
        &self.replica_ids
    }
    pub fn clear_replica_ids(&mut self) {
        self.replica_ids.clear();
    }

    // Param is passed by value, moved
    pub fn set_replica_ids(&mut self, v: ::std::vec::Vec<i64>) {
        self.replica_ids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replica_ids(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.replica_ids
    }

    // Take field
    pub fn take_replica_ids(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.replica_ids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ReplicaGroup {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.replica_ids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.replica_ids {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.replica_ids {
            os.write_int64(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicaGroup {
        ReplicaGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "replica_ids",
                |m: &ReplicaGroup| { &m.replica_ids },
                |m: &mut ReplicaGroup| { &mut m.replica_ids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicaGroup>(
                "ReplicaGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplicaGroup {
        static instance: ::protobuf::rt::LazyV2<ReplicaGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicaGroup::new)
    }
}

impl ::protobuf::Clear for ReplicaGroup {
    fn clear(&mut self) {
        self.replica_ids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicaGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicaGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SourceTarget {
    // message fields
    pub source: i64,
    pub target: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SourceTarget {
    fn default() -> &'a SourceTarget {
        <SourceTarget as ::protobuf::Message>::default_instance()
    }
}

impl SourceTarget {
    pub fn new() -> SourceTarget {
        ::std::default::Default::default()
    }

    // int64 source = 1;


    pub fn get_source(&self) -> i64 {
        self.source
    }
    pub fn clear_source(&mut self) {
        self.source = 0;
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: i64) {
        self.source = v;
    }

    // int64 target = 2;


    pub fn get_target(&self) -> i64 {
        self.target
    }
    pub fn clear_target(&mut self) {
        self.target = 0;
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: i64) {
        self.target = v;
    }
}

impl ::protobuf::Message for SourceTarget {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.source = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.target = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.source != 0 {
            my_size += ::protobuf::rt::value_size(1, self.source, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.target != 0 {
            my_size += ::protobuf::rt::value_size(2, self.target, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.source != 0 {
            os.write_int64(1, self.source)?;
        }
        if self.target != 0 {
            os.write_int64(2, self.target)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SourceTarget {
        SourceTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "source",
                |m: &SourceTarget| { &m.source },
                |m: &mut SourceTarget| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "target",
                |m: &SourceTarget| { &m.target },
                |m: &mut SourceTarget| { &mut m.target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SourceTarget>(
                "SourceTarget",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SourceTarget {
        static instance: ::protobuf::rt::LazyV2<SourceTarget> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SourceTarget::new)
    }
}

impl ::protobuf::Clear for SourceTarget {
    fn clear(&mut self) {
        self.source = 0;
        self.target = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SourceTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SourceTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrecisionConfig {
    // message fields
    pub operand_precision: ::std::vec::Vec<PrecisionConfig_Precision>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrecisionConfig {
    fn default() -> &'a PrecisionConfig {
        <PrecisionConfig as ::protobuf::Message>::default_instance()
    }
}

impl PrecisionConfig {
    pub fn new() -> PrecisionConfig {
        ::std::default::Default::default()
    }

    // repeated .xla.PrecisionConfig.Precision operand_precision = 1;


    pub fn get_operand_precision(&self) -> &[PrecisionConfig_Precision] {
        &self.operand_precision
    }
    pub fn clear_operand_precision(&mut self) {
        self.operand_precision.clear();
    }

    // Param is passed by value, moved
    pub fn set_operand_precision(&mut self, v: ::std::vec::Vec<PrecisionConfig_Precision>) {
        self.operand_precision = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operand_precision(&mut self) -> &mut ::std::vec::Vec<PrecisionConfig_Precision> {
        &mut self.operand_precision
    }

    // Take field
    pub fn take_operand_precision(&mut self) -> ::std::vec::Vec<PrecisionConfig_Precision> {
        ::std::mem::replace(&mut self.operand_precision, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PrecisionConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_enum_with_unknown_fields_into(wire_type, is, &mut self.operand_precision, 1, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.operand_precision {
            my_size += ::protobuf::rt::enum_size(1, *value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.operand_precision {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(v))?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrecisionConfig {
        PrecisionConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PrecisionConfig_Precision>>(
                "operand_precision",
                |m: &PrecisionConfig| { &m.operand_precision },
                |m: &mut PrecisionConfig| { &mut m.operand_precision },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrecisionConfig>(
                "PrecisionConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrecisionConfig {
        static instance: ::protobuf::rt::LazyV2<PrecisionConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrecisionConfig::new)
    }
}

impl ::protobuf::Clear for PrecisionConfig {
    fn clear(&mut self) {
        self.operand_precision.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrecisionConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrecisionConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrecisionConfig_Precision {
    DEFAULT = 0,
    HIGH = 1,
    HIGHEST = 2,
}

impl ::protobuf::ProtobufEnum for PrecisionConfig_Precision {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrecisionConfig_Precision> {
        match value {
            0 => ::std::option::Option::Some(PrecisionConfig_Precision::DEFAULT),
            1 => ::std::option::Option::Some(PrecisionConfig_Precision::HIGH),
            2 => ::std::option::Option::Some(PrecisionConfig_Precision::HIGHEST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrecisionConfig_Precision] = &[
            PrecisionConfig_Precision::DEFAULT,
            PrecisionConfig_Precision::HIGH,
            PrecisionConfig_Precision::HIGHEST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PrecisionConfig_Precision>("PrecisionConfig.Precision", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PrecisionConfig_Precision {
}

impl ::std::default::Default for PrecisionConfig_Precision {
    fn default() -> Self {
        PrecisionConfig_Precision::DEFAULT
    }
}

impl ::protobuf::reflect::ProtobufValue for PrecisionConfig_Precision {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ParameterReplication {
    // message fields
    pub replicated_at_leaf_buffers: ::std::vec::Vec<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ParameterReplication {
    fn default() -> &'a ParameterReplication {
        <ParameterReplication as ::protobuf::Message>::default_instance()
    }
}

impl ParameterReplication {
    pub fn new() -> ParameterReplication {
        ::std::default::Default::default()
    }

    // repeated bool replicated_at_leaf_buffers = 1;


    pub fn get_replicated_at_leaf_buffers(&self) -> &[bool] {
        &self.replicated_at_leaf_buffers
    }
    pub fn clear_replicated_at_leaf_buffers(&mut self) {
        self.replicated_at_leaf_buffers.clear();
    }

    // Param is passed by value, moved
    pub fn set_replicated_at_leaf_buffers(&mut self, v: ::std::vec::Vec<bool>) {
        self.replicated_at_leaf_buffers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_replicated_at_leaf_buffers(&mut self) -> &mut ::std::vec::Vec<bool> {
        &mut self.replicated_at_leaf_buffers
    }

    // Take field
    pub fn take_replicated_at_leaf_buffers(&mut self) -> ::std::vec::Vec<bool> {
        ::std::mem::replace(&mut self.replicated_at_leaf_buffers, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ParameterReplication {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bool_into(wire_type, is, &mut self.replicated_at_leaf_buffers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += 2 * self.replicated_at_leaf_buffers.len() as u32;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.replicated_at_leaf_buffers {
            os.write_bool(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ParameterReplication {
        ParameterReplication::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "replicated_at_leaf_buffers",
                |m: &ParameterReplication| { &m.replicated_at_leaf_buffers },
                |m: &mut ParameterReplication| { &mut m.replicated_at_leaf_buffers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ParameterReplication>(
                "ParameterReplication",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ParameterReplication {
        static instance: ::protobuf::rt::LazyV2<ParameterReplication> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ParameterReplication::new)
    }
}

impl ::protobuf::Clear for ParameterReplication {
    fn clear(&mut self) {
        self.replicated_at_leaf_buffers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ParameterReplication {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ParameterReplication {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WhileLoopBackendConfig {
    // message fields
    pub known_trip_count: ::protobuf::SingularPtrField<WhileLoopBackendConfig_KnownTripCount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WhileLoopBackendConfig {
    fn default() -> &'a WhileLoopBackendConfig {
        <WhileLoopBackendConfig as ::protobuf::Message>::default_instance()
    }
}

impl WhileLoopBackendConfig {
    pub fn new() -> WhileLoopBackendConfig {
        ::std::default::Default::default()
    }

    // .xla.WhileLoopBackendConfig.KnownTripCount known_trip_count = 1;


    pub fn get_known_trip_count(&self) -> &WhileLoopBackendConfig_KnownTripCount {
        self.known_trip_count.as_ref().unwrap_or_else(|| <WhileLoopBackendConfig_KnownTripCount as ::protobuf::Message>::default_instance())
    }
    pub fn clear_known_trip_count(&mut self) {
        self.known_trip_count.clear();
    }

    pub fn has_known_trip_count(&self) -> bool {
        self.known_trip_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_known_trip_count(&mut self, v: WhileLoopBackendConfig_KnownTripCount) {
        self.known_trip_count = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_known_trip_count(&mut self) -> &mut WhileLoopBackendConfig_KnownTripCount {
        if self.known_trip_count.is_none() {
            self.known_trip_count.set_default();
        }
        self.known_trip_count.as_mut().unwrap()
    }

    // Take field
    pub fn take_known_trip_count(&mut self) -> WhileLoopBackendConfig_KnownTripCount {
        self.known_trip_count.take().unwrap_or_else(|| WhileLoopBackendConfig_KnownTripCount::new())
    }
}

impl ::protobuf::Message for WhileLoopBackendConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.known_trip_count {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.known_trip_count)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.known_trip_count.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.known_trip_count.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WhileLoopBackendConfig {
        WhileLoopBackendConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WhileLoopBackendConfig_KnownTripCount>>(
                "known_trip_count",
                |m: &WhileLoopBackendConfig| { &m.known_trip_count },
                |m: &mut WhileLoopBackendConfig| { &mut m.known_trip_count },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WhileLoopBackendConfig>(
                "WhileLoopBackendConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WhileLoopBackendConfig {
        static instance: ::protobuf::rt::LazyV2<WhileLoopBackendConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WhileLoopBackendConfig::new)
    }
}

impl ::protobuf::Clear for WhileLoopBackendConfig {
    fn clear(&mut self) {
        self.known_trip_count.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WhileLoopBackendConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WhileLoopBackendConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WhileLoopBackendConfig_KnownTripCount {
    // message fields
    pub n: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WhileLoopBackendConfig_KnownTripCount {
    fn default() -> &'a WhileLoopBackendConfig_KnownTripCount {
        <WhileLoopBackendConfig_KnownTripCount as ::protobuf::Message>::default_instance()
    }
}

impl WhileLoopBackendConfig_KnownTripCount {
    pub fn new() -> WhileLoopBackendConfig_KnownTripCount {
        ::std::default::Default::default()
    }

    // int64 n = 1;


    pub fn get_n(&self) -> i64 {
        self.n
    }
    pub fn clear_n(&mut self) {
        self.n = 0;
    }

    // Param is passed by value, moved
    pub fn set_n(&mut self, v: i64) {
        self.n = v;
    }
}

impl ::protobuf::Message for WhileLoopBackendConfig_KnownTripCount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.n = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.n != 0 {
            my_size += ::protobuf::rt::value_size(1, self.n, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.n != 0 {
            os.write_int64(1, self.n)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WhileLoopBackendConfig_KnownTripCount {
        WhileLoopBackendConfig_KnownTripCount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "n",
                |m: &WhileLoopBackendConfig_KnownTripCount| { &m.n },
                |m: &mut WhileLoopBackendConfig_KnownTripCount| { &mut m.n },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WhileLoopBackendConfig_KnownTripCount>(
                "WhileLoopBackendConfig.KnownTripCount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WhileLoopBackendConfig_KnownTripCount {
        static instance: ::protobuf::rt::LazyV2<WhileLoopBackendConfig_KnownTripCount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WhileLoopBackendConfig_KnownTripCount::new)
    }
}

impl ::protobuf::Clear for WhileLoopBackendConfig_KnownTripCount {
    fn clear(&mut self) {
        self.n = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WhileLoopBackendConfig_KnownTripCount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WhileLoopBackendConfig_KnownTripCount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum PrimitiveType {
    PRIMITIVE_TYPE_INVALID = 0,
    PRED = 1,
    S8 = 2,
    S16 = 3,
    S32 = 4,
    S64 = 5,
    U8 = 6,
    U16 = 7,
    U32 = 8,
    U64 = 9,
    F16 = 10,
    F32 = 11,
    BF16 = 16,
    F64 = 12,
    C64 = 15,
    C128 = 18,
    TUPLE = 13,
    OPAQUE_TYPE = 14,
    TOKEN = 17,
}

impl ::protobuf::ProtobufEnum for PrimitiveType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PrimitiveType> {
        match value {
            0 => ::std::option::Option::Some(PrimitiveType::PRIMITIVE_TYPE_INVALID),
            1 => ::std::option::Option::Some(PrimitiveType::PRED),
            2 => ::std::option::Option::Some(PrimitiveType::S8),
            3 => ::std::option::Option::Some(PrimitiveType::S16),
            4 => ::std::option::Option::Some(PrimitiveType::S32),
            5 => ::std::option::Option::Some(PrimitiveType::S64),
            6 => ::std::option::Option::Some(PrimitiveType::U8),
            7 => ::std::option::Option::Some(PrimitiveType::U16),
            8 => ::std::option::Option::Some(PrimitiveType::U32),
            9 => ::std::option::Option::Some(PrimitiveType::U64),
            10 => ::std::option::Option::Some(PrimitiveType::F16),
            11 => ::std::option::Option::Some(PrimitiveType::F32),
            16 => ::std::option::Option::Some(PrimitiveType::BF16),
            12 => ::std::option::Option::Some(PrimitiveType::F64),
            15 => ::std::option::Option::Some(PrimitiveType::C64),
            18 => ::std::option::Option::Some(PrimitiveType::C128),
            13 => ::std::option::Option::Some(PrimitiveType::TUPLE),
            14 => ::std::option::Option::Some(PrimitiveType::OPAQUE_TYPE),
            17 => ::std::option::Option::Some(PrimitiveType::TOKEN),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PrimitiveType] = &[
            PrimitiveType::PRIMITIVE_TYPE_INVALID,
            PrimitiveType::PRED,
            PrimitiveType::S8,
            PrimitiveType::S16,
            PrimitiveType::S32,
            PrimitiveType::S64,
            PrimitiveType::U8,
            PrimitiveType::U16,
            PrimitiveType::U32,
            PrimitiveType::U64,
            PrimitiveType::F16,
            PrimitiveType::F32,
            PrimitiveType::BF16,
            PrimitiveType::F64,
            PrimitiveType::C64,
            PrimitiveType::C128,
            PrimitiveType::TUPLE,
            PrimitiveType::OPAQUE_TYPE,
            PrimitiveType::TOKEN,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PrimitiveType>("PrimitiveType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for PrimitiveType {
}

impl ::std::default::Default for PrimitiveType {
    fn default() -> Self {
        PrimitiveType::PRIMITIVE_TYPE_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for PrimitiveType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Format {
    INVALID_FORMAT = 0,
    DENSE = 1,
    SPARSE = 2,
}

impl ::protobuf::ProtobufEnum for Format {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Format> {
        match value {
            0 => ::std::option::Option::Some(Format::INVALID_FORMAT),
            1 => ::std::option::Option::Some(Format::DENSE),
            2 => ::std::option::Option::Some(Format::SPARSE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Format] = &[
            Format::INVALID_FORMAT,
            Format::DENSE,
            Format::SPARSE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Format>("Format", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Format {
}

impl ::std::default::Default for Format {
    fn default() -> Self {
        Format::INVALID_FORMAT
    }
}

impl ::protobuf::reflect::ProtobufValue for Format {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum FftType {
    FFT = 0,
    IFFT = 1,
    RFFT = 2,
    IRFFT = 3,
}

impl ::protobuf::ProtobufEnum for FftType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FftType> {
        match value {
            0 => ::std::option::Option::Some(FftType::FFT),
            1 => ::std::option::Option::Some(FftType::IFFT),
            2 => ::std::option::Option::Some(FftType::RFFT),
            3 => ::std::option::Option::Some(FftType::IRFFT),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [FftType] = &[
            FftType::FFT,
            FftType::IFFT,
            FftType::RFFT,
            FftType::IRFFT,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<FftType>("FftType", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for FftType {
}

impl ::std::default::Default for FftType {
    fn default() -> Self {
        FftType::FFT
    }
}

impl ::protobuf::reflect::ProtobufValue for FftType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum RandomDistribution {
    RNG_INVALID = 0,
    RNG_UNIFORM = 1,
    RNG_NORMAL = 2,
}

impl ::protobuf::ProtobufEnum for RandomDistribution {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<RandomDistribution> {
        match value {
            0 => ::std::option::Option::Some(RandomDistribution::RNG_INVALID),
            1 => ::std::option::Option::Some(RandomDistribution::RNG_UNIFORM),
            2 => ::std::option::Option::Some(RandomDistribution::RNG_NORMAL),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [RandomDistribution] = &[
            RandomDistribution::RNG_INVALID,
            RandomDistribution::RNG_UNIFORM,
            RandomDistribution::RNG_NORMAL,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<RandomDistribution>("RandomDistribution", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for RandomDistribution {
}

impl ::std::default::Default for RandomDistribution {
    fn default() -> Self {
        RandomDistribution::RNG_INVALID
    }
}

impl ::protobuf::reflect::ProtobufValue for RandomDistribution {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n&tensorflow/compiler/xla/xla_data.proto\x12\x03xla\"\xf6\x01\n\rPaddin\
    gConfig\x12I\n\ndimensions\x18\x01\x20\x03(\x0b2).xla.PaddingConfig.Padd\
    ingConfigDimensionR\ndimensions\x1a\x99\x01\n\x16PaddingConfigDimension\
    \x12(\n\x10edge_padding_low\x18\x01\x20\x01(\x03R\x0eedgePaddingLow\x12*\
    \n\x11edge_padding_high\x18\x02\x20\x01(\x03R\x0fedgePaddingHigh\x12)\n\
    \x10interior_padding\x18\x03\x20\x01(\x03R\x0finteriorPadding\"+\n\tTile\
    Proto\x12\x1e\n\ndimensions\x18\x01\x20\x03(\x03R\ndimensions\"\xb0\x02\
    \n\x0bLayoutProto\x12#\n\x06format\x18\x04\x20\x01(\x0e2\x0b.xla.FormatR\
    \x06format\x12$\n\x0eminor_to_major\x18\x01\x20\x03(\x03R\x0cminorToMajo\
    r\x12.\n\x13max_sparse_elements\x18\x05\x20\x01(\x03R\x11maxSparseElemen\
    ts\x12$\n\x05tiles\x18\x06\x20\x03(\x0b2\x0e.xla.TileProtoR\x05tiles\x12\
    /\n\x14element_size_in_bits\x18\x07\x20\x01(\x03R\x11elementSizeInBits\
    \x12!\n\x0cmemory_space\x18\x08\x20\x01(\x03R\x0bmemorySpaceJ\x04\x08\
    \x02\x10\x03J\x04\x08\x03\x10\x04R\x11padded_dimensionsR\rpadding_value\
    \"\xff\x01\n\nShapeProto\x125\n\x0celement_type\x18\x02\x20\x01(\x0e2\
    \x12.xla.PrimitiveTypeR\x0belementType\x12\x1e\n\ndimensions\x18\x03\x20\
    \x03(\x03R\ndimensions\x122\n\x0ctuple_shapes\x18\x04\x20\x03(\x0b2\x0f.\
    xla.ShapeProtoR\x0btupleShapes\x12(\n\x06layout\x18\x05\x20\x01(\x0b2\
    \x10.xla.LayoutProtoR\x06layout\x120\n\x14is_dynamic_dimension\x18\x06\
    \x20\x03(\x08R\x12isDynamicDimensionJ\x04\x08\x01\x10\x02R\x04rank\"\x96\
    \x01\n\x11ProgramShapeProto\x12/\n\nparameters\x18\x01\x20\x03(\x0b2\x0f\
    .xla.ShapeProtoR\nparameters\x12'\n\x06result\x18\x02\x20\x01(\x0b2\x0f.\
    xla.ShapeProtoR\x06result\x12'\n\x0fparameter_names\x18\x03\x20\x03(\tR\
    \x0eparameterNames\"d\n\x10ComputationStats\x12\x1d\n\nflop_count\x18\
    \x01\x20\x01(\x01R\tflopCount\x121\n\x14transcendental_count\x18\x02\x20\
    \x01(\x01R\x13transcendentalCount\"\x80\x01\n\nOpMetadata\x12\x17\n\x07o\
    p_type\x18\x01\x20\x01(\tR\x06opType\x12\x17\n\x07op_name\x18\x02\x20\
    \x01(\tR\x06opName\x12\x1f\n\x0bsource_file\x18\x03\x20\x01(\tR\nsourceF\
    ile\x12\x1f\n\x0bsource_line\x18\x04\x20\x01(\x05R\nsourceLine\"\xeb\x02\
    \n\x10ExecutionProfile\x122\n\x15compilation_cache_hit\x18\x01\x20\x01(\
    \x08R\x13compilationCacheHit\x12&\n\x0fcompile_time_ms\x18\x02\x20\x01(\
    \x03R\rcompileTimeMs\x12.\n\x13compute_cycle_count\x18\x03\x20\x01(\x03R\
    \x11computeCycleCount\x12&\n\x0fcompute_time_ns\x18\x04\x20\x01(\x03R\rc\
    omputeTimeNs\x12>\n\x1ccompute_and_transfer_time_ns\x18\x05\x20\x01(\x03\
    R\x18computeAndTransferTimeNs\x127\n\x18executable_size_in_bytes\x18\x06\
    \x20\x01(\x03R\x15executableSizeInBytes\x12*\n\x11profile_cache_hit\x18\
    \x07\x20\x01(\x08R\x0fprofileCacheHit\")\n\x0fExecutionHandle\x12\x16\n\
    \x06handle\x18\x01\x20\x01(\x03R\x06handle\"*\n\x10GlobalDataHandle\x12\
    \x16\n\x06handle\x18\x01\x20\x01(\x03R\x06handle\"I\n\x0cDeviceHandle\
    \x12\x16\n\x06handle\x18\x01\x20\x01(\x03R\x06handle\x12!\n\x0cdevice_co\
    unt\x18\x02\x20\x01(\x03R\x0bdeviceCount\"\xc2\x01\n\rChannelHandle\x12\
    \x16\n\x06handle\x18\x01\x20\x01(\x03R\x06handle\x122\n\x04type\x18\x02\
    \x20\x01(\x0e2\x1e.xla.ChannelHandle.ChannelTypeR\x04type\"e\n\x0bChanne\
    lType\x12\x18\n\x14CHANNEL_TYPE_INVALID\x10\0\x12\x14\n\x10DEVICE_TO_DEV\
    ICE\x10\x01\x12\x12\n\x0eDEVICE_TO_HOST\x10\x02\x12\x12\n\x0eHOST_TO_DEV\
    ICE\x10\x03\"\x8b\x02\n\x15DeviceAssignmentProto\x12#\n\rreplica_count\
    \x18\x01\x20\x01(\x05R\x0creplicaCount\x12+\n\x11computation_count\x18\
    \x02\x20\x01(\x05R\x10computationCount\x12]\n\x13computation_devices\x18\
    \x03\x20\x03(\x0b2,.xla.DeviceAssignmentProto.ComputationDeviceR\x12comp\
    utationDevices\x1aA\n\x11ComputationDevice\x12,\n\x12replica_device_ids\
    \x18\x01\x20\x03(\x05R\x10replicaDeviceIds\"\xc4\x03\n\x0cLiteralProto\
    \x12%\n\x05shape\x18\x01\x20\x01(\x0b2\x0f.xla.ShapeProtoR\x05shape\x12\
    \x14\n\x05preds\x18\x02\x20\x03(\x08R\x05preds\x12\x10\n\x03s8s\x18\x0f\
    \x20\x01(\x0cR\x03s8s\x12\x10\n\x03u8s\x18\x03\x20\x01(\x0cR\x03u8s\x12\
    \x12\n\x04s32s\x18\x04\x20\x03(\x05R\x04s32s\x12\x12\n\x04s64s\x18\x05\
    \x20\x03(\x03R\x04s64s\x12\x12\n\x04u32s\x18\x06\x20\x03(\rR\x04u32s\x12\
    \x12\n\x04u64s\x18\x07\x20\x03(\x04R\x04u64s\x12\x12\n\x04f32s\x18\x08\
    \x20\x03(\x02R\x04f32s\x12\x12\n\x04f64s\x18\t\x20\x03(\x01R\x04f64s\x12\
    \x12\n\x04c64s\x18\x0c\x20\x03(\x02R\x04c64s\x12\x14\n\x05c128s\x18\x12\
    \x20\x03(\x01R\x05c128s\x128\n\x0etuple_literals\x18\n\x20\x03(\x0b2\x11\
    .xla.LiteralProtoR\rtupleLiterals\x12\x12\n\x04f16s\x18\x0b\x20\x01(\x0c\
    R\x04f16s\x12\x14\n\x05bf16s\x18\r\x20\x01(\x0cR\x05bf16s\x12\x12\n\x04u\
    16s\x18\x10\x20\x01(\x0cR\x04u16s\x12\x12\n\x04s16s\x18\x11\x20\x01(\x0c\
    R\x04s16s\x12%\n\x0esparse_indices\x18\x0e\x20\x03(\x03R\rsparseIndices\
    \"\xf8\x01\n\x0fWindowDimension\x12\x12\n\x04size\x18\x01\x20\x01(\x03R\
    \x04size\x12\x16\n\x06stride\x18\x02\x20\x01(\x03R\x06stride\x12\x1f\n\
    \x0bpadding_low\x18\x03\x20\x01(\x03R\npaddingLow\x12!\n\x0cpadding_high\
    \x18\x04\x20\x01(\x03R\x0bpaddingHigh\x12'\n\x0fwindow_dilation\x18\x05\
    \x20\x01(\x03R\x0ewindowDilation\x12#\n\rbase_dilation\x18\x06\x20\x01(\
    \x03R\x0cbaseDilation\x12'\n\x0fwindow_reversal\x18\x07\x20\x01(\x08R\
    \x0ewindowReversal\">\n\x06Window\x124\n\ndimensions\x18\x01\x20\x03(\
    \x0b2\x14.xla.WindowDimensionR\ndimensions\"\xbd\x01\n\x16GatherDimensio\
    nNumbers\x12\x1f\n\x0boffset_dims\x18\x01\x20\x03(\x03R\noffsetDims\x120\
    \n\x14collapsed_slice_dims\x18\x02\x20\x03(\x03R\x12collapsedSliceDims\
    \x12&\n\x0fstart_index_map\x18\x03\x20\x03(\x03R\rstartIndexMap\x12(\n\
    \x10index_vector_dim\x18\x04\x20\x01(\x03R\x0eindexVectorDim\"\xe3\x01\n\
    \x17ScatterDimensionNumbers\x12,\n\x12update_window_dims\x18\x01\x20\x03\
    (\x03R\x10updateWindowDims\x120\n\x14inserted_window_dims\x18\x02\x20\
    \x03(\x03R\x12insertedWindowDims\x12>\n\x1cscatter_dims_to_operand_dims\
    \x18\x03\x20\x03(\x03R\x18scatterDimsToOperandDims\x12(\n\x10index_vecto\
    r_dim\x18\x04\x20\x01(\x03R\x0eindexVectorDim\"\xb7\x04\n\x1bConvolution\
    DimensionNumbers\x122\n\x15input_batch_dimension\x18\x07\x20\x01(\x03R\
    \x13inputBatchDimension\x126\n\x17input_feature_dimension\x18\x08\x20\
    \x01(\x03R\x15inputFeatureDimension\x128\n\x18input_spatial_dimensions\
    \x18\x0b\x20\x03(\x03R\x16inputSpatialDimensions\x12C\n\x1ekernel_input_\
    feature_dimension\x18\x03\x20\x01(\x03R\x1bkernelInputFeatureDimension\
    \x12E\n\x1fkernel_output_feature_dimension\x18\x04\x20\x01(\x03R\x1ckern\
    elOutputFeatureDimension\x12:\n\x19kernel_spatial_dimensions\x18\x06\x20\
    \x03(\x03R\x17kernelSpatialDimensions\x124\n\x16output_batch_dimension\
    \x18\t\x20\x01(\x03R\x14outputBatchDimension\x128\n\x18output_feature_di\
    mension\x18\n\x20\x01(\x03R\x16outputFeatureDimension\x12:\n\x19output_s\
    patial_dimensions\x18\x0c\x20\x03(\x03R\x17outputSpatialDimensions\"\xf5\
    \x01\n\x13DotDimensionNumbers\x12<\n\x1alhs_contracting_dimensions\x18\
    \x01\x20\x03(\x03R\x18lhsContractingDimensions\x12<\n\x1arhs_contracting\
    _dimensions\x18\x02\x20\x03(\x03R\x18rhsContractingDimensions\x120\n\x14\
    lhs_batch_dimensions\x18\x03\x20\x03(\x03R\x12lhsBatchDimensions\x120\n\
    \x14rhs_batch_dimensions\x18\x04\x20\x03(\x03R\x12rhsBatchDimensions\"\
    \x8a\x02\n\x16TriangularSolveOptions\x12\x1b\n\tleft_side\x18\x01\x20\
    \x01(\x08R\x08leftSide\x12\x14\n\x05lower\x18\x02\x20\x01(\x08R\x05lower\
    \x12#\n\runit_diagonal\x18\x03\x20\x01(\x08R\x0cunitDiagonal\x12F\n\x0bt\
    ranspose_a\x18\x04\x20\x01(\x0e2%.xla.TriangularSolveOptions.TransposeR\
    \ntransposeA\"P\n\tTranspose\x12\x15\n\x11TRANSPOSE_INVALID\x10\0\x12\
    \x10\n\x0cNO_TRANSPOSE\x10\x01\x12\r\n\tTRANSPOSE\x10\x02\x12\x0b\n\x07A\
    DJOINT\x10\x03\"'\n\x0fCholeskyOptions\x12\x14\n\x05lower\x18\x01\x20\
    \x01(\x08R\x05lower\"\xd1\x02\n\nOpSharding\x12(\n\x04type\x18\x01\x20\
    \x01(\x0e2\x14.xla.OpSharding.TypeR\x04type\x12.\n\ntile_shape\x18\x02\
    \x20\x01(\x0b2\x0f.xla.ShapeProtoR\ttileShape\x12<\n\x1atile_assignment_\
    dimensions\x18\x03\x20\x03(\x03R\x18tileAssignmentDimensions\x126\n\x17t\
    ile_assignment_devices\x18\x04\x20\x03(\x03R\x15tileAssignmentDevices\
    \x128\n\x0ftuple_shardings\x18\x05\x20\x03(\x0b2\x0f.xla.OpShardingR\x0e\
    tupleShardings\"9\n\x04Type\x12\x0e\n\nREPLICATED\x10\0\x12\x0b\n\x07MAX\
    IMAL\x10\x01\x12\t\n\x05TUPLE\x10\x02\x12\t\n\x05OTHER\x10\x03\"/\n\x0cR\
    eplicaGroup\x12\x1f\n\x0breplica_ids\x18\x01\x20\x03(\x03R\nreplicaIds\"\
    >\n\x0cSourceTarget\x12\x16\n\x06source\x18\x01\x20\x01(\x03R\x06source\
    \x12\x16\n\x06target\x18\x02\x20\x01(\x03R\x06target\"\x8f\x01\n\x0fPrec\
    isionConfig\x12K\n\x11operand_precision\x18\x01\x20\x03(\x0e2\x1e.xla.Pr\
    ecisionConfig.PrecisionR\x10operandPrecision\"/\n\tPrecision\x12\x0b\n\
    \x07DEFAULT\x10\0\x12\x08\n\x04HIGH\x10\x01\x12\x0b\n\x07HIGHEST\x10\x02\
    \"S\n\x14ParameterReplication\x12;\n\x1areplicated_at_leaf_buffers\x18\
    \x01\x20\x03(\x08R\x17replicatedAtLeafBuffers\"\x8e\x01\n\x16WhileLoopBa\
    ckendConfig\x12T\n\x10known_trip_count\x18\x01\x20\x01(\x0b2*.xla.WhileL\
    oopBackendConfig.KnownTripCountR\x0eknownTripCount\x1a\x1e\n\x0eKnownTri\
    pCount\x12\x0c\n\x01n\x18\x01\x20\x01(\x03R\x01n*\xda\x01\n\rPrimitiveTy\
    pe\x12\x1a\n\x16PRIMITIVE_TYPE_INVALID\x10\0\x12\x08\n\x04PRED\x10\x01\
    \x12\x06\n\x02S8\x10\x02\x12\x07\n\x03S16\x10\x03\x12\x07\n\x03S32\x10\
    \x04\x12\x07\n\x03S64\x10\x05\x12\x06\n\x02U8\x10\x06\x12\x07\n\x03U16\
    \x10\x07\x12\x07\n\x03U32\x10\x08\x12\x07\n\x03U64\x10\t\x12\x07\n\x03F1\
    6\x10\n\x12\x07\n\x03F32\x10\x0b\x12\x08\n\x04BF16\x10\x10\x12\x07\n\x03\
    F64\x10\x0c\x12\x07\n\x03C64\x10\x0f\x12\x08\n\x04C128\x10\x12\x12\t\n\
    \x05TUPLE\x10\r\x12\x0f\n\x0bOPAQUE_TYPE\x10\x0e\x12\t\n\x05TOKEN\x10\
    \x11*3\n\x06Format\x12\x12\n\x0eINVALID_FORMAT\x10\0\x12\t\n\x05DENSE\
    \x10\x01\x12\n\n\x06SPARSE\x10\x02*1\n\x07FftType\x12\x07\n\x03FFT\x10\0\
    \x12\x08\n\x04IFFT\x10\x01\x12\x08\n\x04RFFT\x10\x02\x12\t\n\x05IRFFT\
    \x10\x03*F\n\x12RandomDistribution\x12\x0f\n\x0bRNG_INVALID\x10\0\x12\
    \x0f\n\x0bRNG_UNIFORM\x10\x01\x12\x0e\n\nRNG_NORMAL\x10\x02B\x03\xf8\x01\
    \x01b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
